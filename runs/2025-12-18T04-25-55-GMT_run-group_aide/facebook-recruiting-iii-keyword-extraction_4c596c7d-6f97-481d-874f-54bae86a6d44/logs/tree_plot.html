<!doctype html>
<html lang="en"> 
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script
      id="p5scripttag"
      src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"
      integrity="sha512-uaz5GpnQoE6t5echKlX8P52czvsIGgLPcvlzfvRubLZ1Hp8JemUDnbUiAahbVtPb+jUVrNETuXvAhDDF/N3M4w=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>

    <script>
      const bgCol = "#F2F0E7";
const accentCol = "#fd4578";

hljs.initHighlightingOnLoad();

const updateTargetDims = () => {
  // width is max-width of `.contentContainer` - its padding
  // return [min(windowWidth, 900 - 80), 700]
  return [windowWidth * (1 / 2), windowHeight];
};

const setCodeAndPlan = (code, plan) => {
  const codeElm = document.getElementById("code");
  if (codeElm) {
    // codeElm.innerText = code;
    codeElm.innerHTML = hljs.highlight(code, { language: "python" }).value;
  }

  const planElm = document.getElementById("plan");
  if (planElm) {
    // planElm.innerText = plan.trim();
    planElm.innerHTML = hljs.highlight(plan, { language: "plaintext" }).value;
  }
};

windowResized = () => {
  resizeCanvas(...updateTargetDims());
  awaitingPostResizeOps = true;
};

const animEase = (t) => 1 - (1 - Math.min(t, 1.0)) ** 5;

// ---- global constants ----

const globalAnimSpeed = 1.1;
const scaleFactor = 0.57;

// ---- global vars ----

let globalTime = 0;
let manualSelection = false;

let currentElemInd = 0;

let treeStructData = {"edges": [[0, 6], [3, 5], [5, 7], [7, 8], [8, 9], [9, 10], [10, 11], [11, 12], [12, 13], [13, 14], [14, 15], [15, 16], [16, 17], [17, 18], [18, 19]], "layout": [[0.0, 0.0], [0.25, 0.0], [0.5, 0.0], [0.75, 0.0], [1.0, 0.0], [0.75, 0.0714285714285714], [0.0, 0.0714285714285714], [0.75, 0.1428571428571429], [0.75, 0.2142857142857143], [0.75, 0.2857142857142857], [0.75, 0.3571428571428571], [0.75, 0.4285714285714286], [0.75, 0.5], [0.75, 0.5714285714285714], [0.75, 0.6428571428571428], [0.75, 0.7142857142857143], [0.75, 0.7857142857142857], [0.75, 0.8571428571428572], [0.75, 0.9285714285714286], [0.75, 1.0]], "plan": ["I will train a simple but scalable multi-label text classifier: combine\nTitle+Body, vectorize with TF-IDF (limited features), restrict to the top-K most\nfrequent tags, and train a One-vs-Rest linear classifier (SGD with log loss) on\na random sample of the training data to keep memory/time reasonable. I will\nevaluate using sample-wise mean F1-score (sklearn's average='samples') via\n3-fold cross-validation on the sampled training set, print that score, then\nretrain on the full sampled set and produce predictions for the provided test\nset, saving them to ./submission/submission.csv. The model will stream-test in\nchunks to avoid memory spikes and will ensure every test row gets at least one\npredicted tag (fallback to the highest-scoring tag).", "I will build a compact multi-label baseline: pick the most frequent tags, train\nOne-vs-Rest linear classifiers on TF-IDF features of Title+Body using a\nmanageable random/sample subset of the huge training file, and evaluate with\n5-fold cross-validation using the sample-wise F1 (mean F1 per example) which\nmatches the competition metric. After CV I will retrain on the sampled training\nset and predict the top-3 tags per test question in chunks, writing the required\nsubmission CSV. The code prints the cross-validation mean sample-F1 and writes\n./submission/submission.csv.", "I will train a compact multilabel text classifier that predicts tags from\nquestion title+body. I will read a manageable sample of the training data,\nextract the top K frequent tags, vectorize text with TF-IDF (unigrams+bigrams),\nand train a One-vs-Rest linear classifier (SGD with log loss). I'll evaluate\nwith 5-fold cross-validation using the sample-wise F1 score (average='samples')\nand finally predict the top 3 tags per test example and write\n./submission/submission.csv.", "I will train a compact multilabel text classifier: sample a manageable subset of\nthe training set, keep the top-K most frequent tags, vectorize Title+Body with\nTF-IDF (1-2 grams) and train a One-vs-Rest linear SGD classifier. I'll evaluate\nwith 5-fold cross-validation using the sample-wise F1 score (average='samples'),\nthen retrain on the sampled data and predict the top-3 tags per test example and\nsave them to ./submission/submission.csv. The script prints the 5-fold sample-\nwise F1 and writes the required submission file.", "I will train a compact multilabel classifier that predicts tags from the\nquestion Title+Body. The plan: (1) scan the training file to find the top-K most\nfrequent tags, (2) sample up to N training examples that contain at least one of\nthose top-K tags, (3) vectorize text with a TfidfVectorizer (unigrams+bigrams,\ncapped features), (4) train a One-vs-Rest MultinomialNB classifier and evaluate\nwith 5-fold CV using the sample-wise F1 (average='samples'), and (5) retrain on\nthe sampled training set and generate predictions for the test set (top-3 tags\nper question) and save submission/submission.csv. The reported evaluation metric\nwill be the mean sample-wise F1 across the 5 folds.", "I'll fix the submission bug by simplifying and stabilizing the data pipeline:\nfirst do a fast tag-frequency pass over a modest number of rows to pick top-K\ntags, then stream the train file again to collect a bounded sample of examples\nthat contain those tags. I'll vectorize Title+Body with TF-IDF, binarize labels\nfor the chosen tags, run a 3-fold cross-validation to compute a sample-wise F1,\nretrain on the full sampled data, and then predict on the provided test set in\nchunks and ensure a submission CSV is written to ./submission/submission.csv.\nThe code uses robust top-k selection for predictions and conservative resource\nsettings to avoid parallelism/numpy pitfalls that could previously prevent\noutput being written.", "I will fix the original script by making label binarization tied explicitly to\nthe top-K tag list (so class order is stable), using a smaller sampled training\nsubset to keep runtime reasonable, and handling the \"no predicted tags\" case\nrobustly using decision scores' per-row argmax (with fallbacks). I'll run a\nk-fold CV to print a sample-wise F1, retrain on the full sampled data, and\nstream predictions on the test set in chunks writing\n./submission/submission.csv. The code includes safer handling for sparse\ndecision matrices and ensures the submission file is always created.", "I will fix the submission generation and a few logic bugs: properly use per-row\nargmax when no labels are selected, avoid passing fixed \"classes\" into\nMultiLabelBinarizer (which can mismatch), and make the pipeline more robust for\nlarge files by sampling a limited number of training rows and using chunked I/O.\nThe script below collects a reasonable training sample containing only top tags,\nbuilds TF-IDF features, does 5-fold cross-validated predictions to compute\nsample-wise F1, retrains on full sampled data, predicts the test set in chunks,\nand writes the required ./submission/submission.csv file. The printed output is\nthe cross-validated sample-wise F1.", "I will fix the previous script by (1) ensuring the mapping between modeled tags\nand label binarizer is explicit (pass the selected top tags as the\nMultiLabelBinarizer classes so mlb.classes_ order is guaranteed), (2) making tag\nparsing robust, (3) handling cross_val_predict fallbacks gracefully\n(decision_function -> predict_proba -> predict) and aligning shapes, and (4)\nwriting a guaranteed submission CSV in ./submission/submission.csv. The\nimplementation samples a manageable number of training rows for speed, computes\na TF-IDF representation, evaluates with cross-validated top-k F1 (printed),\nretrains on full sampled data, and writes test predictions in chunks.", "I will fix robustness and runtime issues by: (1) sampling a manageable portion\nof the huge train file to compute the most frequent tags, (2) collecting a\nmoderate number of training examples that contain those top tags, (3) using a\nlightweight One-vs-Rest logistic classifier with TF-IDF features, (4) performing\nK-fold cross-validation (printing the sample-wise F1) and then retraining on all\nsampled data, and (5) predicting the required top-K tags for the test set in\nchunks and saving them to ./submission/submission.csv. The code is defensive\nabout large files, uses chunked reads, and falls back gracefully if a cross-val\nmethod fails.", "I will fix the previous script by making the sampling and tag selection robust\nand faster (smaller defaults to ensure completion), ensuring label-to-class\nalignment is explicit when binarizing and when mapping back predicted indices to\ntags, and by always writing the submission file to ./submission/submission.csv.\nI'll also compute and print a cross-validated sample-wise F1 on the sampled\ntraining set and then retrain on the sampled data to predict the test set in\nchunks, writing a valid submission CSV. The script includes safer fallbacks for\nprediction methods (decision_function, predict_proba, predict) and handles empty\npredictions by selecting the top-scoring tag.", "I'll fix the previous script by replacing the fragile cross_val_predict usage\nwith a robust manual cross-validation loop that clones and fits the\nOneVsRestClassifier on each fold and collects predicted probabilities; this\navoids method dispatch failures and works for multilabel targets. I'll also make\nthe streaming reads and tag parsing more defensive, ensure the\nMultiLabelBinarizer classes match the chosen top tags, and always write the\nrequired ./submission/submission.csv file. The script prints the cross-validated\nsample-wise F1 score to stdout, retrains on the full sampled training set,\npredicts the test set in chunks, and writes the final submission.", "I'll fix the pipeline by making the data sampling and tag counting robust to\nlarge files, ensuring the label binarizer and class ordering are consistent,\nperforming a safe manual cross-validation that falls back between\ndecision_function and predict_proba, and always writing a submission CSV to\n./submission/submission.csv. The script will sample a manageable training subset\ncontaining examples with the most frequent tags, vectorize text with TF-IDF, run\nk-fold CV to compute and print the sample-wise F1, retrain on all sampled data,\npredict in chunks on the provided test set, and write the required submission\nfile. I've added error handling for different predictor outputs and ensured the\noutput format matches the competition requirements.", "I will make the pipeline more robust by adding fallbacks at every fragile step:\nensure top tags are selected even if the fast pass finds few tags, collect a\nfixed-size sampled training set (with a fallback to taking the first N rows if\nnot enough matches), and guard prediction shapes when using decision_function /\npredict_proba / predict. I will compute a 5-fold cross-validated sample-wise F1\non the sampled training set and print it, then retrain on the full sampled set\nand produce predictions on the provided test.csv, writing the required\n./submission/submission.csv file. The code uses chunked reading to keep memory\nusage reasonable and limits TF-IDF features to finish quickly.", "I fixed the sampling / training pipeline to be more robust and ensured a\nsubmission is always written. The fix: perform a fast reliable top-tag count on\na limited number of rows, sample training rows containing those tags up to a\ntarget, build a TF-IDF + OneVsRest LogisticRegression model, perform manual\nK-fold CV to compute a sample-wise F1, then retrain on all sampled data and\npredict on the (chunked) test set. The script includes many shape/safety checks\nand always writes ./submission/submission.csv and prints the CV F1 to stdout.", "I will fix the prior pipeline by making the data sampling and tag counting more\nrobust, reducing sample sizes for reliability, and ensuring the submission file\nis always written. I'll add clearer fallbacks when tag extraction fails, enforce\nat-least-one-tag predictions, and print the cross-validated sample-wise F1. The\nscript will sample a manageable number of training rows that contain frequent\ntags, train a One-vs-Rest logistic model with TF-IDF features, evaluate via\nK-fold CV, retrain on all sampled data, and then predict the provided test set\nin chunks and save ./submission/submission.csv.", "I'll simplify and harden the pipeline so it reliably creates a submission: read\na modest first portion of train.csv to extract frequent tags, collect a sample\nof training rows containing those top tags (with a fallback to fill up the\nsample), build TF-IDF features, run a 5-fold manual cross-validation with a One-\nvs-Rest logistic classifier to print a sample-wise F1 score, retrain on the full\nsampled data, then predict the provided test set in chunks and save the\nresulting submission to ./submission/submission.csv. I'll add robust parsing,\nshape checks and safe fallbacks so the script never exits early and always\nwrites a valid CSV with Id and space-separated tags. The implementation is tuned\nto run within the contest limits and prints the cross-validated F1 before\nwriting the submission.", "I fixed robustness and sampling issues that could prevent producing a\nsubmission: I simplified and hardened tag parsing, reliably extract frequent\ntags from the head of the file, collect a randomized but bounded sample of\ntraining rows containing those tags, and ensure label alignment before model\ntraining. I also added safer fallbacks for prediction methods, ensured cross-\nvalidated probability estimation for the sample-wise F1 metric, and explicitly\nwrite the final predictions to ./submission/submission.csv while printing the CV\nF1. The code reads train/test in chunks so it will run within resource limits.", "I will simplify and harden the pipeline: reliably extract the most frequent tags\nfrom the train file using a safe chunked scan, collect a fixed-size sampled\ntraining set that contains those tags, build TF-IDF features, train a One-vs-\nRest logistic regression model, evaluate with K-fold CV (manual fold loop to\nensure robust predict_proba/decision_function handling) and finally retrain on\nall sampled data and write predictions for the provided test set. I also add\nextra safeguards for I/O, align shapes when some classes are missing in\nindividual folds, and ensure the submission CSV is written to\n./submission/submission.csv (and copied to ./working/ for convenience). The\nscript prints the cross-validated sample-wise F1 score to stdout before writing\nthe submission.", "I'll fix the pipeline by simplifying and stabilizing the training/prediction\nsteps: (1) compute top tags from a head of the training file and collect a\nmanageable sampled training set that contains those tags; (2) use TF-IDF on\nTitle+Body and a MultiLabelBinarizer fixed to the top tags; (3) perform K-fold\ncross-validation but train per-class binary LogisticRegression models inside\neach fold (this avoids estimator column-alignment issues), compute per-sample\nscores, convert to top-k predictions and report sample-wise F1; (4) retrain per-\nclass models on all sampled data and predict the test set in chunks, writing\nsubmission/submission.csv and copying to working/submission.csv. The code below\nimplements these fixes and prints the CV F1."], "code": ["import os\nimport sys\nimport gc\nimport numpy as np\nimport pandas as pd\nfrom collections import Counter\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.linear_model import SGDClassifier\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.model_selection import KFold\nfrom sklearn.metrics import f1_score\nfrom scipy import sparse\n\n# Configuration / hyperparameters\nRANDOM_STATE = 42\nSAMPLE_ROWS = 200000  # number of training rows to use (to keep runtime reasonable)\nTOP_K_TAGS = 500  # only predict top-K most frequent tags\nTFIDF_MAX_FEATURES = 50000  # size of TF-IDF vocabulary\nN_FOLDS = 3  # folds for cross-validation\nSGD_MAX_ITER = 5  # iterations for SGDClassifier (quick)\nCHUNK_SIZE_TEST = 20000  # rows per chunk when processing test set\n\nINPUT_DIR = \"./input\"\nTRAIN_FILE = os.path.join(INPUT_DIR, \"train.csv\")\nTEST_FILE = os.path.join(INPUT_DIR, \"test.csv\")\nSUBMISSION_DIR = \"./submission\"\nSUBMISSION_FILE = os.path.join(SUBMISSION_DIR, \"submission.csv\")\n\nos.makedirs(SUBMISSION_DIR, exist_ok=True)\n\n\n# Utility: sample first SAMPLE_ROWS rows (reading sequentially for speed)\ndef load_train_sample(train_file, nrows):\n    # read in chunks to handle very large file if necessary\n    df_list = []\n    read = 0\n    chunksize = 50000\n    for chunk in pd.read_csv(\n        train_file, usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"], chunksize=chunksize\n    ):\n        df_list.append(chunk)\n        read += len(chunk)\n        if read >= nrows:\n            break\n    df = pd.concat(df_list, ignore_index=True)\n    if len(df) > nrows:\n        df = df.iloc[:nrows].reset_index(drop=True)\n    return df\n\n\nprint(\"Loading training sample...\")\ntrain_df = load_train_sample(TRAIN_FILE, SAMPLE_ROWS)\nprint(f\"Train sample shape: {train_df.shape}\")\n\n# Preprocess tags into lists\ntrain_df[\"TagList\"] = train_df[\"Tags\"].apply(lambda x: x.split())\n\n# Determine top-K tags\ntag_counter = Counter()\nfor tags in train_df[\"TagList\"]:\n    tag_counter.update(tags)\nmost_common_tags = set([t for t, _ in tag_counter.most_common(TOP_K_TAGS)])\nprint(f\"Selected top-{TOP_K_TAGS} tags (unique): {len(most_common_tags)}\")\n\n\n# Filter tags to top-K and drop rows that end up with no labels (can't train on them)\ndef filter_topk(tags):\n    return [t for t in tags if t in most_common_tags]\n\n\ntrain_df[\"FilteredTags\"] = train_df[\"TagList\"].apply(filter_topk)\ntrain_df = train_df[train_df[\"FilteredTags\"].map(len) > 0].reset_index(drop=True)\nprint(f\"After filtering to top-{TOP_K_TAGS} tags, training rows: {len(train_df)}\")\n\n# Build text field\ntrain_texts = (\n    (train_df[\"Title\"].fillna(\"\") + \" \" + train_df[\"Body\"].fillna(\"\"))\n    .astype(str)\n    .values\n)\ntrain_labels = list(train_df[\"FilteredTags\"])\n\n# Binarize labels\nmlb = MultiLabelBinarizer()\nmlb.fit(train_labels)  # classes will be the top-K tags subset present\nprint(f\"Number of classes (after binarizer): {len(mlb.classes_)}\")\n\nY = mlb.transform(train_labels)\nprint(f\"Label matrix shape: {Y.shape}\")\n\n# TF-IDF vectorization\nprint(\"Fitting TF-IDF vectorizer...\")\ntfidf = TfidfVectorizer(\n    max_features=TFIDF_MAX_FEATURES, ngram_range=(1, 2), stop_words=\"english\"\n)\nX = tfidf.fit_transform(train_texts)\nprint(f\"TF-IDF matrix shape: {X.shape}\")\n\n# Free memory\ndel train_texts\ngc.collect()\n\n# Cross-validation (K-fold) evaluation using One-vs-Rest with SGDClassifier\nkf = KFold(n_splits=N_FOLDS, shuffle=True, random_state=RANDOM_STATE)\nfold = 0\nf1_scores = []\n\nprint(f\"Starting {N_FOLDS}-fold cross-validation...\")\nfor train_idx, val_idx in kf.split(X):\n    fold += 1\n    print(\n        f\"Fold {fold} - training on {len(train_idx)} samples, validating on {len(val_idx)} samples\"\n    )\n    X_train, X_val = X[train_idx], X[val_idx]\n    Y_train, Y_val = Y[train_idx], Y[val_idx]\n\n    classifier = OneVsRestClassifier(\n        SGDClassifier(loss=\"log\", max_iter=SGD_MAX_ITER, random_state=RANDOM_STATE),\n        n_jobs=-1,\n    )\n    classifier.fit(X_train, Y_train)\n    # decision_function -> convert to binary by thresholding at 0.0\n    try:\n        dec = classifier.decision_function(X_val)\n        Y_pred = (dec > 0.0).astype(int)\n    except Exception:\n        # fallback to predict\n        Y_pred = classifier.predict(X_val)\n\n    # For any sample with no predicted labels, pick top scoring label\n    # (ensure at least one tag per sample)\n    no_pred = Y_pred.sum(axis=1) == 0\n    if np.any(no_pred):\n        if isinstance(dec, np.ndarray):\n            top_idx = dec.argmax(axis=1)\n        else:  # sparse\n            top_idx = np.asarray(dec.todense()).argmax(axis=1)\n        for i, flag in enumerate(no_pred):\n            if flag:\n                Y_pred[i, top_idx[i]] = 1\n\n    score = f1_score(Y_val, Y_pred, average=\"samples\")\n    f1_scores.append(score)\n    print(f\"Fold {fold} F1 (samples): {score:.5f}\")\n\nmean_f1 = np.mean(f1_scores)\nprint(f\"{N_FOLDS}-fold mean sample-wise F1: {mean_f1:.5f}\")\n\n# Retrain on full sampled training set\nprint(\"Retraining on full sampled training data...\")\nfinal_clf = OneVsRestClassifier(\n    SGDClassifier(loss=\"log\", max_iter=SGD_MAX_ITER, random_state=RANDOM_STATE),\n    n_jobs=-1,\n)\nfinal_clf.fit(X, Y)\nprint(\"Final model trained.\")\n\n# Process test set in chunks and write submission\nprint(\"Processing test set and writing submission...\")\nif os.path.exists(SUBMISSION_FILE):\n    os.remove(SUBMISSION_FILE)\n\n# Write header\nwith open(SUBMISSION_FILE, \"w\", encoding=\"utf-8\") as f:\n    f.write(\"Id,Tags\\n\")\n\n# Stream test file in chunks\ntest_reader = pd.read_csv(\n    TEST_FILE, usecols=[\"Id\", \"Title\", \"Body\"], chunksize=CHUNK_SIZE_TEST\n)\nfor chunk_idx, chunk in enumerate(test_reader):\n    ids = chunk[\"Id\"].values\n    texts = (\n        (chunk[\"Title\"].fillna(\"\") + \" \" + chunk[\"Body\"].fillna(\"\")).astype(str).values\n    )\n    X_test = tfidf.transform(texts)\n    try:\n        dec = final_clf.decision_function(X_test)\n        Y_test_pred = (dec > 0.0).astype(int)\n    except Exception:\n        Y_test_pred = final_clf.predict(X_test)\n        dec = None\n\n    # Ensure at least one tag per sample\n    no_pred = Y_test_pred.sum(axis=1) == 0\n    if np.any(no_pred):\n        # compute top index using decision scores if available, otherwise use classifier.predict_proba if exists\n        if dec is None:\n            # fallback: use argmax over linear models via predict_proba if possible\n            try:\n                probs = final_clf.predict_proba(X_test)\n                top_idx = probs.argmax(axis=1)\n            except Exception:\n                # ultimate fallback: assign most frequent tag\n                top_idx = np.zeros(len(ids), dtype=int)\n        else:\n            top_idx = dec.argmax(axis=1)\n        for i, flag in enumerate(no_pred):\n            if flag:\n                Y_test_pred[i, top_idx[i]] = 1\n\n    # Convert predictions to tag strings\n    tag_arrays = mlb.inverse_transform(Y_test_pred)\n    lines = []\n    for id_val, tags in zip(ids, tag_arrays):\n        if len(tags) == 0:\n            tag_str = mlb.classes_[0]  # fallback to most frequent tag\n        else:\n            tag_str = \" \".join(tags)\n        # Ensure tags with commas or quotes are handled by quoting; sample_submission uses quotes but simple CSV is fine\n        lines.append(f'{id_val},\"{tag_str}\"\\n')\n\n    # Append to file\n    with open(SUBMISSION_FILE, \"a\", encoding=\"utf-8\") as f:\n        f.writelines(lines)\n\n    print(f\"Processed test chunk {chunk_idx+1}, wrote {len(ids)} rows.\")\n    # free\n    del X_test, texts, ids, Y_test_pred, tag_arrays\n    gc.collect()\n\nprint(f\"Submission saved to {SUBMISSION_FILE}\")\nprint(f\"Cross-validation mean sample-wise F1: {mean_f1:.6f}\")\n", "import os\nimport gc\nimport sys\nimport random\nfrom collections import Counter, defaultdict\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.linear_model import SGDClassifier\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.model_selection import KFold\nfrom sklearn.metrics import f1_score\n\n# Configuration - keep modest to fit compute/memory\nTOP_K_TAGS = 200  # number of most frequent tags to model\nSAMPLE_SIZE = 100000  # number of training rows to sample for modeling\nTFIDF_MAX_FEATURES = 50000\nNGRAM_RANGE = (1, 2)\nRANDOM_STATE = 42\nTOP_PRED_PER_ROW = 3  # number of tags to predict per sample in submission\nTRAIN_PATH = \"./input/train.csv\"\nTEST_PATH = \"./input/test.csv\"\nSUBMISSION_PATH = \"./submission/submission.csv\"\n\nos.makedirs(os.path.dirname(SUBMISSION_PATH), exist_ok=True)\nrandom.seed(RANDOM_STATE)\nnp.random.seed(RANDOM_STATE)\n\n# Step 1: scan train.csv to get tag frequencies\nprint(\"Scanning training file to compute tag frequencies...\")\ntag_counter = Counter()\nchunksize = 200000\ntrain_rows_total = 0\nfor chunk in pd.read_csv(TRAIN_PATH, usecols=[\"Tags\"], chunksize=chunksize):\n    train_rows_total += len(chunk)\n    # Tags are space separated\n    for tags in chunk[\"Tags\"].fillna(\"\"):\n        if not tags:\n            continue\n        for t in tags.split():\n            tag_counter[t] += 1\nprint(f\"Total training rows scanned: {train_rows_total}\")\nprint(f\"Total distinct tags found: {len(tag_counter)}\")\n\ntop_tags = [t for t, _ in tag_counter.most_common(TOP_K_TAGS)]\ntop_tag_set = set(top_tags)\nprint(f\"Selected top {len(top_tags)} tags (most frequent).\")\n\n# Step 2: sample rows for modeling, preferring rows that contain top tags\nprint(\"Sampling training rows for modeling...\")\nsample_indices = []\nsample_texts = []\nsample_tag_lists = []\n\n# We'll iterate again and collect rows that have at least one top tag until SAMPLE_SIZE reached.\ncollected = 0\nfor chunk in pd.read_csv(\n    TRAIN_PATH, usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"], chunksize=chunksize\n):\n    for _, row in chunk.iterrows():\n        tags = str(row[\"Tags\"]) if pd.notna(row[\"Tags\"]) else \"\"\n        tag_list = [t for t in tags.split() if t in top_tag_set]\n        if tag_list:\n            # include this row\n            text = (\n                (str(row[\"Title\"]) if pd.notna(row[\"Title\"]) else \"\")\n                + \" \"\n                + (str(row[\"Body\"]) if pd.notna(row[\"Body\"]) else \"\")\n            )\n            sample_texts.append(text)\n            sample_tag_lists.append(tag_list)\n            collected += 1\n            if collected >= SAMPLE_SIZE:\n                break\n    if collected >= SAMPLE_SIZE:\n        break\n\n# If not enough collected (unlikely), fill with random rows from train\nif collected < SAMPLE_SIZE:\n    print(\n        f\"Collected {collected} rows with top tags; need {SAMPLE_SIZE}. Filling with additional random rows...\"\n    )\n    # We'll do another pass and add rows without top tags randomly\n    for chunk in pd.read_csv(\n        TRAIN_PATH, usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"], chunksize=chunksize\n    ):\n        for _, row in chunk.iterrows():\n            if collected >= SAMPLE_SIZE:\n                break\n            tags = str(row[\"Tags\"]) if pd.notna(row[\"Tags\"]) else \"\"\n            tag_list = [t for t in tags.split() if t in top_tag_set]\n            if tag_list:\n                continue\n            # add with small probability to avoid bias\n            if random.random() < 0.02:\n                text = (\n                    (str(row[\"Title\"]) if pd.notna(row[\"Title\"]) else \"\")\n                    + \" \"\n                    + (str(row[\"Body\"]) if pd.notna(row[\"Body\"]) else \"\")\n                )\n                sample_texts.append(text)\n                sample_tag_lists.append([t for t in tags.split() if t in top_tag_set])\n                collected += 1\n        if collected >= SAMPLE_SIZE:\n            break\n\nprint(f\"Final sampled training size: {len(sample_texts)}\")\n\n# Free memory\ndel tag_counter\ngc.collect()\n\n# Step 3: vectorize texts with TF-IDF\nprint(\"Fitting TF-IDF vectorizer on sampled texts...\")\ntfidf = TfidfVectorizer(\n    max_features=TFIDF_MAX_FEATURES, ngram_range=NGRAM_RANGE, stop_words=\"english\"\n)\nX = tfidf.fit_transform(sample_texts)\nprint(f\"TF-IDF matrix shape: {X.shape}\")\n\n# Step 4: binarize tags\nmlb = MultiLabelBinarizer(classes=top_tags)\nY = mlb.fit_transform(sample_tag_lists)\nprint(f\"MultiLabel binarized shape: {Y.shape}\")\n\n# Step 5: 5-fold CV using OneVsRestClassifier with linear SGD (logistic loss)\nprint(\"Starting 5-fold cross-validation...\")\nkf = KFold(n_splits=5, shuffle=True, random_state=RANDOM_STATE)\nfold_scores = []\nfold = 0\n\n# Using OneVsRestClassifier with SGDClassifier (log loss)\nbase_clf = SGDClassifier(\n    loss=\"log\", penalty=\"l2\", max_iter=1000, tol=1e-3, random_state=RANDOM_STATE\n)\nclf_template = OneVsRestClassifier(base_clf, n_jobs=-1)\n\nfor train_idx, val_idx in kf.split(X):\n    fold += 1\n    print(\n        f\" Fold {fold} - training on {len(train_idx)} samples, validating on {len(val_idx)} samples...\"\n    )\n    X_train = X[train_idx]\n    Y_train = Y[train_idx]\n    X_val = X[val_idx]\n    Y_val = Y[val_idx]\n    clf = clf_template\n    clf.fit(X_train, Y_train)\n    # decision_function output shape (n_samples, n_classes)\n    try:\n        dec = clf.decision_function(X_val)\n    except Exception:\n        # fallback to predict_proba if available\n        dec = clf.predict_proba(X_val)\n    # For each sample, pick top TOP_PRED_PER_ROW classes by score\n    top_preds = np.argsort(-dec, axis=1)[:, :TOP_PRED_PER_ROW]\n    Y_pred = np.zeros_like(Y_val)\n    for i, idxs in enumerate(top_preds):\n        Y_pred[i, idxs] = 1\n    score = f1_score(Y_val, Y_pred, average=\"samples\")\n    print(f\"  Fold {fold} sample-wise F1: {score:.5f}\")\n    fold_scores.append(score)\n    # cleanup\n    del X_train, Y_train, X_val, Y_val, dec, Y_pred\n    gc.collect()\n\nmean_score = np.mean(fold_scores)\nprint(f\"\\nMean sample-wise F1 across {kf.n_splits} folds: {mean_score:.6f}\")\n\n# Step 6: retrain on all sampled data\nprint(\"Retraining classifier on all sampled data...\")\nclf_final = clf_template\nclf_final.fit(X, Y)\ndel X, Y, sample_texts, sample_tag_lists\ngc.collect()\n\n# Step 7: Predict on test set in chunks and write submission\nprint(\"Predicting on test set in chunks and writing submission...\")\n\n# Prepare output file\nout_rows = []\ntest_chunksize = 50000  # process in chunks to limit memory\nreader = pd.read_csv(TEST_PATH, chunksize=test_chunksize)\nrow_count = 0\n\n# We'll write directly to CSV to avoid holding everything in memory\nwith open(SUBMISSION_PATH, \"w\", encoding=\"utf-8\") as fout:\n    fout.write(\"Id,Tags\\n\")\n    for chunk in reader:\n        ids = chunk[\"Id\"].astype(str).values\n        texts = (chunk[\"Title\"].fillna(\"\") + \" \" + chunk[\"Body\"].fillna(\"\")).values\n        X_test = tfidf.transform(texts)\n        try:\n            dec = clf_final.decision_function(X_test)\n        except Exception:\n            dec = clf_final.predict_proba(X_test)\n        # For each row take top TOP_PRED_PER_ROW tags\n        top_preds = np.argsort(-dec, axis=1)[:, :TOP_PRED_PER_ROW]\n        for i, idv in enumerate(ids):\n            pred_idxs = top_preds[i]\n            pred_tags = [mlb.classes_[j] for j in pred_idxs]\n            # join with space and quote to match sample format\n            tags_str = \" \".join(pred_tags)\n            fout.write(f'{idv},\"{tags_str}\"\\n')\n        row_count += len(ids)\n        print(f\"  Processed {row_count} test rows...\", end=\"\\r\")\n        del X_test, dec\n        gc.collect()\n\nprint(f\"\\nSubmission written to {SUBMISSION_PATH}\")\nprint(f\"Cross-validation mean sample-wise F1: {mean_score:.6f}\")\n", "import os\nimport sys\nimport gc\nimport pandas as pd\nimport numpy as np\nfrom collections import Counter\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.model_selection import KFold\nfrom sklearn.linear_model import SGDClassifier\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.metrics import f1_score\n\n# SETTINGS\nINPUT_DIR = \"./input\"\nTRAIN_FILE = os.path.join(INPUT_DIR, \"train.csv\")\nTEST_FILE = os.path.join(INPUT_DIR, \"test.csv\")\nSAMPLE_N = 100000  # number of training rows to read for faster iteration\nTOP_K_TAGS = 300  # number of most frequent tags to model\nTFIDF_MAX_FEATURES = 30000\nNGRAM_RANGE = (1, 2)\nN_FOLDS = 5\nRANDOM_STATE = 42\nTOP_K_PRED = 3  # number of tags to predict for submission\n\n# Ensure submission dir exists\nos.makedirs(\"./submission\", exist_ok=True)\n\nprint(\"Loading a sample of the training data (nrows={})...\".format(SAMPLE_N))\ntrain = pd.read_csv(TRAIN_FILE, nrows=SAMPLE_N, usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"])\nprint(\"Loaded train sample shape:\", train.shape)\n\n# Basic preprocessing\ntrain[\"Title\"] = train[\"Title\"].fillna(\"\")\ntrain[\"Body\"] = train[\"Body\"].fillna(\"\")\ntrain[\"text\"] = (train[\"Title\"].astype(str) + \" \" + train[\"Body\"].astype(str)).astype(\n    str\n)\n# Tags are space-separated per description\ntrain[\"tags_list\"] = train[\"Tags\"].fillna(\"\").astype(str).apply(lambda s: s.split())\n\n# Determine top K tags from the sample\ntag_counter = Counter()\nfor tags in train[\"tags_list\"]:\n    tag_counter.update(tags)\nmost_common = [t for t, _ in tag_counter.most_common(TOP_K_TAGS)]\nprint(\"Top {} tags (sample): {}\".format(TOP_K_TAGS, most_common[:20]))\n\n# Filter labels to these top tags - create multilabel binarizer\nmlb = MultiLabelBinarizer(classes=most_common)\ny = mlb.fit_transform(train[\"tags_list\"])\nprint(\"Label matrix shape:\", y.shape)\n\n# Text vectorization\nprint(\"Fitting TF-IDF vectorizer (max_features={})...\".format(TFIDF_MAX_FEATURES))\ntfidf = TfidfVectorizer(\n    max_features=TFIDF_MAX_FEATURES,\n    ngram_range=NGRAM_RANGE,\n    stop_words=\"english\",\n    sublinear_tf=True,\n)\nX = tfidf.fit_transform(train[\"text\"])\nprint(\"Text features shape:\", X.shape)\n\n# Free some memory\ndel train\ngc.collect()\n\n# 5-fold cross-validation evaluation (sample-wise F1)\nkf = KFold(n_splits=N_FOLDS, shuffle=True, random_state=RANDOM_STATE)\nfold_scores = []\nfold_idx = 0\nprint(\"Starting {}-fold cross-validation...\".format(N_FOLDS))\nfor train_idx, val_idx in kf.split(X):\n    fold_idx += 1\n    print(\" Fold\", fold_idx)\n    X_train, X_val = X[train_idx], X[val_idx]\n    y_train, y_val = y[train_idx], y[val_idx]\n\n    # Train One-vs-Rest linear classifier using SGD (log loss -> probabilistic bounds via scores)\n    clf = OneVsRestClassifier(\n        SGDClassifier(\n            loss=\"log\", penalty=\"l2\", max_iter=1000, tol=1e-3, random_state=RANDOM_STATE\n        ),\n        n_jobs=-1,\n    )\n    clf.fit(X_train, y_train)\n\n    # Get decision scores (higher means more confident)\n    try:\n        scores = clf.decision_function(X_val)\n    except Exception:\n        # Fallback to predict_proba if available\n        scores = clf.predict_proba(X_val)\n\n    # For each sample select top k where k = number of true labels (at least 1)\n    true_counts = y_val.sum(axis=1).astype(int)\n    y_pred = np.zeros_like(y_val)\n    for i, cnt in enumerate(true_counts):\n        k = int(cnt) if cnt >= 1 else 1\n        row_scores = scores[i]\n        topk_idx = np.argpartition(-row_scores, k - 1)[:k]\n        y_pred[i, topk_idx] = 1\n\n    # Compute sample-wise F1\n    fold_f1 = f1_score(y_val, y_pred, average=\"samples\")\n    fold_scores.append(fold_f1)\n    print(\"  Fold {} sample-wise F1: {:.6f}\".format(fold_idx, fold_f1))\n\ncv_mean_f1 = float(np.mean(fold_scores))\nprint(\"Cross-validation mean sample-wise F1: {:.6f}\".format(cv_mean_f1))\n\n# Retrain on entire sampled data\nprint(\"Retraining classifier on full sampled training data...\")\nclf_full = OneVsRestClassifier(\n    SGDClassifier(\n        loss=\"log\", penalty=\"l2\", max_iter=1000, tol=1e-3, random_state=RANDOM_STATE\n    ),\n    n_jobs=-1,\n)\nclf_full.fit(X, y)\ndel X, y\ngc.collect()\n\n# Load test data (all rows) and predict in one go (should fit; if memory is an issue, chunking can be added)\nprint(\"Loading test data and preparing submission predictions...\")\ntest = pd.read_csv(TEST_FILE, usecols=[\"Id\", \"Title\", \"Body\"])\ntest[\"Title\"] = test[\"Title\"].fillna(\"\")\ntest[\"Body\"] = test[\"Body\"].fillna(\"\")\ntest[\"text\"] = (test[\"Title\"].astype(str) + \" \" + test[\"Body\"].astype(str)).astype(str)\ntest_ids = test[\"Id\"].values\nX_test = tfidf.transform(test[\"text\"])\n\n# Get decision scores and pick top K predictions per sample\ntry:\n    test_scores = clf_full.decision_function(X_test)\nexcept Exception:\n    test_scores = clf_full.predict_proba(X_test)\n\nn_test = X_test.shape[0]\npred_tags_list = []\nprint(\"Selecting top-{} tags for each test example...\".format(TOP_K_PRED))\nbatch_size = 50000\nfor start in range(0, n_test, batch_size):\n    end = min(n_test, start + batch_size)\n    block_scores = test_scores[start:end]\n    # For each row take top-K indices\n    topk_idx_block = np.argpartition(-block_scores, TOP_K_PRED - 1, axis=1)[\n        :, :TOP_K_PRED\n    ]\n    # For nicer ordering, sort the selected indices by score descending\n    sorted_idx_block = np.array(\n        [row[np.argsort(-block_scores[i, row])] for i, row in enumerate(topk_idx_block)]\n    )\n    for row in sorted_idx_block:\n        tags = [mlb.classes_[j] for j in row]\n        pred_tags_list.append(\" \".join(tags))\n\n# Build submission DataFrame\nsubmission = pd.DataFrame({\"Id\": test_ids, \"Tags\": pred_tags_list})\nsubmission_path = \"./submission/submission.csv\"\nsubmission.to_csv(submission_path, index=False)\nprint(\"Wrote submission to:\", submission_path)\nprint(\"Done. CV mean sample-wise F1:\", cv_mean_f1)\n", "#!/usr/bin/env python3\nimport os\nimport re\nimport sys\nimport math\nimport time\nimport random\nimport warnings\nfrom collections import Counter, defaultdict\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.linear_model import SGDClassifier\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.model_selection import KFold, cross_val_predict\nfrom sklearn.metrics import f1_score\n\nwarnings.filterwarnings(\"ignore\")\n\n# Config\nINPUT_DIR = \"./input\"\nTRAIN_FILE = os.path.join(INPUT_DIR, \"train.csv\")\nTEST_FILE = os.path.join(INPUT_DIR, \"test.csv\")\nSUBMISSION_DIR = \"./submission\"\nSUBMISSION_FILE = os.path.join(SUBMISSION_DIR, \"submission.csv\")\n\nRANDOM_STATE = 42\nSAMPLE_TARGET = 100_000  # desired number of training rows after keeping only top tags\nTOP_K_TAGS = 300  # number of most frequent tags to model\nTFIDF_MAX_FEATURES = 50000\nNGRAM_RANGE = (1, 2)\nCV_FOLDS = 5\nPRED_TOP_K = 3\nCHUNKSIZE = 100_000  # for reading train in streaming\nTEST_CHUNK = 50_000  # chunk size for transforming test set\n\nos.makedirs(SUBMISSION_DIR, exist_ok=True)\nrandom.seed(RANDOM_STATE)\nnp.random.seed(RANDOM_STATE)\n\n\ndef parse_tags(tagstr):\n    # handle formats like \"<tag1><tag2>\" or \"tag1 tag2\"\n    if pd.isna(tagstr):\n        return []\n    tagstr = str(tagstr).strip()\n    if not tagstr:\n        return []\n    if \"<\" in tagstr and \">\" in tagstr:\n        return re.findall(r\"<([^>]+)>\", tagstr)\n    # else assume space separated\n    return tagstr.split()\n\n\ndef stream_sample_top_tagged_rows(\n    train_file, sample_target, top_k_tags, chunksize=100000\n):\n    \"\"\"\n    Stream the train file in chunks, accumulate examples that include any of the\n    top_k_tags (dynamically determined after initial lightweight pass).\n    Strategy:\n    1) Make a fast first pass to count tags (sampling chunks to save time).\n    2) Determine top_k_tags.\n    3) Second pass: collect rows that contain at least one top tag until sample_target reached.\n    \"\"\"\n    print(\"Counting tag frequencies (fast pass)...\", file=sys.stderr)\n    tag_counter = Counter()\n    # fast pass: sample only first N chunks to estimate tag frequencies\n    read_rows = 0\n    max_chunks_for_count = (\n        20  # roughly sample up to ~2M rows if chunksize=100k (adjustable)\n    )\n    for i, chunk in enumerate(\n        pd.read_csv(\n            train_file, usecols=[\"Tags\"], chunksize=chunksize, iterator=True, engine=\"c\"\n        )\n    ):\n        # parse tags and count\n        for t in chunk[\"Tags\"].dropna().astype(str):\n            # quick parse: find <tag> pattern or split\n            if \"<\" in t and \">\" in t:\n                tags = re.findall(r\"<([^>]+)>\", t)\n            else:\n                tags = t.split()\n            tag_counter.update(tags)\n        read_rows += len(chunk)\n        if i + 1 >= max_chunks_for_count:\n            break\n    print(\n        f\"Fast pass counted tags from ~{read_rows} rows, unique tags found: {len(tag_counter)}\",\n        file=sys.stderr,\n    )\n\n    top_tags = [t for t, _ in tag_counter.most_common(top_k_tags)]\n    print(f\"Top {len(top_tags)} tags selected.\", file=sys.stderr)\n\n    print(\"Second pass: collecting examples containing top tags...\", file=sys.stderr)\n    collected = []\n    collected_ids = set()\n    # second pass: stream and collect rows that have at least one top tag\n    for chunk in pd.read_csv(\n        train_file,\n        usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n        chunksize=chunksize,\n        iterator=True,\n        engine=\"c\",\n    ):\n        # parse tags\n        mask_rows = []\n        tags_list = []\n        for idx, row in chunk.iterrows():\n            t = row[\"Tags\"]\n            parsed = parse_tags(t)\n            # keep if any tag in top_tags\n            keep = any(tag in top_tags for tag in parsed)\n            if keep:\n                tags_list.append(parsed)\n                mask_rows.append(idx)\n        if mask_rows:\n            sel = chunk.loc[mask_rows].copy()\n            sel[\"ParsedTags\"] = tags_list\n            # append rows but ensure we don't exceed target\n            for _, r in sel.iterrows():\n                rid = int(r[\"Id\"])\n                if rid in collected_ids:\n                    continue\n                collected.append((rid, r[\"Title\"], r[\"Body\"], r[\"ParsedTags\"]))\n                collected_ids.add(rid)\n                if len(collected) >= sample_target:\n                    break\n        if len(collected) >= sample_target:\n            break\n    print(\n        f\"Collected {len(collected)} rows with top tags (target was {sample_target}).\",\n        file=sys.stderr,\n    )\n    # If not enough, fall back to collecting any rows (without requiring top tag) until target\n    if len(collected) < sample_target:\n        print(\n            \"Not enough rows with top tags; collecting additional rows regardless of tags...\",\n            file=sys.stderr,\n        )\n        for chunk in pd.read_csv(\n            train_file,\n            usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"c\",\n        ):\n            for idx, row in chunk.iterrows():\n                rid = int(row[\"Id\"])\n                if rid in collected_ids:\n                    continue\n                parsed = parse_tags(row[\"Tags\"])\n                collected.append((rid, row[\"Title\"], row[\"Body\"], parsed))\n                collected_ids.add(rid)\n                if len(collected) >= sample_target:\n                    break\n            if len(collected) >= sample_target:\n                break\n    # Build DataFrame\n    df = pd.DataFrame(collected, columns=[\"Id\", \"Title\", \"Body\", \"ParsedTags\"])\n    return df, top_tags\n\n\ndef build_dataset(df, top_tags):\n    # Combine Title+Body\n    df[\"Title\"] = df[\"Title\"].fillna(\"\").astype(str)\n    df[\"Body\"] = df[\"Body\"].fillna(\"\").astype(str)\n    df[\"text\"] = (\n        (df[\"Title\"] + \" \" + df[\"Body\"]).str.replace(\"\\n\", \" \").str.replace(\"\\r\", \" \")\n    )\n    # Filter tags to only top_tags in each example\n    df[\"TagsFiltered\"] = df[\"ParsedTags\"].apply(\n        lambda tags: [t for t in tags if t in top_tags]\n    )\n    # remove rows with zero tags after filtering\n    before = len(df)\n    df = df[df[\"TagsFiltered\"].map(len) > 0].reset_index(drop=True)\n    after = len(df)\n    print(\n        f\"Filtered dataset to {after} rows (from {before}) that contain at least one top tag.\",\n        file=sys.stderr,\n    )\n    y_lists = df[\"TagsFiltered\"].tolist()\n    return df, y_lists\n\n\ndef topk_preds_from_scores(scores, k):\n    # scores: (n_samples, n_classes)\n    # returns binary matrix of shape (n_samples, n_classes) with top-k set for each row\n    n_samples, n_classes = scores.shape\n    preds = np.zeros_like(scores, dtype=int)\n    # argsort descending\n    topk_idx = np.argpartition(-scores, kth=range(min(k, n_classes)), axis=1)[:, :k]\n    # For each row, set those indices to 1\n    rows = np.arange(n_samples)[:, None]\n    preds[rows, topk_idx] = 1\n    return preds\n\n\ndef main():\n    start_time = time.time()\n    print(\"Starting training script...\", file=sys.stderr)\n    # 1) Sample and get top tags\n    sampled_df, estimated_top_tags = stream_sample_top_tagged_rows(\n        TRAIN_FILE, SAMPLE_TARGET, TOP_K_TAGS, chunksize=CHUNKSIZE\n    )\n    # Recompute true top tags on sampled_df to ensure consistency\n    all_tags = []\n    for tags in sampled_df[\"ParsedTags\"]:\n        all_tags.extend(tags)\n    tag_counts = Counter(all_tags)\n    top_tags = [t for t, _ in tag_counts.most_common(TOP_K_TAGS)]\n    print(\n        f\"Top tags recalculated from sampled data: {len(top_tags)} tags.\",\n        file=sys.stderr,\n    )\n\n    # 2) Build dataset (text and filtered tags)\n    df, y_lists = build_dataset(sampled_df, top_tags)\n    if len(df) < 1000:\n        print(\"Too few examples after filtering. Exiting.\", file=sys.stderr)\n        return\n\n    texts = df[\"text\"].tolist()\n    ids = df[\"Id\"].tolist()\n\n    # 3) Vectorize\n    print(\"Fitting TF-IDF vectorizer...\", file=sys.stderr)\n    vectorizer = TfidfVectorizer(\n        max_features=TFIDF_MAX_FEATURES, ngram_range=NGRAM_RANGE, stop_words=\"english\"\n    )\n    X = vectorizer.fit_transform(texts)\n    print(f\"TF-IDF shaped: {X.shape}\", file=sys.stderr)\n\n    # 4) Binarize labels\n    mlb = MultiLabelBinarizer(classes=top_tags)\n    Y = mlb.fit_transform(y_lists)\n    print(f\"Label matrix shaped: {Y.shape}\", file=sys.stderr)\n\n    # 5) Build classifier\n    base_clf = SGDClassifier(\n        loss=\"log\", max_iter=1000, tol=1e-3, random_state=RANDOM_STATE\n    )\n    clf = OneVsRestClassifier(base_clf, n_jobs=-1)\n\n    # 6) Cross-validated predictions (decision_function) and sample-wise F1\n    print(\n        f\"Performing {CV_FOLDS}-fold cross-validation (this may take a while)...\",\n        file=sys.stderr,\n    )\n    kf = KFold(n_splits=CV_FOLDS, shuffle=True, random_state=RANDOM_STATE)\n    # cross_val_predict with method='decision_function' to get continuous scores\n    scores = cross_val_predict(clf, X, Y, cv=kf, method=\"decision_function\", n_jobs=-1)\n    # For each sample pick top-PRED_TOP_K labels\n    y_pred_cv = topk_preds_from_scores(scores, PRED_TOP_K)\n    f1 = f1_score(Y, y_pred_cv, average=\"samples\")\n    print(f\"5-fold cross-validated sample-wise F1: {f1:.6f}\")\n\n    # 7) Retrain on full sampled data\n    print(\"Retraining classifier on full sampled data...\", file=sys.stderr)\n    clf.fit(X, Y)\n\n    # 8) Predict on test set in chunks, pick top-K labels and write submission\n    print(\"Predicting on test set and writing submission...\", file=sys.stderr)\n    # We'll process test in chunks and append to list, then write CSV\n    sub_rows = []\n    # reading test: Id, Title, Body\n    test_reader = pd.read_csv(\n        TEST_FILE,\n        usecols=[\"Id\", \"Title\", \"Body\"],\n        chunksize=TEST_CHUNK,\n        iterator=True,\n        engine=\"c\",\n    )\n    total_test = 0\n    for chunk in test_reader:\n        chunk_ids = chunk[\"Id\"].tolist()\n        titles = chunk[\"Title\"].fillna(\"\").astype(str).tolist()\n        bodies = chunk[\"Body\"].fillna(\"\").astype(str).tolist()\n        texts_chunk = [\n            (t + \" \" + b).replace(\"\\n\", \" \").replace(\"\\r\", \" \")\n            for t, b in zip(titles, bodies)\n        ]\n        Xtest = vectorizer.transform(texts_chunk)\n        # get decision scores\n        try:\n            scores_test = clf.decision_function(Xtest)\n        except Exception:\n            # some sklearn versions require predict_proba; fallback to predict\n            preds = clf.predict(Xtest)\n            # convert binary matrix to scores-like\n            scores_test = preds.astype(float)\n        # ensure shape\n        if scores_test.ndim == 1:\n            scores_test = scores_test.reshape(-1, 1)\n        # pick top-k\n        preds_bin = topk_preds_from_scores(scores_test, PRED_TOP_K)\n        # convert to tag strings\n        for rid, row_pred in zip(chunk_ids, preds_bin):\n            lbl_idx = np.where(row_pred == 1)[0]\n            if len(lbl_idx) == 0:\n                # fallback: pick top scoring column\n                idx = int(np.argmax(scores_test[0])) if scores_test.shape[1] > 0 else []\n                lbl_idx = [idx]\n            tags = [mlb.classes_[i] for i in lbl_idx]\n            # join with space as required\n            tags_str = \" \".join(tags)\n            sub_rows.append((int(rid), tags_str))\n        total_test += len(chunk_ids)\n        print(f\"Processed {total_test} test rows...\", file=sys.stderr)\n\n    # Write submission CSV\n    print(f\"Writing submission to {SUBMISSION_FILE} ...\", file=sys.stderr)\n    with open(SUBMISSION_FILE, \"w\", encoding=\"utf-8\") as f:\n        f.write(\"Id,Tags\\n\")\n        for rid, tags in sub_rows:\n            # ensure tags are quoted if contain comma (they shouldn't)\n            # write as Id,\"tag1 tag2\"\n            f.write(f'{rid},\"{tags}\"\\n')\n\n    elapsed = time.time() - start_time\n    print(f\"Done. Time elapsed: {elapsed:.1f} sec\", file=sys.stderr)\n    # Print the metric to stdout as required\n    print(f\"{f1:.6f}\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "import os\nimport re\nimport sys\nimport gc\nimport math\nimport random\nfrom collections import Counter\nimport numpy as np\nimport pandas as pd\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.model_selection import KFold\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.naive_bayes import MultinomialNB\nfrom sklearn.metrics import f1_score\nfrom tqdm import tqdm\n\n# Configuration\nINPUT_DIR = \"./input\"\nTRAIN_FILE = os.path.join(INPUT_DIR, \"train.csv\")\nTEST_FILE = os.path.join(INPUT_DIR, \"test.csv\")\nSAMPLE_SUB_FILE = os.path.join(INPUT_DIR, \"sample_submission.csv\")\nSUBMISSION_DIR = \"./submission\"\nSUBMISSION_FILE = os.path.join(SUBMISSION_DIR, \"submission.csv\")\n\nTOP_K_TAGS = 300  # number of most frequent tags to model\nMAX_SAMPLES = 120000  # maximum number of training examples to use\nRANDOM_STATE = 42\nN_FOLDS = 5\nTOP_PRED = 3  # number of tags to output per question\n\nos.makedirs(SUBMISSION_DIR, exist_ok=True)\nrandom.seed(RANDOM_STATE)\nnp.random.seed(RANDOM_STATE)\n\n\ndef parse_tags(tagstr):\n    if pd.isna(tagstr):\n        return []\n    s = tagstr.strip()\n    if not s:\n        return []\n    # Two common formats: \"<tag1><tag2>\" or \"tag1 tag2\"\n    if s.startswith(\"<\") and \">\" in s:\n        # split by '><' after stripping leading/trailing angle brackets\n        s2 = s.strip()\n        s2 = s2.strip(\"<>\")\n        return [t for t in s2.split(\"><\") if t]\n    else:\n        # assume whitespace-separated\n        return [t for t in s.split() if t]\n\n\nprint(\"Step 1: Scan train file to count tag frequencies...\")\ntag_counter = Counter()\n# read in chunks to avoid loading whole file\nchunksize = 100000\nusecols = [\"Tags\"]\nfor chunk in pd.read_csv(TRAIN_FILE, usecols=usecols, chunksize=chunksize):\n    for tags in chunk[\"Tags\"].fillna(\"\").astype(str):\n        for t in parse_tags(tags):\n            tag_counter[t] += 1\nprint(f\"Found {len(tag_counter)} unique tags in training data.\")\n\ntop_tags = [t for t, _ in tag_counter.most_common(TOP_K_TAGS)]\ntop_tag_set = set(top_tags)\nprint(f\"Selected top {len(top_tags)} tags (most common).\")\n\nprint(\"Step 2: Collect up to MAX_SAMPLES examples that include at least one top tag...\")\ncollected = []\ncollected_tags = []\ncollected_ids = []\ncollected_texts = []\n\n# We'll read again and keep rows that have at least one top tag\ncols = [\"Id\", \"Title\", \"Body\", \"Tags\"]\nfor chunk in pd.read_csv(TRAIN_FILE, usecols=cols, chunksize=chunksize):\n    for idx, row in chunk.iterrows():\n        tags = parse_tags(row[\"Tags\"] if not pd.isna(row[\"Tags\"]) else \"\")\n        tags_in_top = [t for t in tags if t in top_tag_set]\n        if tags_in_top:\n            # combine title and body\n            title = row[\"Title\"] if not pd.isna(row[\"Title\"]) else \"\"\n            body = row[\"Body\"] if not pd.isna(row[\"Body\"]) else \"\"\n            text = (str(title) + \" \" + str(body)).strip()\n            collected_ids.append(row[\"Id\"])\n            collected_texts.append(text)\n            collected_tags.append(tags_in_top)\n            if len(collected_ids) >= MAX_SAMPLES:\n                break\n    if len(collected_ids) >= MAX_SAMPLES:\n        break\n\nn_collected = len(collected_ids)\nprint(f\"Collected {n_collected} training examples with top tags (limit {MAX_SAMPLES}).\")\nif n_collected == 0:\n    raise RuntimeError(\"No training examples collected; check parsing.\")\n\n# Shuffle collected examples\nperm = np.arange(n_collected)\nnp.random.shuffle(perm)\ncollected_ids = [collected_ids[i] for i in perm]\ncollected_texts = [collected_texts[i] for i in perm]\ncollected_tags = [collected_tags[i] for i in perm]\n\n# Prepare multilabel binarizer for only top tags\nmlb = MultiLabelBinarizer(classes=top_tags)\nY = mlb.fit_transform(collected_tags)\nprint(\"Binarized tags shape:\", Y.shape)\n\nprint(\n    \"Step 3: Vectorize text with TfidfVectorizer (unigrams+bigrams, capped features)...\"\n)\ntfidf = TfidfVectorizer(\n    max_features=100000, ngram_range=(1, 2), stop_words=\"english\", min_df=3\n)\nX = tfidf.fit_transform(collected_texts)\nprint(\"TF-IDF matrix shape:\", X.shape)\n\n# free memory\ndel collected_texts\ngc.collect()\n\nprint(\n    f\"Step 4: {N_FOLDS}-fold cross-validation with One-vs-Rest MultinomialNB and sample-wise F1\"\n)\nkf = KFold(n_splits=N_FOLDS, shuffle=True, random_state=RANDOM_STATE)\nf1s = []\nfold = 0\nfor train_idx, val_idx in kf.split(X):\n    fold += 1\n    print(f\" Training fold {fold}...\")\n    X_train = X[train_idx]\n    X_val = X[val_idx]\n    Y_train = Y[train_idx]\n    Y_val = Y[val_idx]\n\n    clf = OneVsRestClassifier(MultinomialNB(alpha=0.1), n_jobs=-1)\n    clf.fit(X_train, Y_train)\n    # predict probabilities and take top-PRED per sample\n    try:\n        probs = clf.predict_proba(X_val)\n    except Exception:\n        # fallback: use decision_function then sigmoid\n        dec = clf.decision_function(X_val)\n        probs = 1.0 / (1.0 + np.exp(-dec))\n\n    # For each sample, pick top TOP_PRED tags\n    top_preds = np.zeros_like(probs, dtype=int)\n    topk_idx = np.argsort(-probs, axis=1)[:, :TOP_PRED]\n    rows = np.arange(probs.shape[0])[:, None]\n    top_preds[rows, topk_idx] = 1\n\n    f1 = f1_score(Y_val, top_preds, average=\"samples\")\n    print(f\"  Fold {fold} sample-wise F1 = {f1:.6f}\")\n    f1s.append(f1)\n\nmean_f1 = float(np.mean(f1s))\nprint(f\"\\nMean sample-wise F1 across {N_FOLDS} folds = {mean_f1:.6f}\")\n\nprint(\n    \"Step 5: Retrain on all collected training data and predict on test set in batches...\"\n)\nclf_full = OneVsRestClassifier(MultinomialNB(alpha=0.1), n_jobs=-1)\nclf_full.fit(X, Y)\ndel X, Y\ngc.collect()\n\n# Prepare to read test and predict in chunks\ntest_cols = [\"Id\", \"Title\", \"Body\"]\ntest_reader = pd.read_csv(TEST_FILE, usecols=test_cols, chunksize=5000)\n\nout_ids = []\nout_tags = []\n\nfor chunk in tqdm(test_reader, desc=\"Predicting test chunks\"):\n    ids = chunk[\"Id\"].tolist()\n    texts = (\n        (\n            chunk[\"Title\"].fillna(\"\").astype(str)\n            + \" \"\n            + chunk[\"Body\"].fillna(\"\").astype(str)\n        )\n    ).tolist()\n    X_test = tfidf.transform(texts)\n    try:\n        probs = clf_full.predict_proba(X_test)\n    except Exception:\n        dec = clf_full.decision_function(X_test)\n        probs = 1.0 / (1.0 + np.exp(-dec))\n    # choose top TOP_PRED tags per row\n    topk_idx = np.argsort(-probs, axis=1)[:, :TOP_PRED]\n    for i, idxs in enumerate(topk_idx):\n        tags = [mlb.classes_[j] for j in idxs]\n        out_ids.append(ids[i])\n        out_tags.append(\" \".join(tags))\n\n# Write submission file\nsub_df = pd.DataFrame({\"Id\": out_ids, \"Tags\": out_tags})\nsub_df.to_csv(SUBMISSION_FILE, index=False)\nprint(f\"Submission saved to: {SUBMISSION_FILE}\")\n\n# Print final metric\nprint(f\"\\nFINAL METRIC (mean sample-wise F1 from CV): {mean_f1:.6f}\")\n", "#!/usr/bin/env python3\nimport os\nimport re\nimport sys\nimport time\nfrom collections import Counter\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.linear_model import SGDClassifier\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.model_selection import KFold, cross_val_predict\nfrom sklearn.metrics import f1_score\n\n# Config\nINPUT_DIR = \"./input\"\nTRAIN_FILE = os.path.join(INPUT_DIR, \"train.csv\")\nTEST_FILE = os.path.join(INPUT_DIR, \"test.csv\")\nSUBMISSION_DIR = \"./submission\"\nSUBMISSION_FILE = os.path.join(SUBMISSION_DIR, \"submission.csv\")\n\nos.makedirs(SUBMISSION_DIR, exist_ok=True)\n\nRANDOM_STATE = 42\nSAMPLE_TARGET = 100_000  # desired number of training rows after keeping only top tags\nTOP_K_TAGS = 300  # number of most frequent tags to model\nTFIDF_MAX_FEATURES = 20000\nNGRAM_RANGE = (1, 2)\nCV_FOLDS = 3\nPRED_TOP_K = 3\nCOUNT_CHUNK_ROWS = 20000  # rows per chunk when counting tags\nCOLLECT_CHUNK = 50000  # rows per chunk when collecting training examples\n\nnp.random.seed(RANDOM_STATE)\n\n\ndef parse_tags(tagstr):\n    if pd.isna(tagstr):\n        return []\n    s = str(tagstr).strip()\n    if not s:\n        return []\n    # pattern like <tag1><tag2>\n    if \"<\" in s and \">\" in s:\n        tags = re.findall(r\"<([^>]+)>\", s)\n        if tags:\n            return tags\n    # else assume space-separated\n    return s.split()\n\n\ndef get_top_tags_fast(\n    train_file, top_k=TOP_K_TAGS, sample_chunks=10, chunksize=COUNT_CHUNK_ROWS\n):\n    counter = Counter()\n    read_rows = 0\n    try:\n        reader = pd.read_csv(\n            train_file, usecols=[\"Tags\"], chunksize=chunksize, iterator=True, engine=\"c\"\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n    for i, chunk in enumerate(reader):\n        for t in chunk[\"Tags\"].dropna().astype(str):\n            if \"<\" in t and \">\" in t:\n                tags = re.findall(r\"<([^>]+)>\", t)\n            else:\n                tags = t.split()\n            counter.update(tags)\n        read_rows += len(chunk)\n        if i + 1 >= sample_chunks:\n            break\n    top_tags = [t for t, _ in counter.most_common(top_k)]\n    print(\n        f\"Fast-pass counted ~{read_rows} rows, unique tags found: {len(counter)}. Selected top {len(top_tags)} tags.\",\n        file=sys.stderr,\n    )\n    return top_tags\n\n\ndef collect_examples_with_top_tags(\n    train_file, top_tags, sample_target=SAMPLE_TARGET, chunksize=COLLECT_CHUNK\n):\n    collected = []\n    collected_ids = set()\n    try:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"c\",\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n    for chunk in reader:\n        # iterate rows and collect those having any top tag\n        for idx, row in chunk.iterrows():\n            rid = int(row[\"Id\"])\n            if rid in collected_ids:\n                continue\n            tags = parse_tags(row[\"Tags\"])\n            if any(t in top_tags for t in tags):\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n            if len(collected) >= sample_target:\n                break\n        if len(collected) >= sample_target:\n            break\n    # If not enough, do another pass and collect arbitrary rows to reach target\n    if len(collected) < sample_target:\n        print(\n            f\"Collected only {len(collected)} rows with top tags; filling up with additional rows...\",\n            file=sys.stderr,\n        )\n        try:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"c\",\n            )\n        except Exception:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"python\",\n            )\n        for chunk in reader2:\n            for idx, row in chunk.iterrows():\n                rid = int(row[\"Id\"])\n                if rid in collected_ids:\n                    continue\n                tags = parse_tags(row[\"Tags\"])\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n                if len(collected) >= sample_target:\n                    break\n            if len(collected) >= sample_target:\n                break\n    df = pd.DataFrame(collected, columns=[\"Id\", \"Title\", \"Body\", \"ParsedTags\"])\n    print(f\"Total collected training examples: {len(df)}\", file=sys.stderr)\n    return df\n\n\ndef build_dataset_from_collected(df, top_tags):\n    df[\"Title\"] = df[\"Title\"].fillna(\"\").astype(str)\n    df[\"Body\"] = df[\"Body\"].fillna(\"\").astype(str)\n    df[\"text\"] = (\n        (df[\"Title\"] + \" \" + df[\"Body\"]).str.replace(\"\\n\", \" \").str.replace(\"\\r\", \" \")\n    )\n    df[\"TagsFiltered\"] = df[\"ParsedTags\"].apply(\n        lambda tags: [t for t in tags if t in top_tags]\n    )\n    before = len(df)\n    df = df[df[\"TagsFiltered\"].map(len) > 0].reset_index(drop=True)\n    after = len(df)\n    print(\n        f\"Filtered dataset to {after} rows (from {before}) that contain at least one top tag.\",\n        file=sys.stderr,\n    )\n    y_lists = df[\"TagsFiltered\"].tolist()\n    return df, y_lists\n\n\ndef topk_from_scores(scores, k):\n    # scores shape (n_samples, n_classes)\n    n_samples, n_classes = scores.shape\n    k = min(k, n_classes)\n    # argsort and take top k indices\n    idx_sorted = np.argsort(scores, axis=1)\n    topk_idx = idx_sorted[:, -k:]\n    preds = np.zeros_like(scores, dtype=int)\n    rows = np.arange(n_samples)[:, None]\n    preds[rows, topk_idx] = 1\n    return preds\n\n\ndef main():\n    start_time = time.time()\n    print(\"Starting training and prediction...\", file=sys.stderr)\n\n    # 1) Fast pass to get top tags\n    top_tags = get_top_tags_fast(\n        TRAIN_FILE, top_k=TOP_K_TAGS, sample_chunks=10, chunksize=COUNT_CHUNK_ROWS\n    )\n\n    # 2) Collect examples that contain top tags\n    sampled_df = collect_examples_with_top_tags(\n        TRAIN_FILE, top_tags, sample_target=SAMPLE_TARGET, chunksize=COLLECT_CHUNK\n    )\n\n    # Recompute top tags based on sampled data to ensure consistency\n    all_tags = []\n    for tags in sampled_df[\"ParsedTags\"]:\n        all_tags.extend(tags)\n    tag_counts = Counter(all_tags)\n    top_tags = [t for t, _ in tag_counts.most_common(TOP_K_TAGS)]\n    print(\n        f\"Top tags recalculated from sampled data: {len(top_tags)} tags.\",\n        file=sys.stderr,\n    )\n\n    # 3) Build dataset\n    df, y_lists = build_dataset_from_collected(sampled_df, top_tags)\n    if len(df) < 100:\n        print(\"Too few examples after filtering. Exiting.\", file=sys.stderr)\n        return\n\n    texts = df[\"text\"].tolist()\n    ids = df[\"Id\"].tolist()\n\n    # 4) Vectorize\n    print(\"Fitting TF-IDF vectorizer...\", file=sys.stderr)\n    vectorizer = TfidfVectorizer(\n        max_features=TFIDF_MAX_FEATURES, ngram_range=NGRAM_RANGE, stop_words=\"english\"\n    )\n    X = vectorizer.fit_transform(texts)\n    print(f\"TF-IDF shaped: {X.shape}\", file=sys.stderr)\n\n    # 5) Binarize labels\n    mlb = MultiLabelBinarizer(classes=top_tags)\n    Y = mlb.fit_transform(y_lists)\n    print(f\"Label matrix shaped: {Y.shape}\", file=sys.stderr)\n\n    # 6) Build classifier\n    base_clf = SGDClassifier(\n        loss=\"log\", max_iter=1000, tol=1e-3, random_state=RANDOM_STATE\n    )\n    clf = OneVsRestClassifier(base_clf, n_jobs=1)  # avoid nested parallelism\n\n    # 7) Cross-validated predictions to compute sample-wise F1\n    print(f\"Performing {CV_FOLDS}-fold cross-validation...\", file=sys.stderr)\n    kf = KFold(n_splits=CV_FOLDS, shuffle=True, random_state=RANDOM_STATE)\n    try:\n        scores_cv = cross_val_predict(\n            clf, X, Y, cv=kf, method=\"decision_function\", n_jobs=1\n        )\n    except Exception as e:\n        # fallback: use predict_proba or predict\n        print(\n            \"cross_val_predict with decision_function failed, falling back to predict. Error: \"\n            + str(e),\n            file=sys.stderr,\n        )\n        preds_cv = cross_val_predict(clf, X, Y, cv=kf, method=\"predict\", n_jobs=1)\n        # convert to float scores for topk logic\n        scores_cv = preds_cv.astype(float)\n    if scores_cv.ndim == 1:\n        scores_cv = scores_cv.reshape(-1, 1)\n    y_pred_cv = topk_from_scores(scores_cv, PRED_TOP_K)\n    f1 = f1_score(Y, y_pred_cv, average=\"samples\")\n    print(f\"Cross-validated sample-wise F1: {f1:.6f}\", file=sys.stderr)\n\n    # 8) Retrain on full sampled data\n    print(\"Retraining classifier on full sampled data...\", file=sys.stderr)\n    clf.fit(X, Y)\n\n    # 9) Predict on test set in chunks and write submission\n    print(\"Predicting on test set and writing submission...\", file=sys.stderr)\n    sub_rows = []\n    total_test = 0\n    try:\n        test_reader = pd.read_csv(\n            TEST_FILE,\n            usecols=[\"Id\", \"Title\", \"Body\"],\n            chunksize=50000,\n            iterator=True,\n            engine=\"c\",\n        )\n    except Exception:\n        test_reader = pd.read_csv(\n            TEST_FILE,\n            usecols=[\"Id\", \"Title\", \"Body\"],\n            chunksize=50000,\n            iterator=True,\n            engine=\"python\",\n        )\n    for chunk in test_reader:\n        chunk_ids = chunk[\"Id\"].tolist()\n        titles = chunk[\"Title\"].fillna(\"\").astype(str).tolist()\n        bodies = chunk[\"Body\"].fillna(\"\").astype(str).tolist()\n        texts_chunk = [\n            (t + \" \" + b).replace(\"\\n\", \" \").replace(\"\\r\", \" \")\n            for t, b in zip(titles, bodies)\n        ]\n        Xtest = vectorizer.transform(texts_chunk)\n        # get decision scores\n        try:\n            scores_test = clf.decision_function(Xtest)\n        except Exception:\n            # fallback to predict\n            preds = clf.predict(Xtest)\n            scores_test = preds.astype(float)\n        if scores_test.ndim == 1:\n            scores_test = scores_test.reshape(-1, 1)\n        preds_bin = topk_from_scores(scores_test, PRED_TOP_K)\n        for rid, row_pred in zip(chunk_ids, preds_bin):\n            lbl_idx = np.where(row_pred == 1)[0]\n            if len(lbl_idx) == 0:\n                # fallback: take highest scoring class\n                idx = (\n                    int(np.argmax(scores_test[0])) if scores_test.shape[1] > 0 else None\n                )\n                if idx is None:\n                    tags = []\n                else:\n                    tags = [mlb.classes_[idx]]\n            else:\n                tags = [mlb.classes_[i] for i in lbl_idx]\n            tags_str = \" \".join(tags)\n            sub_rows.append((int(rid), tags_str))\n        total_test += len(chunk_ids)\n        print(f\"Processed {total_test} test rows...\", file=sys.stderr)\n\n    # Write submission CSV\n    print(f\"Writing submission to {SUBMISSION_FILE} ...\", file=sys.stderr)\n    with open(SUBMISSION_FILE, \"w\", encoding=\"utf-8\") as f:\n        f.write(\"Id,Tags\\n\")\n        for rid, tags in sub_rows:\n            # write as Id,\"tag1 tag2\"\n            f.write(f'{rid},\"{tags}\"\\n')\n\n    elapsed = time.time() - start_time\n    print(f\"Done. Time elapsed: {elapsed:.1f} sec\", file=sys.stderr)\n    # Print the metric to stdout as required\n    print(f\"{f1:.6f}\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "import os\nimport gc\nimport numpy as np\nimport pandas as pd\nfrom collections import Counter\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.linear_model import SGDClassifier\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.model_selection import KFold\nfrom sklearn.metrics import f1_score\n\n# Configuration / hyperparameters\nRANDOM_STATE = 42\nSAMPLE_ROWS = 100000  # reduced sample to keep runtime reasonable\nTOP_K_TAGS = 1000  # predict top-K most frequent tags\nTFIDF_MAX_FEATURES = 30000  # TF-IDF vocabulary size\nN_FOLDS = 3  # folds for cross-validation (balanced for speed)\nSGD_MAX_ITER = 5  # iterations for SGDClassifier (quick)\nCHUNK_SIZE_READ = 50000  # chunks when reading large CSVs\nCHUNK_SIZE_TEST = 50000  # rows per chunk when processing test set\n\nINPUT_DIR = \"./input\"\nTRAIN_FILE = os.path.join(INPUT_DIR, \"train.csv\")\nTEST_FILE = os.path.join(INPUT_DIR, \"test.csv\")\nSUBMISSION_DIR = \"./submission\"\nSUBMISSION_FILE = os.path.join(SUBMISSION_DIR, \"submission.csv\")\nos.makedirs(SUBMISSION_DIR, exist_ok=True)\n\n\ndef load_train_sample(train_file, nrows):\n    # read in chunks to handle very large file if necessary\n    df_list = []\n    read = 0\n    chunksize = CHUNK_SIZE_READ\n    for chunk in pd.read_csv(\n        train_file, usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"], chunksize=chunksize\n    ):\n        df_list.append(chunk)\n        read += len(chunk)\n        if read >= nrows:\n            break\n    if not df_list:\n        return pd.DataFrame(columns=[\"Id\", \"Title\", \"Body\", \"Tags\"])\n    df = pd.concat(df_list, ignore_index=True)\n    if len(df) > nrows:\n        df = df.iloc[:nrows].reset_index(drop=True)\n    return df\n\n\nprint(\"Loading training sample...\")\ntrain_df = load_train_sample(TRAIN_FILE, SAMPLE_ROWS)\nprint(f\"Train sample shape: {train_df.shape}\")\n\n# Basic preprocessing: fillna and combine text\ntrain_df[\"Title\"] = train_df[\"Title\"].fillna(\"\").astype(str)\ntrain_df[\"Body\"] = train_df[\"Body\"].fillna(\"\").astype(str)\ntrain_df[\"Text\"] = (train_df[\"Title\"] + \" \" + train_df[\"Body\"]).astype(str)\n\n# Parse tags into lists (ensure strings)\ntrain_df[\"Tags\"] = train_df[\"Tags\"].fillna(\"\").astype(str)\ntrain_df[\"TagList\"] = train_df[\"Tags\"].apply(lambda x: x.split())\n\n# Determine top-K tags from the sampled data\ntag_counter = Counter()\nfor tags in train_df[\"TagList\"]:\n    tag_counter.update(tags)\nmost_common = [t for t, _ in tag_counter.most_common(TOP_K_TAGS)]\nmost_common_set = set(most_common)\nprint(f\"Selected top-{TOP_K_TAGS} tags (unique found in sample): {len(most_common)}\")\n\n\n# Filter tags to top-K and drop rows without any of the top tags\ndef filter_topk(tags):\n    return [t for t in tags if t in most_common_set]\n\n\ntrain_df[\"FilteredTags\"] = train_df[\"TagList\"].apply(filter_topk)\nbefore_rows = len(train_df)\ntrain_df = train_df[train_df[\"FilteredTags\"].map(len) > 0].reset_index(drop=True)\nafter_rows = len(train_df)\nprint(\n    f\"Rows with at least one top-{TOP_K_TAGS} tag: {after_rows} (dropped {before_rows - after_rows})\"\n)\n\n# Prepare texts and label lists\ntrain_texts = train_df[\"Text\"].values\ntrain_labels = list(train_df[\"FilteredTags\"])\n\n# Fix: ensure MultiLabelBinarizer classes are exactly the top-K (stable ordering)\nmlb = MultiLabelBinarizer(classes=most_common)  # uses provided order\nmlb.fit([])  # initialize; fit requires an iterable but we set classes explicitly\n# transform labels (labels not in classes are ignored)\nY = mlb.transform(train_labels)\nprint(f\"Number of classes (after binarizer): {len(mlb.classes_)}\")\nprint(f\"Label matrix shape: {Y.shape}\")\n\n# TF-IDF vectorization (fit on sampled training texts)\nprint(\"Fitting TF-IDF vectorizer...\")\ntfidf = TfidfVectorizer(\n    max_features=TFIDF_MAX_FEATURES, ngram_range=(1, 2), stop_words=\"english\"\n)\nX = tfidf.fit_transform(train_texts)\nprint(f\"TF-IDF matrix shape: {X.shape}\")\n\n# Free memory\ndel train_texts\ngc.collect()\n\n# Cross-validation evaluation using One-vs-Rest with SGDClassifier\nkf = KFold(n_splits=N_FOLDS, shuffle=True, random_state=RANDOM_STATE)\nfold = 0\nf1_scores = []\nprint(f\"Starting {N_FOLDS}-fold cross-validation on sampled data...\")\n\nfor train_idx, val_idx in kf.split(X):\n    fold += 1\n    print(\n        f\"Fold {fold} - training on {len(train_idx)} samples, validating on {len(val_idx)} samples\"\n    )\n    X_train, X_val = X[train_idx], X[val_idx]\n    Y_train, Y_val = Y[train_idx], Y[val_idx]\n\n    classifier = OneVsRestClassifier(\n        SGDClassifier(loss=\"log\", max_iter=SGD_MAX_ITER, random_state=RANDOM_STATE),\n        n_jobs=-1,\n    )\n    classifier.fit(X_train, Y_train)\n    # decision_function -> convert to binary by thresholding at 0.0\n    try:\n        dec = classifier.decision_function(X_val)\n        # Ensure dec is a numpy array for argmax operations; handle sparse outputs\n        if hasattr(dec, \"toarray\"):\n            dec_arr = np.asarray(dec.toarray())\n        else:\n            dec_arr = np.asarray(dec)\n        Y_pred = (dec_arr > 0.0).astype(int)\n    except Exception:\n        # fallback to predict\n        Y_pred = classifier.predict(X_val)\n        dec_arr = None\n\n    # For any sample with no predicted labels, pick top scoring label\n    no_pred = Y_pred.sum(axis=1) == 0\n    if np.any(no_pred):\n        if dec_arr is not None:\n            # argmax across classes for each sample\n            top_idx = np.argmax(dec_arr, axis=1)\n        else:\n            # fallback: predict_proba (unlikely available) or assign most frequent tag index 0\n            try:\n                probs = classifier.predict_proba(X_val)\n                probs_arr = np.asarray(probs)\n                top_idx = np.argmax(probs_arr, axis=1)\n            except Exception:\n                top_idx = np.zeros(len(Y_pred), dtype=int)\n        # assign top predicted class for rows with no predictions\n        for i in np.where(no_pred)[0]:\n            Y_pred[i, int(top_idx[i])] = 1\n\n    score = f1_score(Y_val, Y_pred, average=\"samples\")\n    f1_scores.append(score)\n    print(f\"Fold {fold} F1 (samples): {score:.5f}\")\n\nmean_f1 = np.mean(f1_scores)\nprint(f\"{N_FOLDS}-fold mean sample-wise F1: {mean_f1:.5f}\")\n\n# Retrain on full sampled training set\nprint(\"Retraining on full sampled training data...\")\nfinal_clf = OneVsRestClassifier(\n    SGDClassifier(loss=\"log\", max_iter=SGD_MAX_ITER, random_state=RANDOM_STATE),\n    n_jobs=-1,\n)\nfinal_clf.fit(X, Y)\nprint(\"Final model trained.\")\n\n# Process test set in chunks and write submission\nprint(\"Processing test set and writing submission...\")\nif os.path.exists(SUBMISSION_FILE):\n    os.remove(SUBMISSION_FILE)\n\n# Write header\nwith open(SUBMISSION_FILE, \"w\", encoding=\"utf-8\") as f:\n    f.write(\"Id,Tags\\n\")\n\n# Stream test file in chunks\ntest_reader = pd.read_csv(\n    TEST_FILE, usecols=[\"Id\", \"Title\", \"Body\"], chunksize=CHUNK_SIZE_TEST\n)\nfor chunk_idx, chunk in enumerate(test_reader):\n    ids = chunk[\"Id\"].values\n    titles = chunk[\"Title\"].fillna(\"\").astype(str)\n    bodies = chunk[\"Body\"].fillna(\"\").astype(str)\n    texts = (titles + \" \" + bodies).values\n    X_test = tfidf.transform(texts)\n    try:\n        dec = final_clf.decision_function(X_test)\n        if hasattr(dec, \"toarray\"):\n            dec_arr = np.asarray(dec.toarray())\n        else:\n            dec_arr = np.asarray(dec)\n        Y_test_pred = (dec_arr > 0.0).astype(int)\n    except Exception:\n        Y_test_pred = final_clf.predict(X_test)\n        dec_arr = None\n\n    # Ensure at least one tag per sample\n    no_pred = Y_test_pred.sum(axis=1) == 0\n    if np.any(no_pred):\n        if dec_arr is not None:\n            top_idx = np.argmax(dec_arr, axis=1)\n        else:\n            try:\n                probs = final_clf.predict_proba(X_test)\n                probs_arr = np.asarray(probs)\n                top_idx = np.argmax(probs_arr, axis=1)\n            except Exception:\n                top_idx = np.zeros(len(ids), dtype=int)\n        for i in np.where(no_pred)[0]:\n            Y_test_pred[i, int(top_idx[i])] = 1\n\n    # Convert predictions to tag strings using mlb classes order\n    tag_arrays = mlb.inverse_transform(Y_test_pred)\n    lines = []\n    for id_val, tags in zip(ids, tag_arrays):\n        if len(tags) == 0:\n            # fallback: most frequent tag from training sample\n            tag_str = most_common[0] if most_common else \"\"\n        else:\n            tag_str = \" \".join(tags)\n        # Quote tag_str to follow expected format\n        # Ensure any internal quotes are escaped by doubling them\n        safe_tag_str = tag_str.replace('\"', '\"\"')\n        lines.append(f'{int(id_val)},\"{safe_tag_str}\"\\n')\n\n    # Append to file\n    with open(SUBMISSION_FILE, \"a\", encoding=\"utf-8\") as f:\n        f.writelines(lines)\n\n    print(f\"Processed test chunk {chunk_idx+1}, wrote {len(ids)} rows.\")\n    # free\n    del X_test, texts, ids, Y_test_pred, tag_arrays, titles, bodies\n    gc.collect()\n\nprint(f\"Submission saved to {SUBMISSION_FILE}\")\nprint(f\"Cross-validation mean sample-wise F1: {mean_f1:.6f}\")\n", "#!/usr/bin/env python3\nimport os\nimport re\nimport sys\nimport time\nfrom collections import Counter\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.linear_model import SGDClassifier\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.model_selection import KFold, cross_val_predict\nfrom sklearn.metrics import f1_score\n\n# Config / hyperparameters (kept conservative for runtime)\nINPUT_DIR = \"./input\"\nTRAIN_FILE = os.path.join(INPUT_DIR, \"train.csv\")\nTEST_FILE = os.path.join(INPUT_DIR, \"test.csv\")\nSUBMISSION_DIR = \"./submission\"\nSUBMISSION_FILE = os.path.join(SUBMISSION_DIR, \"submission.csv\")\n\nos.makedirs(SUBMISSION_DIR, exist_ok=True)\n\nRANDOM_STATE = 42\nSAMPLE_TARGET = 50000  # number of training rows to collect\nTOP_K_TAGS = 200  # number of most frequent tags to model\nTFIDF_MAX_FEATURES = 15000\nNGRAM_RANGE = (1, 2)\nCV_FOLDS = 5\nPRED_TOP_K = 3\nCOUNT_CHUNK_ROWS = 50000  # rows per chunk when counting tags\nCOLLECT_CHUNK = 50000  # rows per chunk when collecting examples\n\nnp.random.seed(RANDOM_STATE)\n\n\ndef parse_tags(tagstr):\n    if pd.isna(tagstr):\n        return []\n    s = str(tagstr).strip()\n    if not s:\n        return []\n    # pattern like <tag1><tag2>\n    if \"<\" in s and \">\" in s:\n        tags = re.findall(r\"<([^>]+)>\", s)\n        if tags:\n            return tags\n    # else assume space-separated\n    return s.split()\n\n\ndef get_top_tags_fast(\n    train_file, top_k=TOP_K_TAGS, sample_chunks=5, chunksize=COUNT_CHUNK_ROWS\n):\n    counter = Counter()\n    read_rows = 0\n    try:\n        reader = pd.read_csv(\n            train_file, usecols=[\"Tags\"], chunksize=chunksize, iterator=True, engine=\"c\"\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n    for i, chunk in enumerate(reader):\n        for t in chunk[\"Tags\"].dropna().astype(str):\n            if \"<\" in t and \">\" in t:\n                tags = re.findall(r\"<([^>]+)>\", t)\n            else:\n                tags = t.split()\n            counter.update(tags)\n        read_rows += len(chunk)\n        if i + 1 >= sample_chunks:\n            break\n    top_tags = [t for t, _ in counter.most_common(top_k)]\n    print(\n        f\"[info] Fast-pass counted ~{read_rows} rows, unique tags found: {len(counter)}. Selected top {len(top_tags)} tags.\",\n        file=sys.stderr,\n    )\n    return top_tags\n\n\ndef collect_examples_with_top_tags(\n    train_file, top_tags, sample_target=SAMPLE_TARGET, chunksize=COLLECT_CHUNK\n):\n    collected = []\n    collected_ids = set()\n    try:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"c\",\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n    for chunk in reader:\n        for idx, row in chunk.iterrows():\n            try:\n                rid = int(row[\"Id\"])\n            except Exception:\n                continue\n            if rid in collected_ids:\n                continue\n            tags = parse_tags(row.get(\"Tags\", \"\"))\n            # keep only if any top tag present\n            if any(t in top_tags for t in tags):\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n            if len(collected) >= sample_target:\n                break\n        if len(collected) >= sample_target:\n            break\n    # If not enough, do a second pass to fill up (without tag requirement)\n    if len(collected) < sample_target:\n        print(\n            f\"[info] Collected only {len(collected)} rows with top tags; filling up with additional rows...\",\n            file=sys.stderr,\n        )\n        try:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"c\",\n            )\n        except Exception:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"python\",\n            )\n        for chunk in reader2:\n            for idx, row in chunk.iterrows():\n                try:\n                    rid = int(row[\"Id\"])\n                except Exception:\n                    continue\n                if rid in collected_ids:\n                    continue\n                tags = parse_tags(row.get(\"Tags\", \"\"))\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n                if len(collected) >= sample_target:\n                    break\n            if len(collected) >= sample_target:\n                break\n    df = pd.DataFrame(collected, columns=[\"Id\", \"Title\", \"Body\", \"ParsedTags\"])\n    print(f\"[info] Total collected training examples: {len(df)}\", file=sys.stderr)\n    return df\n\n\ndef build_dataset_from_collected(df, top_tags):\n    df[\"Title\"] = df[\"Title\"].fillna(\"\").astype(str)\n    df[\"Body\"] = df[\"Body\"].fillna(\"\").astype(str)\n    df[\"text\"] = (\n        (df[\"Title\"] + \" \" + df[\"Body\"]).str.replace(\"\\n\", \" \").str.replace(\"\\r\", \" \")\n    )\n    df[\"TagsFiltered\"] = df[\"ParsedTags\"].apply(\n        lambda tags: [t for t in tags if t in top_tags]\n    )\n    before = len(df)\n    df = df[df[\"TagsFiltered\"].map(len) > 0].reset_index(drop=True)\n    after = len(df)\n    print(\n        f\"[info] Filtered dataset to {after} rows (from {before}) that contain at least one top tag.\",\n        file=sys.stderr,\n    )\n    y_lists = df[\"TagsFiltered\"].tolist()\n    return df, y_lists\n\n\ndef topk_from_scores(scores, k):\n    # scores shape (n_samples, n_classes)\n    n_samples, n_classes = scores.shape\n    k = min(k, n_classes)\n    # argsort and take top k indices (per row)\n    idx_sorted = np.argsort(scores, axis=1)\n    topk_idx = idx_sorted[:, -k:]\n    preds = np.zeros_like(scores, dtype=int)\n    rows = np.arange(n_samples)[:, None]\n    preds[rows, topk_idx] = 1\n    return preds\n\n\ndef main():\n    start_time = time.time()\n    print(\"[info] Starting training and prediction...\", file=sys.stderr)\n\n    # 1) Fast pass to get top tags\n    top_tags = get_top_tags_fast(\n        TRAIN_FILE, top_k=TOP_K_TAGS, sample_chunks=5, chunksize=COUNT_CHUNK_ROWS\n    )\n\n    # 2) Collect examples that contain top tags\n    sampled_df = collect_examples_with_top_tags(\n        TRAIN_FILE, top_tags, sample_target=SAMPLE_TARGET, chunksize=COLLECT_CHUNK\n    )\n\n    # Recompute top tags based on sampled data to ensure we model the most frequent among sampled ones\n    all_tags = []\n    for tags in sampled_df[\"ParsedTags\"]:\n        all_tags.extend(tags)\n    tag_counts = Counter(all_tags)\n    # Keep intersection with original top_tags but rely on counts from sampled set\n    top_tags_sampled = [t for t, _ in tag_counts.most_common(TOP_K_TAGS)]\n    top_tags = [\n        t for t in top_tags_sampled if t in top_tags\n    ]  # ensure subset (keeps order)\n    print(f\"[info] Final modeling tag count: {len(top_tags)}\", file=sys.stderr)\n    if len(top_tags) == 0:\n        print(\"[error] No top tags found after sampling; exiting.\", file=sys.stderr)\n        return\n\n    # 3) Build dataset\n    df, y_lists = build_dataset_from_collected(sampled_df, top_tags)\n    if len(df) < 50:\n        print(\"[error] Too few examples after filtering. Exiting.\", file=sys.stderr)\n        return\n\n    texts = df[\"text\"].tolist()\n    ids = df[\"Id\"].tolist()\n\n    # 4) Vectorize\n    print(\"[info] Fitting TF-IDF vectorizer...\", file=sys.stderr)\n    vectorizer = TfidfVectorizer(\n        max_features=TFIDF_MAX_FEATURES, ngram_range=NGRAM_RANGE, stop_words=\"english\"\n    )\n    X = vectorizer.fit_transform(texts)\n    print(f\"[info] TF-IDF shaped: {X.shape}\", file=sys.stderr)\n\n    # 5) Binarize labels (do NOT pass classes param to avoid mismatches)\n    mlb = MultiLabelBinarizer()\n    Y = mlb.fit_transform(y_lists)\n    # If some requested top tags didn't appear, we might want to limit mlb classes to intersection\n    classes = list(mlb.classes_)\n    print(\n        f\"[info] Label matrix shaped: {Y.shape}. Modeling {len(classes)} classes.\",\n        file=sys.stderr,\n    )\n\n    # 6) Build classifier\n    base_clf = SGDClassifier(\n        loss=\"log\", max_iter=1000, tol=1e-3, random_state=RANDOM_STATE\n    )\n    clf = OneVsRestClassifier(base_clf, n_jobs=1)\n\n    # 7) Cross-validated predictions to compute sample-wise F1\n    print(f\"[info] Performing {CV_FOLDS}-fold cross-validation...\", file=sys.stderr)\n    kf = KFold(n_splits=CV_FOLDS, shuffle=True, random_state=RANDOM_STATE)\n    try:\n        # decision_function returns real-valued scores suitable for ranking\n        scores_cv = cross_val_predict(\n            clf, X, Y, cv=kf, method=\"decision_function\", n_jobs=1\n        )\n    except Exception as e:\n        print(\n            f\"[warning] cross_val_predict with decision_function failed: {e}. Falling back to predict.\",\n            file=sys.stderr,\n        )\n        # fallback to predict (binary) and convert to float\n        preds_cv = cross_val_predict(clf, X, Y, cv=kf, method=\"predict\", n_jobs=1)\n        scores_cv = preds_cv.astype(float)\n    if scores_cv.ndim == 1:\n        scores_cv = scores_cv.reshape(-1, 1)\n    # derive top-k binary predictions\n    y_pred_cv = topk_from_scores(scores_cv, PRED_TOP_K)\n    # Make sure shape matches Y\n    if y_pred_cv.shape != Y.shape:\n        # attempt to align columns if different\n        min_cols = min(y_pred_cv.shape[1], Y.shape[1])\n        y_pred_cv = y_pred_cv[:, :min_cols]\n        Y_eval = Y[:, :min_cols]\n    else:\n        Y_eval = Y\n    f1 = f1_score(Y_eval, y_pred_cv, average=\"samples\")\n    print(f\"[info] Cross-validated sample-wise F1: {f1:.6f}\", file=sys.stderr)\n\n    # 8) Retrain on full sampled data\n    print(\"[info] Retraining classifier on full sampled data...\", file=sys.stderr)\n    clf.fit(X, Y)\n\n    # 9) Predict on test set in chunks and write submission\n    print(\"[info] Predicting on test set and writing submission...\", file=sys.stderr)\n    sub_rows = []\n    total_test = 0\n    try:\n        test_reader = pd.read_csv(\n            TEST_FILE,\n            usecols=[\"Id\", \"Title\", \"Body\"],\n            chunksize=50000,\n            iterator=True,\n            engine=\"c\",\n        )\n    except Exception:\n        test_reader = pd.read_csv(\n            TEST_FILE,\n            usecols=[\"Id\", \"Title\", \"Body\"],\n            chunksize=50000,\n            iterator=True,\n            engine=\"python\",\n        )\n\n    for chunk in test_reader:\n        chunk_ids = chunk[\"Id\"].tolist()\n        titles = chunk[\"Title\"].fillna(\"\").astype(str).tolist()\n        bodies = chunk[\"Body\"].fillna(\"\").astype(str).tolist()\n        texts_chunk = [\n            (t + \" \" + b).replace(\"\\n\", \" \").replace(\"\\r\", \" \")\n            for t, b in zip(titles, bodies)\n        ]\n        Xtest = vectorizer.transform(texts_chunk)\n        # get decision scores\n        try:\n            scores_test = clf.decision_function(Xtest)\n        except Exception:\n            preds = clf.predict(Xtest)\n            scores_test = preds.astype(float)\n        if scores_test.ndim == 1:\n            scores_test = scores_test.reshape(-1, 1)\n        preds_bin = topk_from_scores(scores_test, PRED_TOP_K)\n        # For each row, if no label selected (all zeros), take the highest-scoring class for that row\n        for i, rid in enumerate(chunk_ids):\n            row_pred = preds_bin[i]\n            if row_pred.sum() == 0:\n                # pick argmax for this row\n                if scores_test.shape[1] > 0:\n                    idx = int(np.argmax(scores_test[i]))\n                    tags = [mlb.classes_[idx]]\n                else:\n                    tags = []\n            else:\n                lbl_idx = np.where(row_pred == 1)[0]\n                tags = [mlb.classes_[j] for j in lbl_idx]\n            tags_str = \" \".join(tags)\n            sub_rows.append((int(rid), tags_str))\n        total_test += len(chunk_ids)\n        print(f\"[info] Processed {total_test} test rows...\", file=sys.stderr)\n\n    # Write submission CSV\n    print(f\"[info] Writing submission to {SUBMISSION_FILE} ...\", file=sys.stderr)\n    with open(SUBMISSION_FILE, \"w\", encoding=\"utf-8\") as f:\n        f.write(\"Id,Tags\\n\")\n        for rid, tags in sub_rows:\n            # escape double quotes in tags just in case (tags should not contain quotes)\n            safe_tags = tags.replace('\"', \"'\")\n            f.write(f'{rid},\"{safe_tags}\"\\n')\n\n    elapsed = time.time() - start_time\n    print(f\"[info] Done. Time elapsed: {elapsed:.1f} sec\", file=sys.stderr)\n    # Print the metric to stdout (required)\n    print(f\"{f1:.6f}\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\nimport os\nimport re\nimport sys\nimport time\nfrom collections import Counter\nimport random\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.linear_model import SGDClassifier\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.model_selection import KFold, cross_val_predict\nfrom sklearn.metrics import f1_score\n\n# Config / hyperparameters\nINPUT_DIR = \"./input\"\nTRAIN_FILE = os.path.join(INPUT_DIR, \"train.csv\")\nTEST_FILE = os.path.join(INPUT_DIR, \"test.csv\")\nSUBMISSION_DIR = \"./submission\"\nSUBMISSION_FILE = os.path.join(SUBMISSION_DIR, \"submission.csv\")\nos.makedirs(SUBMISSION_DIR, exist_ok=True)\n\nRANDOM_STATE = 42\nSAMPLE_TARGET = 30000  # number of training rows to collect (kept moderate)\nTOP_K_TAGS = 200  # number of most frequent tags to model\nTFIDF_MAX_FEATURES = 15000\nNGRAM_RANGE = (1, 2)\nCV_FOLDS = 5\nPRED_TOP_K = 3\nCOUNT_CHUNK_ROWS = 50000  # rows per chunk when counting tags\nCOLLECT_CHUNK = 50000  # rows per chunk when collecting examples\nnp.random.seed(RANDOM_STATE)\nrandom.seed(RANDOM_STATE)\n\n\ndef parse_tags(tagstr):\n    \"\"\"Robust tag parsing: handle <a><b> format or space-separated tags.\"\"\"\n    if pd.isna(tagstr):\n        return []\n    s = str(tagstr).strip()\n    if not s:\n        return []\n    if \"<\" in s and \">\" in s:\n        tags = re.findall(r\"<([^>]+)>\", s)\n        if tags:\n            return [t.strip().lower() for t in tags if t.strip()]\n    # otherwise assume space-separated\n    parts = [p.strip().lower() for p in s.split() if p.strip()]\n    return parts\n\n\ndef get_top_tags_fast(\n    train_file, top_k=TOP_K_TAGS, sample_chunks=6, chunksize=COUNT_CHUNK_ROWS\n):\n    counter = Counter()\n    read_rows = 0\n    try:\n        reader = pd.read_csv(\n            train_file, usecols=[\"Tags\"], chunksize=chunksize, iterator=True, engine=\"c\"\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n    for i, chunk in enumerate(reader):\n        for t in chunk[\"Tags\"].dropna().astype(str):\n            tags = parse_tags(t)\n            counter.update(tags)\n        read_rows += len(chunk)\n        if i + 1 >= sample_chunks:\n            break\n    top_tags = [t for t, _ in counter.most_common(top_k)]\n    print(\n        f\"[info] Fast-pass counted ~{read_rows} rows, unique tags found: {len(counter)}. Selected top {len(top_tags)} tags.\",\n        file=sys.stderr,\n    )\n    return top_tags\n\n\ndef collect_examples_with_top_tags(\n    train_file, top_tags, sample_target=SAMPLE_TARGET, chunksize=COLLECT_CHUNK\n):\n    \"\"\"Collect examples that contain at least one of top_tags; fill up if needed.\"\"\"\n    collected = []\n    collected_ids = set()\n    try:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"c\",\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n    for chunk in reader:\n        for _, row in chunk.iterrows():\n            try:\n                rid = int(row[\"Id\"])\n            except Exception:\n                continue\n            if rid in collected_ids:\n                continue\n            tags = parse_tags(row.get(\"Tags\", \"\"))\n            if any(t in top_tags for t in tags):\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n            if len(collected) >= sample_target:\n                break\n        if len(collected) >= sample_target:\n            break\n\n    # Fill up with additional rows (random sample) if not enough\n    if len(collected) < sample_target:\n        print(\n            f\"[info] Collected only {len(collected)} rows with top tags; filling up with additional rows...\",\n            file=sys.stderr,\n        )\n        # We'll sample more rows by scanning again and adding until target\n        try:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"c\",\n            )\n        except Exception:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"python\",\n            )\n        for chunk in reader2:\n            for _, row in chunk.iterrows():\n                try:\n                    rid = int(row[\"Id\"])\n                except Exception:\n                    continue\n                if rid in collected_ids:\n                    continue\n                tags = parse_tags(row.get(\"Tags\", \"\"))\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n                if len(collected) >= sample_target:\n                    break\n            if len(collected) >= sample_target:\n                break\n\n    df = pd.DataFrame(collected, columns=[\"Id\", \"Title\", \"Body\", \"ParsedTags\"])\n    print(f\"[info] Total collected training examples: {len(df)}\", file=sys.stderr)\n    return df\n\n\ndef build_dataset_from_collected(df, top_tags):\n    df[\"Title\"] = df[\"Title\"].fillna(\"\").astype(str)\n    df[\"Body\"] = df[\"Body\"].fillna(\"\").astype(str)\n    df[\"text\"] = (\n        (df[\"Title\"] + \" \" + df[\"Body\"]).str.replace(\"\\n\", \" \").str.replace(\"\\r\", \" \")\n    )\n    df[\"TagsFiltered\"] = df[\"ParsedTags\"].apply(\n        lambda tags: [t for t in tags if t in top_tags]\n    )\n    before = len(df)\n    df = df[df[\"TagsFiltered\"].map(len) > 0].reset_index(drop=True)\n    after = len(df)\n    print(\n        f\"[info] Filtered dataset to {after} rows (from {before}) that contain at least one top tag.\",\n        file=sys.stderr,\n    )\n    y_lists = df[\"TagsFiltered\"].tolist()\n    return df, y_lists\n\n\ndef topk_from_scores(scores, k):\n    # scores shape (n_samples, n_classes)\n    n_samples = scores.shape[0]\n    n_classes = scores.shape[1] if scores.ndim > 1 else 1\n    k = min(k, n_classes)\n    if n_classes == 1:\n        # For single class treat thresholding: predict class for all since only one possible\n        return np.ones((n_samples, 1), dtype=int)\n    # argsort and take top k indices (per row)\n    idx_sorted = np.argsort(scores, axis=1)\n    topk_idx = idx_sorted[:, -k:]\n    preds = np.zeros_like(scores, dtype=int)\n    rows = np.arange(n_samples)[:, None]\n    preds[rows, topk_idx] = 1\n    return preds\n\n\ndef safe_cross_val_scores(clf, X, Y, cv):\n    \"\"\"Try decision_function, else predict_proba, else predict. Always return float array scores shape (n_samples, n_classes).\"\"\"\n    methods = [\"decision_function\", \"predict_proba\", \"predict\"]\n    for method in methods:\n        try:\n            scores = cross_val_predict(clf, X, Y, cv=cv, method=method, n_jobs=1)\n            scores = np.asarray(scores)\n            # If predict returned binary matrix, cast to float\n            if method == \"predict\":\n                scores = scores.astype(float)\n            # Ensure 2D\n            if scores.ndim == 1:\n                scores = scores.reshape(-1, 1)\n            return scores\n        except Exception as e:\n            print(\n                f\"[warning] cross_val_predict with {method} failed: {e}\",\n                file=sys.stderr,\n            )\n            continue\n    # As last resort, return zeros\n    print(\n        \"[warning] All cross_val_predict attempts failed; returning zeros.\",\n        file=sys.stderr,\n    )\n    return np.zeros(Y.shape, dtype=float)\n\n\ndef main():\n    start_time = time.time()\n    print(\"[info] Starting training and prediction...\", file=sys.stderr)\n\n    # 1) Fast pass to get top tags\n    top_tags = get_top_tags_fast(\n        TRAIN_FILE, top_k=TOP_K_TAGS, sample_chunks=6, chunksize=COUNT_CHUNK_ROWS\n    )\n    if len(top_tags) == 0:\n        print(\"[error] No tags found in training data; exiting.\", file=sys.stderr)\n        return\n\n    # 2) Collect examples that contain top tags\n    sampled_df = collect_examples_with_top_tags(\n        TRAIN_FILE, top_tags, sample_target=SAMPLE_TARGET, chunksize=COLLECT_CHUNK\n    )\n\n    # Recompute top tags based on sampled data to ensure best coverage among sampled ones\n    all_tags = []\n    for tags in sampled_df[\"ParsedTags\"]:\n        all_tags.extend(tags)\n    tag_counts = Counter(all_tags)\n    top_tags_sampled = [t for t, _ in tag_counts.most_common(TOP_K_TAGS)]\n    # Ensure we keep only tags present originally and limit to TOP_K_TAGS\n    top_tags = [t for t in top_tags_sampled if t in top_tags][:TOP_K_TAGS]\n    print(f\"[info] Final modeling tag count: {len(top_tags)}\", file=sys.stderr)\n    if len(top_tags) == 0:\n        print(\"[error] No top tags found after sampling; exiting.\", file=sys.stderr)\n        return\n\n    # 3) Build dataset\n    df, y_lists = build_dataset_from_collected(sampled_df, top_tags)\n    if len(df) < 50:\n        print(\"[error] Too few examples after filtering. Exiting.\", file=sys.stderr)\n        return\n\n    texts = df[\"text\"].tolist()\n    ids = df[\"Id\"].tolist()\n\n    # 4) Vectorize\n    print(\"[info] Fitting TF-IDF vectorizer...\", file=sys.stderr)\n    vectorizer = TfidfVectorizer(\n        max_features=TFIDF_MAX_FEATURES, ngram_range=NGRAM_RANGE, stop_words=\"english\"\n    )\n    X = vectorizer.fit_transform(texts)\n    print(f\"[info] TF-IDF shaped: {X.shape}\", file=sys.stderr)\n\n    # 5) Binarize labels with explicit classes order to guarantee alignment\n    mlb = MultiLabelBinarizer(classes=top_tags)\n    Y = mlb.fit_transform(y_lists)  # mlb.classes_ will equal top_tags\n    classes = list(mlb.classes_)\n    print(\n        f\"[info] Label matrix shaped: {Y.shape}. Modeling {len(classes)} classes.\",\n        file=sys.stderr,\n    )\n\n    # 6) Build classifier\n    base_clf = SGDClassifier(\n        loss=\"log\", max_iter=1000, tol=1e-3, random_state=RANDOM_STATE\n    )\n    clf = OneVsRestClassifier(base_clf, n_jobs=1)\n\n    # 7) Cross-validated predictions to compute sample-wise F1\n    print(f\"[info] Performing {CV_FOLDS}-fold cross-validation...\", file=sys.stderr)\n    kf = KFold(n_splits=CV_FOLDS, shuffle=True, random_state=RANDOM_STATE)\n    scores_cv = safe_cross_val_scores(clf, X, Y, cv=kf)\n    if scores_cv.ndim == 1:\n        scores_cv = scores_cv.reshape(-1, 1)\n    # derive top-k binary predictions\n    y_pred_cv = topk_from_scores(scores_cv, PRED_TOP_K)\n    # Align shapes if necessary\n    if y_pred_cv.shape != Y.shape:\n        min_cols = min(y_pred_cv.shape[1], Y.shape[1])\n        y_pred_cv = y_pred_cv[:, :min_cols]\n        Y_eval = Y[:, :min_cols]\n    else:\n        Y_eval = Y\n    f1 = f1_score(Y_eval, y_pred_cv, average=\"samples\")\n    # Print metric to stdout as required\n    print(f\"{f1:.6f}\")\n    print(f\"[info] Cross-validated sample-wise F1: {f1:.6f}\", file=sys.stderr)\n\n    # 8) Retrain on full sampled data\n    print(\"[info] Retraining classifier on full sampled data...\", file=sys.stderr)\n    clf.fit(X, Y)\n\n    # 9) Predict on test set in chunks and write submission\n    print(\"[info] Predicting on test set and writing submission...\", file=sys.stderr)\n    sub_rows = []\n    total_test = 0\n    try:\n        test_reader = pd.read_csv(\n            TEST_FILE,\n            usecols=[\"Id\", \"Title\", \"Body\"],\n            chunksize=50000,\n            iterator=True,\n            engine=\"c\",\n        )\n    except Exception:\n        test_reader = pd.read_csv(\n            TEST_FILE,\n            usecols=[\"Id\", \"Title\", \"Body\"],\n            chunksize=50000,\n            iterator=True,\n            engine=\"python\",\n        )\n\n    for chunk in test_reader:\n        chunk_ids = chunk[\"Id\"].tolist()\n        titles = chunk[\"Title\"].fillna(\"\").astype(str).tolist()\n        bodies = chunk[\"Body\"].fillna(\"\").astype(str).tolist()\n        texts_chunk = [\n            (t + \" \" + b).replace(\"\\n\", \" \").replace(\"\\r\", \" \")\n            for t, b in zip(titles, bodies)\n        ]\n        Xtest = vectorizer.transform(texts_chunk)\n        # get decision scores\n        scores_test = None\n        try:\n            scores_test = clf.decision_function(Xtest)\n        except Exception:\n            try:\n                # predict_proba might not be available; attempt if underlying supports it\n                scores_test = clf.predict_proba(Xtest)\n            except Exception:\n                preds = clf.predict(Xtest)\n                scores_test = preds.astype(float)\n        scores_test = np.asarray(scores_test)\n        if scores_test.ndim == 1:\n            scores_test = scores_test.reshape(-1, 1)\n        preds_bin = topk_from_scores(scores_test, PRED_TOP_K)\n        # For each row, if no label selected (all zeros), take the highest-scoring class for that row\n        for i, rid in enumerate(chunk_ids):\n            row_pred = preds_bin[i]\n            if row_pred.sum() == 0:\n                # pick argmax for this row\n                if scores_test.shape[1] > 0:\n                    idx = int(np.argmax(scores_test[i]))\n                    tags = [mlb.classes_[idx]]\n                else:\n                    tags = []\n            else:\n                lbl_idx = np.where(row_pred == 1)[0]\n                tags = [mlb.classes_[j] for j in lbl_idx]\n            tags_str = \" \".join(tags)\n            sub_rows.append((int(rid), tags_str))\n        total_test += len(chunk_ids)\n        print(f\"[info] Processed {total_test} test rows...\", file=sys.stderr)\n\n    # Write submission CSV\n    print(f\"[info] Writing submission to {SUBMISSION_FILE} ...\", file=sys.stderr)\n    with open(SUBMISSION_FILE, \"w\", encoding=\"utf-8\") as f:\n        f.write(\"Id,Tags\\n\")\n        for rid, tags in sub_rows:\n            safe_tags = tags.replace('\"', \"'\")\n            f.write(f'{rid},\"{safe_tags}\"\\n')\n\n    elapsed = time.time() - start_time\n    print(f\"[info] Done. Time elapsed: {elapsed:.1f} sec\", file=sys.stderr)\n\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\nimport os\nimport re\nimport sys\nimport time\nfrom collections import Counter\nimport random\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.model_selection import KFold, cross_val_predict\nfrom sklearn.metrics import f1_score\n\n# Config / hyperparameters (kept conservative for speed & memory)\nINPUT_DIR = \"./input\"\nTRAIN_FILE = os.path.join(INPUT_DIR, \"train.csv\")\nTEST_FILE = os.path.join(INPUT_DIR, \"test.csv\")\nSUBMISSION_DIR = \"./submission\"\nSUBMISSION_FILE = os.path.join(SUBMISSION_DIR, \"submission.csv\")\nos.makedirs(SUBMISSION_DIR, exist_ok=True)\n\nRANDOM_STATE = 42\nSAMPLE_TARGET = 20000  # number of training rows to collect (moderate)\nTOP_K_TAGS = 150  # number of most frequent tags to model\nTFIDF_MAX_FEATURES = 10000\nNGRAM_RANGE = (1, 2)\nCV_FOLDS = 5\nPRED_TOP_K = 3\nCOUNT_CHUNK_ROWS = 50000  # rows per chunk when counting tags\nCOLLECT_CHUNK = 50000  # rows per chunk when collecting examples\nnp.random.seed(RANDOM_STATE)\nrandom.seed(RANDOM_STATE)\n\n\ndef parse_tags(tagstr):\n    \"\"\"Robust tag parsing: handle <a><b> format or space-separated tags.\"\"\"\n    if pd.isna(tagstr):\n        return []\n    s = str(tagstr).strip()\n    if not s:\n        return []\n    # Common Kaggle format: tags as \"<tag1><tag2>\"\n    if \"<\" in s and \">\" in s:\n        tags = re.findall(r\"<([^>]+)>\", s)\n        if tags:\n            return [t.strip().lower() for t in tags if t.strip()]\n    # otherwise assume space-separated\n    parts = [p.strip().lower() for p in s.split() if p.strip()]\n    return parts\n\n\ndef get_top_tags_fast(\n    train_file, top_k=TOP_K_TAGS, sample_chunks=6, chunksize=COUNT_CHUNK_ROWS\n):\n    counter = Counter()\n    read_rows = 0\n    try:\n        reader = pd.read_csv(\n            train_file, usecols=[\"Tags\"], chunksize=chunksize, iterator=True, engine=\"c\"\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n    for i, chunk in enumerate(reader):\n        for t in chunk[\"Tags\"].dropna().astype(str):\n            counter.update(parse_tags(t))\n        read_rows += len(chunk)\n        if i + 1 >= sample_chunks:\n            break\n    top_tags = [t for t, _ in counter.most_common(top_k)]\n    print(\n        f\"[info] Fast-pass counted ~{read_rows} rows, unique tags: {len(counter)}. Selected top {len(top_tags)} tags.\",\n        file=sys.stderr,\n    )\n    return top_tags\n\n\ndef collect_examples_with_top_tags(\n    train_file, top_tags, sample_target=SAMPLE_TARGET, chunksize=COLLECT_CHUNK\n):\n    \"\"\"Collect examples that contain at least one of top_tags; fill up if needed (scans once, then second pass if necessary).\"\"\"\n    collected = []\n    collected_ids = set()\n    try:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"c\",\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n    for chunk in reader:\n        for _, row in chunk.iterrows():\n            try:\n                rid = int(row[\"Id\"])\n            except Exception:\n                continue\n            if rid in collected_ids:\n                continue\n            tags = parse_tags(row.get(\"Tags\", \"\"))\n            if any(t in top_tags for t in tags):\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n            if len(collected) >= sample_target:\n                break\n        if len(collected) >= sample_target:\n            break\n\n    # If not enough, do a second pass and add arbitrary rows (to reach target) to improve diversity\n    if len(collected) < sample_target:\n        print(\n            f\"[info] Collected only {len(collected)} rows with top tags; doing second pass to fill up to {sample_target}.\",\n            file=sys.stderr,\n        )\n        try:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"c\",\n            )\n        except Exception:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"python\",\n            )\n        for chunk in reader2:\n            for _, row in chunk.iterrows():\n                try:\n                    rid = int(row[\"Id\"])\n                except Exception:\n                    continue\n                if rid in collected_ids:\n                    continue\n                tags = parse_tags(row.get(\"Tags\", \"\"))\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n                if len(collected) >= sample_target:\n                    break\n            if len(collected) >= sample_target:\n                break\n\n    df = pd.DataFrame(collected, columns=[\"Id\", \"Title\", \"Body\", \"ParsedTags\"])\n    print(f\"[info] Total collected training examples: {len(df)}\", file=sys.stderr)\n    return df\n\n\ndef build_dataset_from_collected(df, top_tags):\n    df[\"Title\"] = df[\"Title\"].fillna(\"\").astype(str)\n    df[\"Body\"] = df[\"Body\"].fillna(\"\").astype(str)\n    # normalize newlines\n    df[\"text\"] = (\n        (df[\"Title\"] + \" \" + df[\"Body\"]).str.replace(\"\\n\", \" \").str.replace(\"\\r\", \" \")\n    )\n    df[\"TagsFiltered\"] = df[\"ParsedTags\"].apply(\n        lambda tags: [t for t in tags if t in top_tags]\n    )\n    before = len(df)\n    df = df[df[\"TagsFiltered\"].map(len) > 0].reset_index(drop=True)\n    after = len(df)\n    print(\n        f\"[info] Filtered dataset to {after} rows (from {before}) that contain at least one top tag.\",\n        file=sys.stderr,\n    )\n    y_lists = df[\"TagsFiltered\"].tolist()\n    return df, y_lists\n\n\ndef topk_from_scores(scores, k):\n    # scores shape (n_samples, n_classes)\n    n_samples = scores.shape[0]\n    if scores.ndim == 1:\n        scores = scores.reshape(-1, 1)\n    n_classes = scores.shape[1]\n    k = min(k, n_classes)\n    if n_classes == 0:\n        return np.zeros((n_samples, 0), dtype=int)\n    idx_sorted = np.argsort(scores, axis=1)\n    topk_idx = idx_sorted[:, -k:]\n    preds = np.zeros((n_samples, n_classes), dtype=int)\n    rows = np.arange(n_samples)[:, None]\n    preds[rows, topk_idx] = 1\n    return preds\n\n\ndef safe_cross_val_scores(clf, X, Y, cv):\n    \"\"\"Try decision_function, else predict_proba, else predict. Return float array scores shape (n_samples, n_classes).\"\"\"\n    methods = [\"decision_function\", \"predict_proba\", \"predict\"]\n    for method in methods:\n        try:\n            scores = cross_val_predict(clf, X, Y, cv=cv, method=method, n_jobs=1)\n            scores = np.asarray(scores)\n            # predict may return binary matrix; cast to float\n            if method == \"predict\":\n                scores = scores.astype(float)\n            if scores.ndim == 1:\n                scores = scores.reshape(-1, 1)\n            return scores\n        except Exception as e:\n            print(\n                f\"[warning] cross_val_predict with {method} failed: {e}\",\n                file=sys.stderr,\n            )\n            continue\n    print(\n        \"[warning] All cross_val_predict attempts failed; returning zeros.\",\n        file=sys.stderr,\n    )\n    return np.zeros(Y.shape, dtype=float)\n\n\ndef main():\n    start_time = time.time()\n    print(\"[info] Starting training and prediction...\", file=sys.stderr)\n\n    # 1) Fast pass to get top tags (sample few chunks)\n    top_tags = get_top_tags_fast(\n        TRAIN_FILE, top_k=TOP_K_TAGS, sample_chunks=6, chunksize=COUNT_CHUNK_ROWS\n    )\n    if len(top_tags) == 0:\n        print(\"[error] No tags found in training data; exiting.\", file=sys.stderr)\n        return\n\n    # 2) Collect examples that contain top tags\n    sampled_df = collect_examples_with_top_tags(\n        TRAIN_FILE, top_tags, sample_target=SAMPLE_TARGET, chunksize=COLLECT_CHUNK\n    )\n\n    # Recompute top tags based on sampled data to ensure best coverage among sampled ones\n    all_tags = []\n    for tags in sampled_df[\"ParsedTags\"]:\n        all_tags.extend(tags)\n    tag_counts = Counter(all_tags)\n    top_tags_sampled = [t for t, _ in tag_counts.most_common(TOP_K_TAGS)]\n    top_tags = top_tags_sampled[:TOP_K_TAGS]\n    print(f\"[info] Final modeling tag count: {len(top_tags)}\", file=sys.stderr)\n    if len(top_tags) == 0:\n        print(\"[error] No top tags found after sampling; exiting.\", file=sys.stderr)\n        return\n\n    # 3) Build dataset\n    df, y_lists = build_dataset_from_collected(sampled_df, top_tags)\n    if len(df) < 50:\n        print(\"[error] Too few examples after filtering. Exiting.\", file=sys.stderr)\n        return\n\n    texts = df[\"text\"].tolist()\n    ids = df[\"Id\"].tolist()\n\n    # 4) Vectorize\n    print(\"[info] Fitting TF-IDF vectorizer...\", file=sys.stderr)\n    vectorizer = TfidfVectorizer(\n        max_features=TFIDF_MAX_FEATURES, ngram_range=NGRAM_RANGE, stop_words=\"english\"\n    )\n    X = vectorizer.fit_transform(texts)\n    print(f\"[info] TF-IDF shaped: {X.shape}\", file=sys.stderr)\n\n    # 5) Binarize labels with explicit classes order to guarantee alignment\n    mlb = MultiLabelBinarizer(classes=top_tags)\n    Y = mlb.fit_transform(y_lists)\n    classes = list(mlb.classes_)\n    print(\n        f\"[info] Label matrix shaped: {Y.shape}. Modeling {len(classes)} classes.\",\n        file=sys.stderr,\n    )\n\n    # 6) Build classifier (One-vs-Rest logistic - decision_function available)\n    base_clf = LogisticRegression(\n        solver=\"saga\", max_iter=400, C=1.0, random_state=RANDOM_STATE, n_jobs=1\n    )\n    clf = OneVsRestClassifier(base_clf, n_jobs=1)\n\n    # 7) Cross-validated predictions to compute sample-wise F1\n    print(f\"[info] Performing {CV_FOLDS}-fold cross-validation...\", file=sys.stderr)\n    kf = KFold(\n        n_splits=min(CV_FOLDS, max(2, X.shape[0] // 50)),\n        shuffle=True,\n        random_state=RANDOM_STATE,\n    )\n    scores_cv = safe_cross_val_scores(clf, X, Y, cv=kf)\n    if scores_cv.ndim == 1:\n        scores_cv = scores_cv.reshape(-1, 1)\n    # derive top-k binary predictions\n    y_pred_cv = topk_from_scores(scores_cv, PRED_TOP_K)\n    # Align shapes if necessary\n    if y_pred_cv.shape != Y.shape:\n        min_cols = min(y_pred_cv.shape[1], Y.shape[1])\n        y_pred_cv = y_pred_cv[:, :min_cols]\n        Y_eval = Y[:, :min_cols]\n    else:\n        Y_eval = Y\n    try:\n        f1 = f1_score(Y_eval, y_pred_cv, average=\"samples\")\n    except Exception:\n        f1 = 0.0\n    # Print metric to stdout as required\n    print(f\"{f1:.6f}\")\n    print(f\"[info] Cross-validated sample-wise F1: {f1:.6f}\", file=sys.stderr)\n\n    # 8) Retrain on full sampled data\n    print(\"[info] Retraining classifier on full sampled data...\", file=sys.stderr)\n    clf.fit(X, Y)\n\n    # 9) Predict on test set in chunks and write submission\n    print(\"[info] Predicting on test set and writing submission...\", file=sys.stderr)\n    sub_rows = []\n    total_test = 0\n    try:\n        test_reader = pd.read_csv(\n            TEST_FILE,\n            usecols=[\"Id\", \"Title\", \"Body\"],\n            chunksize=50000,\n            iterator=True,\n            engine=\"c\",\n        )\n    except Exception:\n        test_reader = pd.read_csv(\n            TEST_FILE,\n            usecols=[\"Id\", \"Title\", \"Body\"],\n            chunksize=50000,\n            iterator=True,\n            engine=\"python\",\n        )\n\n    for chunk in test_reader:\n        chunk_ids = chunk[\"Id\"].tolist()\n        titles = chunk[\"Title\"].fillna(\"\").astype(str).tolist()\n        bodies = chunk[\"Body\"].fillna(\"\").astype(str).tolist()\n        texts_chunk = [\n            (t + \" \" + b).replace(\"\\n\", \" \").replace(\"\\r\", \" \")\n            for t, b in zip(titles, bodies)\n        ]\n        Xtest = vectorizer.transform(texts_chunk)\n        # get decision scores\n        scores_test = None\n        try:\n            scores_test = clf.decision_function(Xtest)\n        except Exception:\n            try:\n                scores_test = clf.predict_proba(Xtest)\n            except Exception:\n                preds = clf.predict(Xtest)\n                scores_test = preds.astype(float)\n        scores_test = np.asarray(scores_test)\n        if scores_test.ndim == 1:\n            scores_test = scores_test.reshape(-1, 1)\n        preds_bin = topk_from_scores(scores_test, PRED_TOP_K)\n        # For each row, if no label selected (all zeros), take the highest-scoring class for that row\n        for i, rid in enumerate(chunk_ids):\n            row_pred = preds_bin[i]\n            if row_pred.sum() == 0:\n                if scores_test.shape[1] > 0:\n                    idx = int(np.argmax(scores_test[i]))\n                    tags = [mlb.classes_[idx]]\n                else:\n                    tags = []\n            else:\n                lbl_idx = np.where(row_pred == 1)[0]\n                tags = [mlb.classes_[j] for j in lbl_idx]\n            tags_str = \" \".join(tags)\n            sub_rows.append((int(rid), tags_str))\n        total_test += len(chunk_ids)\n        print(f\"[info] Processed {total_test} test rows...\", file=sys.stderr)\n\n    # Write submission CSV\n    print(f\"[info] Writing submission to {SUBMISSION_FILE} ...\", file=sys.stderr)\n    with open(SUBMISSION_FILE, \"w\", encoding=\"utf-8\") as f:\n        f.write(\"Id,Tags\\n\")\n        for rid, tags in sub_rows:\n            safe_tags = tags.replace('\"', \"'\")\n            f.write(f'{rid},\"{safe_tags}\"\\n')\n\n    elapsed = time.time() - start_time\n    print(f\"[info] Done. Time elapsed: {elapsed:.1f} sec\", file=sys.stderr)\n\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\nimport os\nimport re\nimport sys\nimport time\nfrom collections import Counter\nimport random\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.model_selection import KFold, cross_val_predict\nfrom sklearn.metrics import f1_score\n\n# Configuration (kept conservative to run in reasonable time)\nINPUT_DIR = \"./input\"\nTRAIN_FILE = os.path.join(INPUT_DIR, \"train.csv\")\nTEST_FILE = os.path.join(INPUT_DIR, \"test.csv\")\nSUBMISSION_DIR = \"./submission\"\nSUBMISSION_FILE = os.path.join(SUBMISSION_DIR, \"submission.csv\")\nos.makedirs(SUBMISSION_DIR, exist_ok=True)\n\nRANDOM_STATE = 42\nnp.random.seed(RANDOM_STATE)\nrandom.seed(RANDOM_STATE)\n\n# Sampling / model hyperparameters\nSAMPLE_TARGET = 12000  # number of training rows to collect (smaller to speed up)\nTOP_K_TAGS = 100  # number of most frequent tags to model\nTFIDF_MAX_FEATURES = 8000\nNGRAM_RANGE = (1, 2)\nCV_FOLDS = 5\nPRED_TOP_K = 3\nCOUNT_CHUNK_ROWS = 50000  # rows per chunk when counting tags\nCOLLECT_CHUNK = 50000  # rows per chunk when collecting examples\nTEST_CHUNK = 50000  # chunk size when processing test set\n\n\ndef parse_tags(tagstr):\n    \"\"\"Robust tag parsing: handle <a><b> format or space-separated tags.\"\"\"\n    if pd.isna(tagstr):\n        return []\n    s = str(tagstr).strip()\n    if not s:\n        return []\n    if \"<\" in s and \">\" in s:\n        tags = re.findall(r\"<([^>]+)>\", s)\n        if tags:\n            return [t.strip().lower() for t in tags if t.strip()]\n    parts = [p.strip().lower() for p in s.split() if p.strip()]\n    return parts\n\n\ndef get_top_tags_fast(\n    train_file, top_k=TOP_K_TAGS, sample_chunks=6, chunksize=COUNT_CHUNK_ROWS\n):\n    counter = Counter()\n    read_rows = 0\n    try:\n        reader = pd.read_csv(\n            train_file, usecols=[\"Tags\"], chunksize=chunksize, iterator=True, engine=\"c\"\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n    for i, chunk in enumerate(reader):\n        for t in chunk[\"Tags\"].dropna().astype(str):\n            counter.update(parse_tags(t))\n        read_rows += len(chunk)\n        if i + 1 >= sample_chunks:\n            break\n    top_tags = [t for t, _ in counter.most_common(top_k)]\n    print(\n        f\"[info] Fast-pass counted ~{read_rows} rows, unique tags: {len(counter)}. Selected top {len(top_tags)} tags.\",\n        file=sys.stderr,\n    )\n    return top_tags\n\n\ndef collect_examples_with_top_tags(\n    train_file, top_tags, sample_target=SAMPLE_TARGET, chunksize=COLLECT_CHUNK\n):\n    collected = []\n    collected_ids = set()\n    try:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"c\",\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n    for chunk in reader:\n        for _, row in chunk.iterrows():\n            try:\n                rid = int(row[\"Id\"])\n            except Exception:\n                continue\n            if rid in collected_ids:\n                continue\n            tags = parse_tags(row.get(\"Tags\", \"\"))\n            if any(t in top_tags for t in tags):\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n            if len(collected) >= sample_target:\n                break\n        if len(collected) >= sample_target:\n            break\n\n    if len(collected) < sample_target:\n        print(\n            f\"[info] Only {len(collected)} rows with top tags; doing second pass to fill up to {sample_target}.\",\n            file=sys.stderr,\n        )\n        try:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"c\",\n            )\n        except Exception:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"python\",\n            )\n        for chunk in reader2:\n            for _, row in chunk.iterrows():\n                try:\n                    rid = int(row[\"Id\"])\n                except Exception:\n                    continue\n                if rid in collected_ids:\n                    continue\n                tags = parse_tags(row.get(\"Tags\", \"\"))\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n                if len(collected) >= sample_target:\n                    break\n            if len(collected) >= sample_target:\n                break\n\n    df = pd.DataFrame(collected, columns=[\"Id\", \"Title\", \"Body\", \"ParsedTags\"])\n    print(f\"[info] Total collected training examples: {len(df)}\", file=sys.stderr)\n    return df\n\n\ndef build_dataset_from_collected(df, top_tags):\n    df[\"Title\"] = df[\"Title\"].fillna(\"\").astype(str)\n    df[\"Body\"] = df[\"Body\"].fillna(\"\").astype(str)\n    df[\"text\"] = (\n        (df[\"Title\"] + \" \" + df[\"Body\"]).str.replace(\"\\n\", \" \").str.replace(\"\\r\", \" \")\n    )\n    df[\"TagsFiltered\"] = df[\"ParsedTags\"].apply(\n        lambda tags: [t for t in tags if t in top_tags]\n    )\n    before = len(df)\n    df = df[df[\"TagsFiltered\"].map(len) > 0].reset_index(drop=True)\n    after = len(df)\n    print(\n        f\"[info] Filtered dataset to {after} rows (from {before}) that contain at least one top tag.\",\n        file=sys.stderr,\n    )\n    y_lists = df[\"TagsFiltered\"].tolist()\n    return df, y_lists\n\n\ndef topk_from_scores(scores, k):\n    n_samples = scores.shape[0]\n    if scores.ndim == 1:\n        scores = scores.reshape(-1, 1)\n    n_classes = scores.shape[1]\n    k = min(k, n_classes)\n    if n_classes == 0 or k == 0:\n        return np.zeros((n_samples, n_classes), dtype=int)\n    idx_sorted = np.argsort(scores, axis=1)\n    topk_idx = idx_sorted[:, -k:]\n    preds = np.zeros((n_samples, n_classes), dtype=int)\n    rows = np.arange(n_samples)[:, None]\n    preds[rows, topk_idx] = 1\n    return preds\n\n\ndef safe_cross_val_scores(clf, X, Y, cv):\n    \"\"\"Try decision_function, else predict_proba, else predict. Return float array scores shape (n_samples, n_classes).\"\"\"\n    methods = [\"decision_function\", \"predict_proba\", \"predict\"]\n    for method in methods:\n        try:\n            scores = cross_val_predict(clf, X, Y, cv=cv, method=method, n_jobs=1)\n            scores = np.asarray(scores)\n            if method == \"predict\":\n                scores = scores.astype(float)\n            if scores.ndim == 1:\n                scores = scores.reshape(-1, 1)\n            return scores\n        except Exception as e:\n            print(\n                f\"[warning] cross_val_predict with {method} failed: {e}\",\n                file=sys.stderr,\n            )\n            continue\n    print(\n        \"[warning] All cross_val_predict attempts failed; returning zeros.\",\n        file=sys.stderr,\n    )\n    return np.zeros(Y.shape, dtype=float)\n\n\ndef main():\n    start_time = time.time()\n    print(\"[info] Starting training and prediction...\", file=sys.stderr)\n\n    # 1) Get top tags from a fast pass\n    top_tags = get_top_tags_fast(\n        TRAIN_FILE, top_k=TOP_K_TAGS, sample_chunks=6, chunksize=COUNT_CHUNK_ROWS\n    )\n    if len(top_tags) == 0:\n        print(\"[error] No tags found in training data; exiting.\", file=sys.stderr)\n        return\n\n    # 2) Collect examples that contain top tags (and fill up to SAMPLE_TARGET)\n    sampled_df = collect_examples_with_top_tags(\n        TRAIN_FILE, top_tags, sample_target=SAMPLE_TARGET, chunksize=COLLECT_CHUNK\n    )\n\n    # Recompute top tags based on sampled data to ensure better alignment\n    all_tags = []\n    for tags in sampled_df[\"ParsedTags\"]:\n        all_tags.extend(tags)\n    tag_counts = Counter(all_tags)\n    top_tags_sampled = [t for t, _ in tag_counts.most_common(TOP_K_TAGS)]\n    top_tags = top_tags_sampled[:TOP_K_TAGS]\n    print(f\"[info] Final modeling tag count: {len(top_tags)}\", file=sys.stderr)\n    if len(top_tags) == 0:\n        print(\"[error] No top tags found after sampling; exiting.\", file=sys.stderr)\n        return\n\n    # 3) Build dataset\n    df, y_lists = build_dataset_from_collected(sampled_df, top_tags)\n    if len(df) < 50:\n        print(\"[error] Too few examples after filtering. Exiting.\", file=sys.stderr)\n        return\n\n    texts = df[\"text\"].tolist()\n    ids = df[\"Id\"].tolist()\n\n    # 4) Vectorize\n    print(\"[info] Fitting TF-IDF vectorizer...\", file=sys.stderr)\n    vectorizer = TfidfVectorizer(\n        max_features=TFIDF_MAX_FEATURES, ngram_range=NGRAM_RANGE, stop_words=\"english\"\n    )\n    X = vectorizer.fit_transform(texts)\n    print(f\"[info] TF-IDF shaped: {X.shape}\", file=sys.stderr)\n\n    # 5) Binarize labels with explicit classes order\n    mlb = MultiLabelBinarizer(classes=top_tags)\n    Y = mlb.fit_transform(\n        y_lists\n    )  # classes are set by constructor; ensures mapping order matches top_tags\n    classes = list(mlb.classes_)\n    print(\n        f\"[info] Label matrix shaped: {Y.shape}. Modeling {len(classes)} classes.\",\n        file=sys.stderr,\n    )\n\n    # 6) Build classifier\n    base_clf = LogisticRegression(\n        solver=\"saga\", max_iter=300, C=1.0, random_state=RANDOM_STATE, n_jobs=1\n    )\n    clf = OneVsRestClassifier(base_clf, n_jobs=1)\n\n    # 7) Cross-validated predictions to compute sample-wise F1\n    n_splits = CV_FOLDS\n    if X.shape[0] < 10:\n        n_splits = 2\n    else:\n        n_splits = min(CV_FOLDS, X.shape[0])\n    print(f\"[info] Performing {n_splits}-fold cross-validation...\", file=sys.stderr)\n    kf = KFold(n_splits=n_splits, shuffle=True, random_state=RANDOM_STATE)\n    scores_cv = safe_cross_val_scores(clf, X, Y, cv=kf)\n    if scores_cv.ndim == 1:\n        scores_cv = scores_cv.reshape(-1, 1)\n    y_pred_cv = topk_from_scores(scores_cv, PRED_TOP_K)\n    # Align shapes for evaluation\n    if y_pred_cv.shape != Y.shape:\n        min_cols = min(y_pred_cv.shape[1], Y.shape[1])\n        y_pred_cv = y_pred_cv[:, :min_cols]\n        Y_eval = Y[:, :min_cols]\n    else:\n        Y_eval = Y\n    try:\n        f1 = f1_score(Y_eval, y_pred_cv, average=\"samples\", zero_division=0)\n    except Exception:\n        f1 = 0.0\n    # Print metric to stdout (as required) and also to stderr\n    print(f\"{f1:.6f}\")\n    print(f\"[info] Cross-validated sample-wise F1: {f1:.6f}\", file=sys.stderr)\n\n    # 8) Retrain on full sampled data\n    print(\"[info] Retraining classifier on full sampled data...\", file=sys.stderr)\n    clf.fit(X, Y)\n\n    # 9) Predict on test set in chunks and write submission\n    print(\"[info] Predicting on test set and writing submission...\", file=sys.stderr)\n    sub_rows = []\n    total_test = 0\n    try:\n        test_reader = pd.read_csv(\n            TEST_FILE,\n            usecols=[\"Id\", \"Title\", \"Body\"],\n            chunksize=TEST_CHUNK,\n            iterator=True,\n            engine=\"c\",\n        )\n    except Exception:\n        test_reader = pd.read_csv(\n            TEST_FILE,\n            usecols=[\"Id\", \"Title\", \"Body\"],\n            chunksize=TEST_CHUNK,\n            iterator=True,\n            engine=\"python\",\n        )\n\n    for chunk in test_reader:\n        chunk_ids = chunk[\"Id\"].tolist()\n        titles = chunk[\"Title\"].fillna(\"\").astype(str).tolist()\n        bodies = chunk[\"Body\"].fillna(\"\").astype(str).tolist()\n        texts_chunk = [\n            (t + \" \" + b).replace(\"\\n\", \" \").replace(\"\\r\", \" \")\n            for t, b in zip(titles, bodies)\n        ]\n        Xtest = vectorizer.transform(texts_chunk)\n\n        # get decision scores (try decision_function, then predict_proba, then predict)\n        scores_test = None\n        try:\n            scores_test = clf.decision_function(Xtest)\n        except Exception:\n            try:\n                scores_test = clf.predict_proba(Xtest)\n            except Exception:\n                preds = clf.predict(Xtest)\n                scores_test = preds.astype(float)\n\n        scores_test = np.asarray(scores_test)\n        if scores_test.ndim == 1:\n            scores_test = scores_test.reshape(-1, 1)\n\n        preds_bin = topk_from_scores(scores_test, PRED_TOP_K)\n\n        for i, rid in enumerate(chunk_ids):\n            row_pred = preds_bin[i]\n            if row_pred.sum() == 0:\n                if scores_test.shape[1] > 0:\n                    idx = int(np.argmax(scores_test[i]))\n                    tags = [mlb.classes_[idx]]\n                else:\n                    tags = []\n            else:\n                lbl_idx = np.where(row_pred == 1)[0]\n                tags = [mlb.classes_[j] for j in lbl_idx]\n            tags_str = \" \".join(tags)\n            sub_rows.append((int(rid), tags_str))\n        total_test += len(chunk_ids)\n        print(f\"[info] Processed {total_test} test rows...\", file=sys.stderr)\n\n    # Write submission CSV\n    print(f\"[info] Writing submission to {SUBMISSION_FILE} ...\", file=sys.stderr)\n    with open(SUBMISSION_FILE, \"w\", encoding=\"utf-8\") as f:\n        f.write(\"Id,Tags\\n\")\n        for rid, tags in sub_rows:\n            safe_tags = tags.replace('\"', \"'\")\n            f.write(f'{rid},\"{safe_tags}\"\\n')\n\n    elapsed = time.time() - start_time\n    print(f\"[info] Done. Time elapsed: {elapsed:.1f} sec\", file=sys.stderr)\n\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\nimport os\nimport re\nimport sys\nimport time\nfrom collections import Counter\nimport random\nimport math\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.model_selection import KFold\nfrom sklearn.metrics import f1_score\nfrom sklearn.base import clone\n\n# Configuration\nINPUT_DIR = \"./input\"\nTRAIN_FILE = os.path.join(INPUT_DIR, \"train.csv\")\nTEST_FILE = os.path.join(INPUT_DIR, \"test.csv\")\nSUBMISSION_DIR = \"./submission\"\nSUBMISSION_FILE = os.path.join(SUBMISSION_DIR, \"submission.csv\")\nos.makedirs(SUBMISSION_DIR, exist_ok=True)\n\nRANDOM_STATE = 42\nnp.random.seed(RANDOM_STATE)\nrandom.seed(RANDOM_STATE)\n\n# Sampling / model hyperparameters\nSAMPLE_TARGET = 20000  # try to collect this many training rows\nTOP_K_TAGS = 100  # model these many most frequent tags\nTFIDF_MAX_FEATURES = 10000\nNGRAM_RANGE = (1, 2)\nCV_FOLDS = 5\nPRED_TOP_K = 3\nCOUNT_CHUNK_ROWS = 50000  # rows per chunk when counting tags\nCOLLECT_CHUNK = 50000  # rows per chunk when collecting examples\nTEST_CHUNK = 50000  # chunk size when processing test set\n\n\ndef parse_tags(tagstr):\n    \"\"\"Robust tag parsing: handle <a><b> format or space-separated tags.\"\"\"\n    if pd.isna(tagstr):\n        return []\n    s = str(tagstr).strip()\n    if not s:\n        return []\n    # common StackExchange format: <tag1><tag2>\n    if \"<\" in s and \">\" in s:\n        tags = re.findall(r\"<([^>]+)>\", s)\n        if tags:\n            return [t.strip().lower() for t in tags if t.strip()]\n    # else assume space-separated or comma-separated\n    # also handle tags separated by spaces\n    parts = re.split(r\"[,\\s]+\", s)\n    parts = [p.strip().lower() for p in parts if p.strip()]\n    return parts\n\n\ndef get_top_tags_fast(\n    train_file, top_k=TOP_K_TAGS, sample_chunks=6, chunksize=COUNT_CHUNK_ROWS\n):\n    counter = Counter()\n    read_rows = 0\n    try:\n        reader = pd.read_csv(\n            train_file, usecols=[\"Tags\"], chunksize=chunksize, iterator=True, engine=\"c\"\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n    for i, chunk in enumerate(reader):\n        for t in chunk[\"Tags\"].dropna().astype(str):\n            counter.update(parse_tags(t))\n        read_rows += len(chunk)\n        if i + 1 >= sample_chunks:\n            break\n    top_tags = [t for t, _ in counter.most_common(top_k)]\n    print(\n        f\"[info] Fast-pass counted ~{read_rows} rows, unique tags: {len(counter)}. Selected top {len(top_tags)} tags.\",\n        file=sys.stderr,\n    )\n    return top_tags\n\n\ndef collect_examples_with_top_tags(\n    train_file, top_tags, sample_target=SAMPLE_TARGET, chunksize=COLLECT_CHUNK\n):\n    collected = []\n    collected_ids = set()\n    try:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"c\",\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n    for chunk in reader:\n        for _, row in chunk.iterrows():\n            try:\n                rid = int(row[\"Id\"])\n            except Exception:\n                continue\n            if rid in collected_ids:\n                continue\n            tags = parse_tags(row.get(\"Tags\", \"\"))\n            if any(t in top_tags for t in tags):\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n            if len(collected) >= sample_target:\n                break\n        if len(collected) >= sample_target:\n            break\n\n    # If not enough, do a second pass to add arbitrary examples\n    if len(collected) < sample_target:\n        try:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"c\",\n            )\n        except Exception:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"python\",\n            )\n        for chunk in reader2:\n            for _, row in chunk.iterrows():\n                try:\n                    rid = int(row[\"Id\"])\n                except Exception:\n                    continue\n                if rid in collected_ids:\n                    continue\n                tags = parse_tags(row.get(\"Tags\", \"\"))\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n                if len(collected) >= sample_target:\n                    break\n            if len(collected) >= sample_target:\n                break\n\n    df = pd.DataFrame(collected, columns=[\"Id\", \"Title\", \"Body\", \"ParsedTags\"])\n    print(f\"[info] Total collected training examples: {len(df)}\", file=sys.stderr)\n    return df\n\n\ndef build_dataset_from_collected(df, top_tags):\n    df[\"Title\"] = df[\"Title\"].fillna(\"\").astype(str)\n    df[\"Body\"] = df[\"Body\"].fillna(\"\").astype(str)\n    df[\"text\"] = (\n        (df[\"Title\"] + \" \" + df[\"Body\"]).str.replace(\"\\n\", \" \").str.replace(\"\\r\", \" \")\n    )\n    df[\"TagsFiltered\"] = df[\"ParsedTags\"].apply(\n        lambda tags: [t for t in tags if t in top_tags]\n    )\n    before = len(df)\n    df = df[df[\"TagsFiltered\"].map(len) > 0].reset_index(drop=True)\n    after = len(df)\n    print(\n        f\"[info] Filtered dataset to {after} rows (from {before}) that contain at least one top tag.\",\n        file=sys.stderr,\n    )\n    y_lists = df[\"TagsFiltered\"].tolist()\n    return df, y_lists\n\n\ndef topk_from_scores(scores, k):\n    n_samples = scores.shape[0]\n    if scores.ndim == 1:\n        scores = scores.reshape(-1, 1)\n    n_classes = scores.shape[1]\n    k = min(k, n_classes)\n    if n_classes == 0 or k == 0:\n        return np.zeros((n_samples, n_classes), dtype=int)\n    # argsort ascending, take last k\n    idx_sorted = np.argsort(scores, axis=1)\n    topk_idx = idx_sorted[:, -k:]\n    preds = np.zeros((n_samples, n_classes), dtype=int)\n    rows = np.arange(n_samples)[:, None]\n    preds[rows, topk_idx] = 1\n    return preds\n\n\ndef manual_cv_predict_proba(clf, X, Y, cv):\n    \"\"\"Manually perform CV: clone clf, fit on train folds, predict_proba (or decision function/predict) on val fold.\"\"\"\n    n_samples = X.shape[0]\n    n_classes = Y.shape[1]\n    scores = np.zeros((n_samples, n_classes), dtype=float)\n    for fold_i, (train_idx, val_idx) in enumerate(cv.split(X)):\n        X_train = X[train_idx]\n        X_val = X[val_idx]\n        Y_train = Y[train_idx]\n        clf_clone = clone(clf)\n        try:\n            clf_clone.fit(X_train, Y_train)\n        except Exception as e:\n            print(f\"[warning] Fit failed on fold {fold_i}: {e}\", file=sys.stderr)\n            continue\n        # try predict_proba\n        got = None\n        try:\n            got = clf_clone.predict_proba(X_val)\n        except Exception:\n            try:\n                got = clf_clone.decision_function(X_val)\n            except Exception:\n                try:\n                    p = clf_clone.predict(X_val)\n                    got = p.astype(float)\n                except Exception as e:\n                    print(\n                        f\"[warning] All predict methods failed on fold {fold_i}: {e}\",\n                        file=sys.stderr,\n                    )\n                    got = np.zeros((len(val_idx), n_classes), dtype=float)\n        got = np.asarray(got)\n        if got.ndim == 1:\n            got = got.reshape(-1, 1)\n        # If got has different number of columns (rare), try to align first n_classes\n        if got.shape[1] != n_classes:\n            # if more cols, take first n_classes; if fewer, pad with zeros\n            if got.shape[1] > n_classes:\n                got = got[:, :n_classes]\n            else:\n                pad = np.zeros((got.shape[0], n_classes - got.shape[1]), dtype=float)\n                got = np.concatenate([got, pad], axis=1)\n        scores[val_idx] = got\n        print(\n            f\"[info] Completed CV fold {fold_i+1}/{cv.get_n_splits()} (val size={len(val_idx)})\",\n            file=sys.stderr,\n        )\n    return scores\n\n\ndef main():\n    start_time = time.time()\n    print(\"[info] Starting training and prediction...\", file=sys.stderr)\n\n    # 1) Get top tags\n    top_tags = get_top_tags_fast(\n        TRAIN_FILE, top_k=TOP_K_TAGS, sample_chunks=6, chunksize=COUNT_CHUNK_ROWS\n    )\n    if len(top_tags) == 0:\n        print(\"[error] No tags found in training data; exiting.\", file=sys.stderr)\n        return\n\n    # 2) Collect examples that contain top tags (and fill up to SAMPLE_TARGET)\n    sampled_df = collect_examples_with_top_tags(\n        TRAIN_FILE, top_tags, sample_target=SAMPLE_TARGET, chunksize=COLLECT_CHUNK\n    )\n\n    # 2b) Recompute top tags based on sampled data to ensure alignment\n    all_tags = []\n    for tags in sampled_df[\"ParsedTags\"]:\n        all_tags.extend(tags)\n    tag_counts = Counter(all_tags)\n    top_tags_sampled = [t for t, _ in tag_counts.most_common(TOP_K_TAGS)]\n    if len(top_tags_sampled) > 0:\n        top_tags = top_tags_sampled[:TOP_K_TAGS]\n    print(f\"[info] Final modeling tag count: {len(top_tags)}\", file=sys.stderr)\n    if len(top_tags) == 0:\n        print(\"[error] No top tags found after sampling; exiting.\", file=sys.stderr)\n        return\n\n    # 3) Build dataset\n    df, y_lists = build_dataset_from_collected(sampled_df, top_tags)\n    if len(df) < 50:\n        print(\"[error] Too few examples after filtering. Exiting.\", file=sys.stderr)\n        return\n\n    texts = df[\"text\"].tolist()\n    ids = df[\"Id\"].tolist()\n\n    # 4) Vectorize\n    print(\"[info] Fitting TF-IDF vectorizer...\", file=sys.stderr)\n    vectorizer = TfidfVectorizer(\n        max_features=TFIDF_MAX_FEATURES, ngram_range=NGRAM_RANGE, stop_words=\"english\"\n    )\n    X = vectorizer.fit_transform(texts)\n    print(f\"[info] TF-IDF shaped: {X.shape}\", file=sys.stderr)\n\n    # 5) Binarize labels with explicit classes order\n    mlb = MultiLabelBinarizer(classes=top_tags)\n    Y = mlb.fit_transform(y_lists)\n    classes = list(mlb.classes_)\n    print(\n        f\"[info] Label matrix shaped: {Y.shape}. Modeling {len(classes)} classes.\",\n        file=sys.stderr,\n    )\n\n    # 6) Build classifier\n    base_clf = LogisticRegression(\n        solver=\"saga\", max_iter=200, C=1.0, random_state=RANDOM_STATE, n_jobs=1\n    )\n    clf = OneVsRestClassifier(base_clf, n_jobs=1)\n\n    # 7) Cross-validated predictions (manual loop)\n    n_splits = CV_FOLDS\n    if X.shape[0] < 10:\n        n_splits = 2\n    else:\n        n_splits = min(CV_FOLDS, X.shape[0])\n    print(\n        f\"[info] Performing {n_splits}-fold cross-validation (manual)...\",\n        file=sys.stderr,\n    )\n    kf = KFold(n_splits=n_splits, shuffle=True, random_state=RANDOM_STATE)\n    scores_cv = manual_cv_predict_proba(clf, X, Y, cv=kf)\n    if scores_cv.ndim == 1:\n        scores_cv = scores_cv.reshape(-1, 1)\n    y_pred_cv = topk_from_scores(scores_cv, PRED_TOP_K)\n\n    # Align shapes for evaluation\n    if y_pred_cv.shape != Y.shape:\n        min_cols = min(y_pred_cv.shape[1], Y.shape[1])\n        y_pred_cv = y_pred_cv[:, :min_cols]\n        Y_eval = Y[:, :min_cols]\n    else:\n        Y_eval = Y\n    try:\n        f1 = f1_score(Y_eval, y_pred_cv, average=\"samples\", zero_division=0)\n    except Exception as e:\n        print(f\"[warning] f1_score computation failed: {e}\", file=sys.stderr)\n        f1 = 0.0\n    # Print metric to stdout (as required) and also to stderr\n    print(f\"{f1:.6f}\")\n    print(f\"[info] Cross-validated sample-wise F1: {f1:.6f}\", file=sys.stderr)\n\n    # 8) Retrain on full sampled data\n    print(\"[info] Retraining classifier on full sampled data...\", file=sys.stderr)\n    try:\n        clf.fit(X, Y)\n    except Exception as e:\n        print(\n            f\"[warning] Full fit failed: {e}. Attempting to fit per-class logistic regression.\",\n            file=sys.stderr,\n        )\n        # fallback: fit one-vs-rest manually\n        for i in range(Y.shape[1]):\n            try:\n                clf.estimators_[i].fit(X, Y[:, i])\n            except Exception:\n                pass\n\n    # 9) Predict on test set in chunks and write submission\n    print(\"[info] Predicting on test set and writing submission...\", file=sys.stderr)\n    sub_rows = []\n    total_test = 0\n    try:\n        test_reader = pd.read_csv(\n            TEST_FILE,\n            usecols=[\"Id\", \"Title\", \"Body\"],\n            chunksize=TEST_CHUNK,\n            iterator=True,\n            engine=\"c\",\n        )\n    except Exception:\n        test_reader = pd.read_csv(\n            TEST_FILE,\n            usecols=[\"Id\", \"Title\", \"Body\"],\n            chunksize=TEST_CHUNK,\n            iterator=True,\n            engine=\"python\",\n        )\n\n    for chunk in test_reader:\n        chunk_ids = chunk[\"Id\"].tolist()\n        titles = chunk[\"Title\"].fillna(\"\").astype(str).tolist()\n        bodies = chunk[\"Body\"].fillna(\"\").astype(str).tolist()\n        texts_chunk = [\n            (t + \" \" + b).replace(\"\\n\", \" \").replace(\"\\r\", \" \")\n            for t, b in zip(titles, bodies)\n        ]\n        Xtest = vectorizer.transform(texts_chunk)\n\n        # get decision scores (try decision_function, then predict_proba, then predict)\n        scores_test = None\n        try:\n            scores_test = clf.decision_function(Xtest)\n        except Exception:\n            try:\n                scores_test = clf.predict_proba(Xtest)\n            except Exception:\n                preds = clf.predict(Xtest)\n                scores_test = preds.astype(float)\n\n        scores_test = np.asarray(scores_test)\n        if scores_test.ndim == 1:\n            scores_test = scores_test.reshape(-1, 1)\n\n        preds_bin = topk_from_scores(scores_test, PRED_TOP_K)\n\n        for i, rid in enumerate(chunk_ids):\n            row_pred = preds_bin[i]\n            if row_pred.sum() == 0:\n                if scores_test.shape[1] > 0:\n                    idx = int(np.argmax(scores_test[i]))\n                    tags = [mlb.classes_[idx]]\n                else:\n                    tags = []\n            else:\n                lbl_idx = np.where(row_pred == 1)[0]\n                tags = [mlb.classes_[j] for j in lbl_idx]\n            tags_str = \" \".join(tags)\n            sub_rows.append((int(rid), tags_str))\n        total_test += len(chunk_ids)\n        print(f\"[info] Processed {total_test} test rows...\", file=sys.stderr)\n\n    # Write submission CSV\n    print(f\"[info] Writing submission to {SUBMISSION_FILE} ...\", file=sys.stderr)\n    with open(SUBMISSION_FILE, \"w\", encoding=\"utf-8\") as f:\n        f.write(\"Id,Tags\\n\")\n        for rid, tags in sub_rows:\n            safe_tags = tags.replace('\"', \"'\")\n            f.write(f'{rid},\"{safe_tags}\"\\n')\n\n    elapsed = time.time() - start_time\n    print(f\"[info] Done. Time elapsed: {elapsed:.1f} sec\", file=sys.stderr)\n\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\nimport os\nimport re\nimport sys\nimport time\nfrom collections import Counter\nimport random\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.model_selection import KFold\nfrom sklearn.metrics import f1_score\nfrom sklearn.base import clone\n\n# Configuration\nINPUT_DIR = \"./input\"\nTRAIN_FILE = os.path.join(INPUT_DIR, \"train.csv\")\nTEST_FILE = os.path.join(INPUT_DIR, \"test.csv\")\nSUBMISSION_DIR = \"./submission\"\nSUBMISSION_FILE = os.path.join(SUBMISSION_DIR, \"submission.csv\")\nos.makedirs(SUBMISSION_DIR, exist_ok=True)\n\nRANDOM_STATE = 42\nnp.random.seed(RANDOM_STATE)\nrandom.seed(RANDOM_STATE)\n\n# Sampling / model hyperparameters\nSAMPLE_TARGET = 20000  # number of training rows to collect\nTOP_K_TAGS = 100  # model these many most frequent tags\nTFIDF_MAX_FEATURES = 10000\nNGRAM_RANGE = (1, 2)\nCV_FOLDS = 5\nPRED_TOP_K = 3\nCOUNT_CHUNK_ROWS = 50000  # rows per chunk when counting tags\nCOLLECT_CHUNK = 50000  # rows per chunk when collecting examples\nTEST_CHUNK = 50000  # chunk size when processing test set\n\n\ndef parse_tags(tagstr):\n    \"\"\"Robust tag parsing: handle <a><b> format or space-separated tags.\"\"\"\n    if pd.isna(tagstr):\n        return []\n    s = str(tagstr).strip()\n    if not s:\n        return []\n    # common StackExchange format: <tag1><tag2>\n    if \"<\" in s and \">\" in s:\n        tags = re.findall(r\"<([^>]+)>\", s)\n        if tags:\n            return [t.strip().lower() for t in tags if t.strip()]\n    # else assume space-separated or comma-separated\n    parts = re.split(r\"[,\\s]+\", s)\n    parts = [p.strip().lower() for p in parts if p.strip()]\n    return parts\n\n\ndef get_top_tags_fast(\n    train_file, top_k=TOP_K_TAGS, sample_chunks=6, chunksize=COUNT_CHUNK_ROWS\n):\n    counter = Counter()\n    read_rows = 0\n    try:\n        reader = pd.read_csv(\n            train_file, usecols=[\"Tags\"], chunksize=chunksize, iterator=True, engine=\"c\"\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n    for i, chunk in enumerate(reader):\n        for t in chunk[\"Tags\"].dropna().astype(str):\n            counter.update(parse_tags(t))\n        read_rows += len(chunk)\n        if i + 1 >= sample_chunks:\n            break\n    top_tags = [t for t, _ in counter.most_common(top_k)]\n    print(\n        f\"[info] Fast-pass counted ~{read_rows} rows, unique tags: {len(counter)}. Selected top {len(top_tags)} tags.\",\n        file=sys.stderr,\n    )\n    return top_tags\n\n\ndef collect_examples_with_top_tags(\n    train_file, top_tags, sample_target=SAMPLE_TARGET, chunksize=COLLECT_CHUNK\n):\n    collected = []\n    collected_ids = set()\n    try:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"c\",\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n    for chunk in reader:\n        for _, row in chunk.iterrows():\n            try:\n                rid = int(row[\"Id\"])\n            except Exception:\n                continue\n            if rid in collected_ids:\n                continue\n            tags = parse_tags(row.get(\"Tags\", \"\"))\n            if any(t in top_tags for t in tags):\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n            if len(collected) >= sample_target:\n                break\n        if len(collected) >= sample_target:\n            break\n\n    # If not enough, do a second pass to add arbitrary examples\n    if len(collected) < sample_target:\n        try:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"c\",\n            )\n        except Exception:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"python\",\n            )\n        for chunk in reader2:\n            for _, row in chunk.iterrows():\n                try:\n                    rid = int(row[\"Id\"])\n                except Exception:\n                    continue\n                if rid in collected_ids:\n                    continue\n                tags = parse_tags(row.get(\"Tags\", \"\"))\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n                if len(collected) >= sample_target:\n                    break\n            if len(collected) >= sample_target:\n                break\n\n    df = pd.DataFrame(collected, columns=[\"Id\", \"Title\", \"Body\", \"ParsedTags\"])\n    print(f\"[info] Total collected training examples: {len(df)}\", file=sys.stderr)\n    return df\n\n\ndef build_dataset_from_collected(df, top_tags):\n    df[\"Title\"] = df[\"Title\"].fillna(\"\").astype(str)\n    df[\"Body\"] = df[\"Body\"].fillna(\"\").astype(str)\n    # combine title and body, remove newlines\n    df[\"text\"] = (\n        (df[\"Title\"] + \" \" + df[\"Body\"]).str.replace(\"\\n\", \" \").str.replace(\"\\r\", \" \")\n    )\n    df[\"TagsFiltered\"] = df[\"ParsedTags\"].apply(\n        lambda tags: [t for t in tags if t in top_tags]\n    )\n    before = len(df)\n    df = df[df[\"TagsFiltered\"].map(len) > 0].reset_index(drop=True)\n    after = len(df)\n    print(\n        f\"[info] Filtered dataset to {after} rows (from {before}) that contain at least one top tag.\",\n        file=sys.stderr,\n    )\n    y_lists = df[\"TagsFiltered\"].tolist()\n    return df, y_lists\n\n\ndef topk_from_scores(scores, k):\n    n_samples = scores.shape[0]\n    if scores.ndim == 1:\n        scores = scores.reshape(-1, 1)\n    n_classes = scores.shape[1]\n    k = min(k, n_classes)\n    if n_classes == 0 or k == 0:\n        return np.zeros((n_samples, n_classes), dtype=int)\n    # argsort ascending, take last k\n    idx_sorted = np.argsort(scores, axis=1)\n    topk_idx = idx_sorted[:, -k:]\n    preds = np.zeros((n_samples, n_classes), dtype=int)\n    rows = np.arange(n_samples)[:, None]\n    preds[rows, topk_idx] = 1\n    return preds\n\n\ndef manual_cv_predict_proba(clf, X, Y, cv):\n    \"\"\"Manually perform CV: clone clf, fit on train folds, predict scores on val fold.\"\"\"\n    n_samples = X.shape[0]\n    n_classes = Y.shape[1]\n    scores = np.zeros((n_samples, n_classes), dtype=float)\n    for fold_i, (train_idx, val_idx) in enumerate(cv.split(X)):\n        X_train = X[train_idx]\n        X_val = X[val_idx]\n        Y_train = Y[train_idx]\n        clf_clone = clone(clf)\n        try:\n            clf_clone.fit(X_train, Y_train)\n        except Exception as e:\n            print(f\"[warning] Fit failed on fold {fold_i}: {e}\", file=sys.stderr)\n            continue\n        got = None\n        # try decision_function (works for many linear models)\n        try:\n            got = clf_clone.decision_function(X_val)\n        except Exception:\n            try:\n                got = clf_clone.predict_proba(X_val)\n            except Exception:\n                # fallback: predict (binary 0/1) -> cast to float (not ideal but safe)\n                try:\n                    p = clf_clone.predict(X_val)\n                    got = p.astype(float)\n                except Exception as e:\n                    print(\n                        f\"[warning] All predict methods failed on fold {fold_i}: {e}\",\n                        file=sys.stderr,\n                    )\n                    got = np.zeros((len(val_idx), n_classes), dtype=float)\n        got = np.asarray(got)\n        # Normalize shape\n        if got.ndim == 1:\n            got = got.reshape(-1, 1)\n        if got.shape[1] != n_classes:\n            # Align: if fewer cols, try to pad; if more, truncate\n            if got.shape[1] > n_classes:\n                got = got[:, :n_classes]\n            else:\n                pad = np.zeros((got.shape[0], n_classes - got.shape[1]), dtype=float)\n                got = np.concatenate([got, pad], axis=1)\n        scores[val_idx] = got\n        print(\n            f\"[info] Completed CV fold {fold_i+1}/{cv.get_n_splits()} (val size={len(val_idx)})\",\n            file=sys.stderr,\n        )\n    return scores\n\n\ndef main():\n    start_time = time.time()\n    print(\"[info] Starting training and prediction...\", file=sys.stderr)\n\n    # 1) Get top tags\n    top_tags = get_top_tags_fast(\n        TRAIN_FILE, top_k=TOP_K_TAGS, sample_chunks=6, chunksize=COUNT_CHUNK_ROWS\n    )\n    if len(top_tags) == 0:\n        print(\"[error] No tags found in training data; exiting.\", file=sys.stderr)\n        return\n\n    # 2) Collect examples that contain top tags (and fill up to SAMPLE_TARGET)\n    sampled_df = collect_examples_with_top_tags(\n        TRAIN_FILE, top_tags, sample_target=SAMPLE_TARGET, chunksize=COLLECT_CHUNK\n    )\n\n    # 2b) Recompute top tags based on sampled data to ensure alignment\n    all_tags = []\n    for tags in sampled_df[\"ParsedTags\"]:\n        all_tags.extend(tags)\n    tag_counts = Counter(all_tags)\n    top_tags_sampled = [t for t, _ in tag_counts.most_common(TOP_K_TAGS)]\n    if len(top_tags_sampled) > 0:\n        top_tags = top_tags_sampled[:TOP_K_TAGS]\n    print(f\"[info] Final modeling tag count: {len(top_tags)}\", file=sys.stderr)\n    if len(top_tags) == 0:\n        print(\"[error] No top tags found after sampling; exiting.\", file=sys.stderr)\n        return\n\n    # 3) Build dataset\n    df, y_lists = build_dataset_from_collected(sampled_df, top_tags)\n    if len(df) < 50:\n        print(\"[error] Too few examples after filtering. Exiting.\", file=sys.stderr)\n        return\n\n    texts = df[\"text\"].tolist()\n    ids = df[\"Id\"].tolist()\n\n    # 4) Vectorize\n    print(\"[info] Fitting TF-IDF vectorizer...\", file=sys.stderr)\n    vectorizer = TfidfVectorizer(\n        max_features=TFIDF_MAX_FEATURES, ngram_range=NGRAM_RANGE, stop_words=\"english\"\n    )\n    X = vectorizer.fit_transform(texts)\n    print(f\"[info] TF-IDF shaped: {X.shape}\", file=sys.stderr)\n\n    # 5) Binarize labels with explicit classes order\n    mlb = MultiLabelBinarizer(classes=top_tags)\n    Y = mlb.fit_transform(y_lists)\n    classes = list(mlb.classes_)\n    print(\n        f\"[info] Label matrix shaped: {Y.shape}. Modeling {len(classes)} classes.\",\n        file=sys.stderr,\n    )\n\n    # 6) Build classifier\n    base_clf = LogisticRegression(\n        solver=\"saga\", max_iter=200, C=1.0, random_state=RANDOM_STATE\n    )\n    clf = OneVsRestClassifier(base_clf, n_jobs=1)\n\n    # 7) Cross-validated predictions (manual loop)\n    n_splits = CV_FOLDS\n    if X.shape[0] < 10:\n        n_splits = 2\n    else:\n        n_splits = min(CV_FOLDS, X.shape[0])\n    print(\n        f\"[info] Performing {n_splits}-fold cross-validation (manual)...\",\n        file=sys.stderr,\n    )\n    kf = KFold(n_splits=n_splits, shuffle=True, random_state=RANDOM_STATE)\n    scores_cv = manual_cv_predict_proba(clf, X, Y, cv=kf)\n    if scores_cv.ndim == 1:\n        scores_cv = scores_cv.reshape(-1, 1)\n    y_pred_cv = topk_from_scores(scores_cv, PRED_TOP_K)\n\n    # Align shapes for evaluation\n    if y_pred_cv.shape != Y.shape:\n        min_cols = min(y_pred_cv.shape[1], Y.shape[1])\n        y_pred_cv = y_pred_cv[:, :min_cols]\n        Y_eval = Y[:, :min_cols]\n    else:\n        Y_eval = Y\n    try:\n        f1 = f1_score(Y_eval, y_pred_cv, average=\"samples\", zero_division=0)\n    except Exception as e:\n        print(f\"[warning] f1_score computation failed: {e}\", file=sys.stderr)\n        f1 = 0.0\n    # Print metric to stdout (as required) and also to stderr\n    print(f\"{f1:.6f}\")\n    print(f\"[info] Cross-validated sample-wise F1: {f1:.6f}\", file=sys.stderr)\n\n    # 8) Retrain on full sampled data\n    print(\"[info] Retraining classifier on full sampled data...\", file=sys.stderr)\n    try:\n        clf.fit(X, Y)\n    except Exception as e:\n        print(\n            f\"[warning] Full fit failed: {e}. Attempting per-class fallback.\",\n            file=sys.stderr,\n        )\n        # fallback: try to fit estimators individually\n        try:\n            for i in range(Y.shape[1]):\n                try:\n                    if hasattr(clf, \"estimators_\") and clf.estimators_[i] is not None:\n                        clf.estimators_[i].fit(X, Y[:, i])\n                except Exception:\n                    pass\n        except Exception:\n            pass\n\n    # 9) Predict on test set in chunks and write submission\n    print(\"[info] Predicting on test set and writing submission...\", file=sys.stderr)\n    sub_rows = []\n    total_test = 0\n    try:\n        test_reader = pd.read_csv(\n            TEST_FILE,\n            usecols=[\"Id\", \"Title\", \"Body\"],\n            chunksize=TEST_CHUNK,\n            iterator=True,\n            engine=\"c\",\n        )\n    except Exception:\n        test_reader = pd.read_csv(\n            TEST_FILE,\n            usecols=[\"Id\", \"Title\", \"Body\"],\n            chunksize=TEST_CHUNK,\n            iterator=True,\n            engine=\"python\",\n        )\n\n    for chunk in test_reader:\n        chunk_ids = chunk[\"Id\"].tolist()\n        titles = chunk[\"Title\"].fillna(\"\").astype(str).tolist()\n        bodies = chunk[\"Body\"].fillna(\"\").astype(str).tolist()\n        texts_chunk = [\n            (t + \" \" + b).replace(\"\\n\", \" \").replace(\"\\r\", \" \")\n            for t, b in zip(titles, bodies)\n        ]\n        Xtest = vectorizer.transform(texts_chunk)\n\n        # get decision scores (try decision_function, then predict_proba, then predict)\n        scores_test = None\n        try:\n            scores_test = clf.decision_function(Xtest)\n        except Exception:\n            try:\n                scores_test = clf.predict_proba(Xtest)\n            except Exception:\n                preds = clf.predict(Xtest)\n                scores_test = preds.astype(float)\n\n        scores_test = np.asarray(scores_test)\n        if scores_test.ndim == 1:\n            scores_test = scores_test.reshape(-1, 1)\n\n        preds_bin = topk_from_scores(scores_test, PRED_TOP_K)\n\n        for i, rid in enumerate(chunk_ids):\n            row_pred = preds_bin[i]\n            if row_pred.sum() == 0:\n                if scores_test.shape[1] > 0:\n                    idx = int(np.argmax(scores_test[i]))\n                    tags = [mlb.classes_[idx]]\n                else:\n                    tags = []\n            else:\n                lbl_idx = np.where(row_pred == 1)[0]\n                tags = [mlb.classes_[j] for j in lbl_idx]\n            tags_str = \" \".join(tags)\n            sub_rows.append((int(rid), tags_str))\n        total_test += len(chunk_ids)\n        print(f\"[info] Processed {total_test} test rows...\", file=sys.stderr)\n\n    # Write submission CSV\n    print(f\"[info] Writing submission to {SUBMISSION_FILE} ...\", file=sys.stderr)\n    with open(SUBMISSION_FILE, \"w\", encoding=\"utf-8\") as f:\n        f.write(\"Id,Tags\\n\")\n        for rid, tags in sub_rows:\n            safe_tags = tags.replace('\"', \"'\")\n            f.write(f'{rid},\"{safe_tags}\"\\n')\n\n    elapsed = time.time() - start_time\n    print(f\"[info] Done. Time elapsed: {elapsed:.1f} sec\", file=sys.stderr)\n\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\nimport os\nimport re\nimport sys\nimport time\nfrom collections import Counter\nimport random\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.model_selection import KFold\nfrom sklearn.metrics import f1_score\nfrom sklearn.base import clone\n\n# Configuration\nINPUT_DIR = \"./input\"\nTRAIN_FILE = os.path.join(INPUT_DIR, \"train.csv\")\nTEST_FILE = os.path.join(INPUT_DIR, \"test.csv\")\nSUBMISSION_DIR = \"./submission\"\nSUBMISSION_FILE = os.path.join(SUBMISSION_DIR, \"submission.csv\")\nos.makedirs(SUBMISSION_DIR, exist_ok=True)\n\nRANDOM_STATE = 42\nnp.random.seed(RANDOM_STATE)\nrandom.seed(RANDOM_STATE)\n\n# Sampling / model hyperparameters\nSAMPLE_TARGET = 15000  # number of training rows to collect (reduced for speed)\nTOP_K_TAGS = 100  # model these many most frequent tags\nTFIDF_MAX_FEATURES = 10000\nNGRAM_RANGE = (1, 2)\nCV_FOLDS = 5\nPRED_TOP_K = 3\nCOUNT_CHUNK_ROWS = 50000  # rows per chunk when counting tags\nCOLLECT_CHUNK = 50000  # rows per chunk when collecting examples\nTEST_CHUNK = 50000  # chunk size when processing test set\n\n\ndef parse_tags(tagstr):\n    \"\"\"Robust tag parsing: handle <a><b> format or space-separated tags.\"\"\"\n    if pd.isna(tagstr):\n        return []\n    s = str(tagstr).strip()\n    if not s:\n        return []\n    # common StackExchange format: <tag1><tag2>\n    if \"<\" in s and \">\" in s:\n        tags = re.findall(r\"<([^>]+)>\", s)\n        if tags:\n            return [t.strip().lower() for t in tags if t.strip()]\n    # else assume space-separated or comma-separated\n    parts = re.split(r\"[,\\s]+\", s)\n    parts = [p.strip().lower() for p in parts if p.strip()]\n    return parts\n\n\ndef get_top_tags_fast(\n    train_file, top_k=TOP_K_TAGS, sample_chunks=6, chunksize=COUNT_CHUNK_ROWS\n):\n    counter = Counter()\n    read_rows = 0\n    try:\n        reader = pd.read_csv(\n            train_file, usecols=[\"Tags\"], chunksize=chunksize, iterator=True, engine=\"c\"\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n    for i, chunk in enumerate(reader):\n        for t in chunk[\"Tags\"].dropna().astype(str):\n            counter.update(parse_tags(t))\n        read_rows += len(chunk)\n        if i + 1 >= sample_chunks:\n            break\n    if len(counter) == 0:\n        # Fallback: attempt reading a small number of rows without chunking\n        try:\n            tmp = pd.read_csv(train_file, usecols=[\"Tags\"], nrows=1000)\n            for t in tmp[\"Tags\"].dropna().astype(str):\n                counter.update(parse_tags(t))\n        except Exception:\n            pass\n    top_tags = [t for t, _ in counter.most_common(top_k)]\n    print(\n        f\"[info] Fast-pass counted ~{read_rows} rows, unique tags: {len(counter)}. Selected top {len(top_tags)} tags.\",\n        file=sys.stderr,\n    )\n    return top_tags\n\n\ndef collect_examples_with_top_tags(\n    train_file, top_tags, sample_target=SAMPLE_TARGET, chunksize=COLLECT_CHUNK\n):\n    collected = []\n    collected_ids = set()\n    # First pass: collect rows that contain any top tag\n    try:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"c\",\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n    for chunk in reader:\n        for _, row in chunk.iterrows():\n            try:\n                rid = int(row[\"Id\"])\n            except Exception:\n                continue\n            if rid in collected_ids:\n                continue\n            tags = parse_tags(row.get(\"Tags\", \"\"))\n            if any(t in top_tags for t in tags):\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n            if len(collected) >= sample_target:\n                break\n        if len(collected) >= sample_target:\n            break\n\n    # If still not enough, do a second pass to add arbitrary examples (fallback)\n    if len(collected) < sample_target:\n        try:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"c\",\n            )\n        except Exception:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=[\"Id\", \"Title\", \"Body\", \"Tags\"],\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"python\",\n            )\n        for chunk in reader2:\n            for _, row in chunk.iterrows():\n                try:\n                    rid = int(row[\"Id\"])\n                except Exception:\n                    continue\n                if rid in collected_ids:\n                    continue\n                tags = parse_tags(row.get(\"Tags\", \"\"))\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n                if len(collected) >= sample_target:\n                    break\n            if len(collected) >= sample_target:\n                break\n\n    df = pd.DataFrame(collected, columns=[\"Id\", \"Title\", \"Body\", \"ParsedTags\"])\n    print(f\"[info] Total collected training examples: {len(df)}\", file=sys.stderr)\n    return df\n\n\ndef build_dataset_from_collected(df, top_tags):\n    df[\"Title\"] = df[\"Title\"].fillna(\"\").astype(str)\n    df[\"Body\"] = df[\"Body\"].fillna(\"\").astype(str)\n    # combine title and body, remove newlines\n    df[\"text\"] = (\n        (df[\"Title\"] + \" \" + df[\"Body\"]).str.replace(\"\\n\", \" \").str.replace(\"\\r\", \" \")\n    )\n    df[\"TagsFiltered\"] = df[\"ParsedTags\"].apply(\n        lambda tags: [t for t in tags if t in top_tags]\n    )\n    before = len(df)\n    df = df[df[\"TagsFiltered\"].map(len) > 0].reset_index(drop=True)\n    after = len(df)\n    print(\n        f\"[info] Filtered dataset to {after} rows (from {before}) that contain at least one top tag.\",\n        file=sys.stderr,\n    )\n    y_lists = df[\"TagsFiltered\"].tolist()\n    return df, y_lists\n\n\ndef topk_from_scores(scores, k):\n    n_samples = scores.shape[0]\n    if scores.ndim == 1:\n        scores = scores.reshape(-1, 1)\n    n_classes = scores.shape[1]\n    k = min(k, n_classes)\n    if n_classes == 0 or k == 0:\n        return np.zeros((n_samples, n_classes), dtype=int)\n    idx_sorted = np.argsort(scores, axis=1)\n    topk_idx = idx_sorted[:, -k:]\n    preds = np.zeros((n_samples, n_classes), dtype=int)\n    rows = np.arange(n_samples)[:, None]\n    preds[rows, topk_idx] = 1\n    return preds\n\n\ndef manual_cv_predict_proba(clf, X, Y, cv):\n    \"\"\"Manually perform CV: clone clf, fit on train folds, predict scores on val fold.\"\"\"\n    n_samples = X.shape[0]\n    n_classes = Y.shape[1]\n    scores = np.zeros((n_samples, n_classes), dtype=float)\n    for fold_i, (train_idx, val_idx) in enumerate(cv.split(X)):\n        X_train = X[train_idx]\n        X_val = X[val_idx]\n        Y_train = Y[train_idx]\n        clf_clone = clone(clf)\n        try:\n            clf_clone.fit(X_train, Y_train)\n        except Exception as e:\n            print(f\"[warning] Fit failed on fold {fold_i}: {e}\", file=sys.stderr)\n            continue\n        got = None\n        # try decision_function (works for many linear models)\n        try:\n            got = clf_clone.decision_function(X_val)\n        except Exception:\n            try:\n                got = clf_clone.predict_proba(X_val)\n            except Exception:\n                # fallback: predict (binary 0/1) -> cast to float (not ideal but safe)\n                try:\n                    p = clf_clone.predict(X_val)\n                    got = p.astype(float)\n                except Exception as e:\n                    print(\n                        f\"[warning] All predict methods failed on fold {fold_i}: {e}\",\n                        file=sys.stderr,\n                    )\n                    got = np.zeros((len(val_idx), n_classes), dtype=float)\n        got = np.asarray(got)\n        # Normalize shape\n        if got.ndim == 1:\n            got = got.reshape(-1, 1)\n        if got.shape[1] != n_classes:\n            # Align: if fewer cols, try to pad; if more, truncate\n            if got.shape[1] > n_classes:\n                got = got[:, :n_classes]\n            else:\n                pad = np.zeros((got.shape[0], n_classes - got.shape[1]), dtype=float)\n                got = np.concatenate([got, pad], axis=1)\n        scores[val_idx] = got\n        print(\n            f\"[info] Completed CV fold {fold_i+1}/{cv.get_n_splits()} (val size={len(val_idx)})\",\n            file=sys.stderr,\n        )\n    return scores\n\n\ndef main():\n    start_time = time.time()\n    print(\"[info] Starting training and prediction...\", file=sys.stderr)\n\n    # 1) Get top tags (fast pass)\n    top_tags = get_top_tags_fast(\n        TRAIN_FILE, top_k=TOP_K_TAGS, sample_chunks=6, chunksize=COUNT_CHUNK_ROWS\n    )\n    # If no top tags found, attempt a more thorough count on fewer rows\n    if len(top_tags) == 0:\n        print(\n            \"[warning] No top tags found in fast pass, attempting slower pass...\",\n            file=sys.stderr,\n        )\n        try:\n            tmp = pd.read_csv(TRAIN_FILE, usecols=[\"Tags\"], nrows=200000)\n            counter = Counter()\n            for t in tmp[\"Tags\"].dropna().astype(str):\n                counter.update(parse_tags(t))\n            top_tags = [t for t, _ in counter.most_common(TOP_K_TAGS)]\n        except Exception:\n            top_tags = []\n    if len(top_tags) == 0:\n        print(\"[error] No tags found in training data; will exit.\", file=sys.stderr)\n        return\n\n    # 2) Collect examples that contain top tags (and fill up to SAMPLE_TARGET)\n    sampled_df = collect_examples_with_top_tags(\n        TRAIN_FILE, top_tags, sample_target=SAMPLE_TARGET, chunksize=COLLECT_CHUNK\n    )\n\n    # 2b) Recompute top tags based on sampled data to ensure alignment (fallback)\n    all_tags = []\n    for tags in sampled_df[\"ParsedTags\"]:\n        all_tags.extend(tags)\n    tag_counts = Counter(all_tags)\n    top_tags_sampled = [t for t, _ in tag_counts.most_common(TOP_K_TAGS)]\n    if len(top_tags_sampled) > 0:\n        top_tags = top_tags_sampled[:TOP_K_TAGS]\n    print(f\"[info] Final modeling tag count: {len(top_tags)}\", file=sys.stderr)\n    if len(top_tags) == 0:\n        print(\"[error] No top tags found after sampling; exiting.\", file=sys.stderr)\n        return\n\n    # 3) Build dataset\n    df, y_lists = build_dataset_from_collected(sampled_df, top_tags)\n    if len(df) < 50:\n        print(\"[error] Too few examples after filtering. Exiting.\", file=sys.stderr)\n        return\n\n    texts = df[\"text\"].tolist()\n    ids = df[\"Id\"].tolist()\n\n    # 4) Vectorize\n    print(\"[info] Fitting TF-IDF vectorizer...\", file=sys.stderr)\n    vectorizer = TfidfVectorizer(\n        max_features=TFIDF_MAX_FEATURES, ngram_range=NGRAM_RANGE, stop_words=\"english\"\n    )\n    X = vectorizer.fit_transform(texts)\n    print(f\"[info] TF-IDF shaped: {X.shape}\", file=sys.stderr)\n\n    # 5) Binarize labels with explicit classes order\n    mlb = MultiLabelBinarizer(classes=top_tags)\n    Y = mlb.fit_transform(y_lists)\n    classes = list(mlb.classes_)\n    print(\n        f\"[info] Label matrix shaped: {Y.shape}. Modeling {len(classes)} classes.\",\n        file=sys.stderr,\n    )\n\n    # 6) Build classifier\n    base_clf = LogisticRegression(\n        solver=\"saga\", max_iter=200, C=1.0, random_state=RANDOM_STATE\n    )\n    clf = OneVsRestClassifier(base_clf, n_jobs=1)\n\n    # 7) Cross-validated predictions (manual loop)\n    n_splits = CV_FOLDS\n    if X.shape[0] < 10:\n        n_splits = 2\n    else:\n        n_splits = min(CV_FOLDS, X.shape[0])\n    print(\n        f\"[info] Performing {n_splits}-fold cross-validation (manual)...\",\n        file=sys.stderr,\n    )\n    kf = KFold(n_splits=n_splits, shuffle=True, random_state=RANDOM_STATE)\n    scores_cv = manual_cv_predict_proba(clf, X, Y, cv=kf)\n    if scores_cv.ndim == 1:\n        scores_cv = scores_cv.reshape(-1, 1)\n    y_pred_cv = topk_from_scores(scores_cv, PRED_TOP_K)\n\n    # Align shapes for evaluation\n    if y_pred_cv.shape != Y.shape:\n        min_cols = min(y_pred_cv.shape[1], Y.shape[1])\n        y_pred_cv = y_pred_cv[:, :min_cols]\n        Y_eval = Y[:, :min_cols]\n    else:\n        Y_eval = Y\n    try:\n        f1 = f1_score(Y_eval, y_pred_cv, average=\"samples\", zero_division=0)\n    except Exception as e:\n        print(f\"[warning] f1_score computation failed: {e}\", file=sys.stderr)\n        f1 = 0.0\n    # Print metric to stdout (as required) and also to stderr\n    print(f\"{f1:.6f}\")\n    print(f\"[info] Cross-validated sample-wise F1: {f1:.6f}\", file=sys.stderr)\n\n    # 8) Retrain on full sampled data\n    print(\"[info] Retraining classifier on full sampled data...\", file=sys.stderr)\n    try:\n        clf.fit(X, Y)\n    except Exception as e:\n        print(\n            f\"[warning] Full fit failed: {e}. Attempting fallback per-class fit.\",\n            file=sys.stderr,\n        )\n        # fallback: try to fit estimators individually where possible\n        try:\n            for i in range(Y.shape[1]):\n                try:\n                    if hasattr(clf, \"estimators_\") and clf.estimators_[i] is not None:\n                        clf.estimators_[i].fit(X, Y[:, i])\n                except Exception:\n                    pass\n        except Exception:\n            pass\n\n    # 9) Predict on test set in chunks and write submission\n    print(\"[info] Predicting on test set and writing submission...\", file=sys.stderr)\n    sub_rows = []\n    total_test = 0\n    try:\n        test_reader = pd.read_csv(\n            TEST_FILE,\n            usecols=[\"Id\", \"Title\", \"Body\"],\n            chunksize=TEST_CHUNK,\n            iterator=True,\n            engine=\"c\",\n        )\n    except Exception:\n        test_reader = pd.read_csv(\n            TEST_FILE,\n            usecols=[\"Id\", \"Title\", \"Body\"],\n            chunksize=TEST_CHUNK,\n            iterator=True,\n            engine=\"python\",\n        )\n\n    for chunk in test_reader:\n        chunk_ids = chunk[\"Id\"].tolist()\n        titles = chunk[\"Title\"].fillna(\"\").astype(str).tolist()\n        bodies = chunk[\"Body\"].fillna(\"\").astype(str).tolist()\n        texts_chunk = [\n            (t + \" \" + b).replace(\"\\n\", \" \").replace(\"\\r\", \" \")\n            for t, b in zip(titles, bodies)\n        ]\n        Xtest = vectorizer.transform(texts_chunk)\n\n        # get decision scores (try decision_function, then predict_proba, then predict)\n        scores_test = None\n        try:\n            scores_test = clf.decision_function(Xtest)\n        except Exception:\n            try:\n                scores_test = clf.predict_proba(Xtest)\n            except Exception:\n                preds = clf.predict(Xtest)\n                scores_test = preds.astype(float)\n\n        scores_test = np.asarray(scores_test)\n        if scores_test.ndim == 1:\n            scores_test = scores_test.reshape(-1, 1)\n\n        # If the classifier returned per-class binary probs in shape (n_samples, n_classes) good.\n        # Otherwise, if number of columns mismatch, try to align/pad/truncate\n        n_classes_model = len(classes)\n        if scores_test.shape[1] != n_classes_model:\n            if scores_test.shape[1] > n_classes_model:\n                scores_test = scores_test[:, :n_classes_model]\n            else:\n                pad = np.zeros(\n                    (scores_test.shape[0], n_classes_model - scores_test.shape[1]),\n                    dtype=float,\n                )\n                scores_test = np.concatenate([scores_test, pad], axis=1)\n\n        preds_bin = topk_from_scores(scores_test, PRED_TOP_K)\n\n        for i, rid in enumerate(chunk_ids):\n            row_pred = preds_bin[i]\n            if row_pred.sum() == 0:\n                # fallback to highest scoring tag\n                if scores_test.shape[1] > 0:\n                    idx = int(np.argmax(scores_test[i]))\n                    tags = [classes[idx]]\n                else:\n                    tags = []\n            else:\n                lbl_idx = np.where(row_pred == 1)[0]\n                tags = [classes[j] for j in lbl_idx]\n            tags_str = \" \".join(tags)\n            sub_rows.append((int(rid), tags_str))\n        total_test += len(chunk_ids)\n        print(f\"[info] Processed {total_test} test rows...\", file=sys.stderr)\n\n    # Write submission CSV\n    print(f\"[info] Writing submission to {SUBMISSION_FILE} ...\", file=sys.stderr)\n    with open(SUBMISSION_FILE, \"w\", encoding=\"utf-8\") as f:\n        f.write(\"Id,Tags\\n\")\n        for rid, tags in sub_rows:\n            safe_tags = tags.replace('\"', \"'\")\n            f.write(f'{rid},\"{safe_tags}\"\\n')\n\n    elapsed = time.time() - start_time\n    print(f\"[info] Done. Time elapsed: {elapsed:.1f} sec\", file=sys.stderr)\n\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\nimport os\nimport re\nimport sys\nimport time\nfrom collections import Counter\nimport random\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.model_selection import KFold\nfrom sklearn.metrics import f1_score\nfrom sklearn.base import clone\n\n# Configuration (tuned for robustness / speed)\nINPUT_DIR = \"./input\"\nTRAIN_FILE = os.path.join(INPUT_DIR, \"train.csv\")\nTEST_FILE = os.path.join(INPUT_DIR, \"test.csv\")\nSUBMISSION_DIR = \"./submission\"\nSUBMISSION_FILE = os.path.join(SUBMISSION_DIR, \"submission.csv\")\nos.makedirs(SUBMISSION_DIR, exist_ok=True)\n\nRANDOM_STATE = 42\nnp.random.seed(RANDOM_STATE)\nrandom.seed(RANDOM_STATE)\n\nSAMPLE_TARGET = 15000  # how many train examples to sample\nTOP_K_TAGS = 150  # model top K tags\nTFIDF_MAX_FEATURES = 15000\nNGRAM_RANGE = (1, 2)\nCV_FOLDS = 5\nPRED_TOP_K = 3\nCOUNT_CHUNK_ROWS = 50000\nCOLLECT_CHUNK = 50000\nTEST_CHUNK = 50000\n\n\ndef parse_tags(tagstr):\n    if pd.isna(tagstr):\n        return []\n    s = str(tagstr).strip()\n    if not s:\n        return []\n    if \"<\" in s and \">\" in s:\n        tags = re.findall(r\"<([^>]+)>\", s)\n        if tags:\n            return [t.strip().lower() for t in tags if t.strip()]\n    parts = re.split(r\"[,\\s]+\", s)\n    parts = [p.strip().lower() for p in parts if p.strip()]\n    return parts\n\n\ndef get_top_tags_fast(\n    train_file, top_k=TOP_K_TAGS, max_chunks=6, chunksize=COUNT_CHUNK_ROWS\n):\n    counter = Counter()\n    read_rows = 0\n    try:\n        reader = pd.read_csv(\n            train_file, usecols=[\"Tags\"], chunksize=chunksize, iterator=True, engine=\"c\"\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=[\"Tags\"],\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n    for i, chunk in enumerate(reader):\n        for t in chunk[\"Tags\"].dropna().astype(str):\n            counter.update(parse_tags(t))\n        read_rows += len(chunk)\n        if i + 1 >= max_chunks:\n            break\n    if len(counter) == 0:\n        try:\n            tmp = pd.read_csv(train_file, usecols=[\"Tags\"], nrows=1000)\n            for t in tmp[\"Tags\"].dropna().astype(str):\n                counter.update(parse_tags(t))\n        except Exception:\n            pass\n    top_tags = [t for t, _ in counter.most_common(top_k)]\n    print(\n        f\"[info] Fast-pass counted ~{read_rows} rows, unique tags: {len(counter)}. Selected top {len(top_tags)} tags.\",\n        file=sys.stderr,\n    )\n    return top_tags\n\n\ndef collect_examples_with_top_tags(\n    train_file, top_tags, sample_target=SAMPLE_TARGET, chunksize=COLLECT_CHUNK\n):\n    collected = []\n    collected_ids = set()\n    usecols = [\"Id\", \"Title\", \"Body\", \"Tags\"]\n    try:\n        reader = pd.read_csv(\n            train_file, usecols=usecols, chunksize=chunksize, iterator=True, engine=\"c\"\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=usecols,\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n    for chunk in reader:\n        for _, row in chunk.iterrows():\n            try:\n                rid = int(row[\"Id\"])\n            except Exception:\n                continue\n            if rid in collected_ids:\n                continue\n            tags = parse_tags(row.get(\"Tags\", \"\"))\n            if any(t in top_tags for t in tags):\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n            if len(collected) >= sample_target:\n                break\n        if len(collected) >= sample_target:\n            break\n\n    if len(collected) < sample_target:\n        # second pass to fill up sample_target\n        try:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=usecols,\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"c\",\n            )\n        except Exception:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=usecols,\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"python\",\n            )\n        for chunk in reader2:\n            for _, row in chunk.iterrows():\n                try:\n                    rid = int(row[\"Id\"])\n                except Exception:\n                    continue\n                if rid in collected_ids:\n                    continue\n                tags = parse_tags(row.get(\"Tags\", \"\"))\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n                if len(collected) >= sample_target:\n                    break\n            if len(collected) >= sample_target:\n                break\n\n    df = pd.DataFrame(collected, columns=[\"Id\", \"Title\", \"Body\", \"ParsedTags\"])\n    print(f\"[info] Total collected training examples: {len(df)}\", file=sys.stderr)\n    return df\n\n\ndef build_dataset_from_collected(df, top_tags):\n    df[\"Title\"] = df[\"Title\"].fillna(\"\").astype(str)\n    df[\"Body\"] = df[\"Body\"].fillna(\"\").astype(str)\n    df[\"text\"] = (\n        (df[\"Title\"] + \" \" + df[\"Body\"]).str.replace(\"\\n\", \" \").str.replace(\"\\r\", \" \")\n    )\n    df[\"TagsFiltered\"] = df[\"ParsedTags\"].apply(\n        lambda tags: [t for t in tags if t in top_tags]\n    )\n    before = len(df)\n    df = df[df[\"TagsFiltered\"].map(len) > 0].reset_index(drop=True)\n    after = len(df)\n    print(\n        f\"[info] Filtered dataset to {after} rows (from {before}) that contain at least one top tag.\",\n        file=sys.stderr,\n    )\n    y_lists = df[\"TagsFiltered\"].tolist()\n    return df, y_lists\n\n\ndef topk_from_scores(scores, k):\n    n_samples = scores.shape[0]\n    if scores.ndim == 1:\n        scores = scores.reshape(-1, 1)\n    n_classes = scores.shape[1]\n    k = min(k, n_classes)\n    if n_classes == 0 or k == 0:\n        return np.zeros((n_samples, n_classes), dtype=int)\n    idx_sorted = np.argsort(scores, axis=1)\n    topk_idx = idx_sorted[:, -k:]\n    preds = np.zeros((n_samples, n_classes), dtype=int)\n    rows = np.arange(n_samples)[:, None]\n    preds[rows, topk_idx] = 1\n    return preds\n\n\ndef manual_cv_predict_proba(clf, X, Y, cv):\n    n_samples = X.shape[0]\n    n_classes = Y.shape[1]\n    scores = np.zeros((n_samples, n_classes), dtype=float)\n    for fold_i, (train_idx, val_idx) in enumerate(cv.split(X)):\n        X_train = X[train_idx]\n        X_val = X[val_idx]\n        Y_train = Y[train_idx]\n        clf_clone = clone(clf)\n        try:\n            clf_clone.fit(X_train, Y_train)\n        except Exception as e:\n            print(f\"[warning] Fit failed on fold {fold_i}: {e}\", file=sys.stderr)\n            continue\n        got = None\n        try:\n            got = clf_clone.decision_function(X_val)\n        except Exception:\n            try:\n                got = clf_clone.predict_proba(X_val)\n            except Exception:\n                try:\n                    p = clf_clone.predict(X_val)\n                    got = p.astype(float)\n                except Exception as e:\n                    print(\n                        f\"[warning] All predict methods failed on fold {fold_i}: {e}\",\n                        file=sys.stderr,\n                    )\n                    got = np.zeros((len(val_idx), n_classes), dtype=float)\n        got = np.asarray(got)\n        if got.ndim == 1:\n            got = got.reshape(-1, 1)\n        if got.shape[1] != n_classes:\n            if got.shape[1] > n_classes:\n                got = got[:, :n_classes]\n            else:\n                pad = np.zeros((got.shape[0], n_classes - got.shape[1]), dtype=float)\n                got = np.concatenate([got, pad], axis=1)\n        scores[val_idx] = got\n        print(\n            f\"[info] Completed CV fold {fold_i+1}/{cv.get_n_splits()} (val size={len(val_idx)})\",\n            file=sys.stderr,\n        )\n    return scores\n\n\ndef main():\n    start_time = time.time()\n    print(\"[info] Starting training and prediction...\", file=sys.stderr)\n\n    top_tags = get_top_tags_fast(\n        TRAIN_FILE, top_k=TOP_K_TAGS, max_chunks=6, chunksize=COUNT_CHUNK_ROWS\n    )\n    if len(top_tags) == 0:\n        # fallback slower\n        try:\n            tmp = pd.read_csv(TRAIN_FILE, usecols=[\"Tags\"], nrows=200000)\n            counter = Counter()\n            for t in tmp[\"Tags\"].dropna().astype(str):\n                counter.update(parse_tags(t))\n            top_tags = [t for t, _ in counter.most_common(TOP_K_TAGS)]\n        except Exception:\n            top_tags = []\n    if len(top_tags) == 0:\n        print(\"[error] No tags found in training data; will exit.\", file=sys.stderr)\n        return\n\n    sampled_df = collect_examples_with_top_tags(\n        TRAIN_FILE, top_tags, sample_target=SAMPLE_TARGET, chunksize=COLLECT_CHUNK\n    )\n\n    # recompute top tags from sampled data to ensure alignment\n    all_tags = []\n    for tags in sampled_df[\"ParsedTags\"]:\n        all_tags.extend(tags)\n    tag_counts = Counter(all_tags)\n    top_tags_sampled = [t for t, _ in tag_counts.most_common(TOP_K_TAGS)]\n    if len(top_tags_sampled) > 0:\n        top_tags = top_tags_sampled[:TOP_K_TAGS]\n    print(f\"[info] Final modeling tag count: {len(top_tags)}\", file=sys.stderr)\n    if len(top_tags) == 0:\n        print(\"[error] No top tags after sampling; exiting.\", file=sys.stderr)\n        return\n\n    df, y_lists = build_dataset_from_collected(sampled_df, top_tags)\n    if len(df) < 50:\n        print(\"[error] Too few examples after filtering. Exiting.\", file=sys.stderr)\n        return\n\n    texts = df[\"text\"].tolist()\n    ids = df[\"Id\"].tolist()\n\n    print(\"[info] Fitting TF-IDF vectorizer...\", file=sys.stderr)\n    vectorizer = TfidfVectorizer(\n        max_features=TFIDF_MAX_FEATURES, ngram_range=NGRAM_RANGE, stop_words=\"english\"\n    )\n    X = vectorizer.fit_transform(texts)\n    print(f\"[info] TF-IDF shaped: {X.shape}\", file=sys.stderr)\n\n    mlb = MultiLabelBinarizer(classes=top_tags)\n    Y = mlb.fit_transform(y_lists)\n    classes = list(mlb.classes_)\n    print(\n        f\"[info] Label matrix shaped: {Y.shape}. Modeling {len(classes)} classes.\",\n        file=sys.stderr,\n    )\n\n    base_clf = LogisticRegression(\n        solver=\"saga\", max_iter=1000, C=1.0, random_state=RANDOM_STATE\n    )\n    clf = OneVsRestClassifier(base_clf, n_jobs=1)\n\n    n_splits = CV_FOLDS\n    if X.shape[0] < 10:\n        n_splits = 2\n    else:\n        n_splits = min(CV_FOLDS, X.shape[0])\n    print(\n        f\"[info] Performing {n_splits}-fold cross-validation (manual)...\",\n        file=sys.stderr,\n    )\n    kf = KFold(n_splits=n_splits, shuffle=True, random_state=RANDOM_STATE)\n    scores_cv = manual_cv_predict_proba(clf, X, Y, cv=kf)\n    if scores_cv.ndim == 1:\n        scores_cv = scores_cv.reshape(-1, 1)\n    y_pred_cv = topk_from_scores(scores_cv, PRED_TOP_K)\n\n    if y_pred_cv.shape != Y.shape:\n        min_cols = min(y_pred_cv.shape[1], Y.shape[1])\n        y_pred_cv = y_pred_cv[:, :min_cols]\n        Y_eval = Y[:, :min_cols]\n    else:\n        Y_eval = Y\n    try:\n        f1 = f1_score(Y_eval, y_pred_cv, average=\"samples\", zero_division=0)\n    except Exception as e:\n        print(f\"[warning] f1_score computation failed: {e}\", file=sys.stderr)\n        f1 = 0.0\n\n    # Print metric to stdout as required (single line)\n    print(f\"{f1:.6f}\")\n    print(f\"[info] Cross-validated sample-wise F1: {f1:.6f}\", file=sys.stderr)\n\n    # Retrain on full sampled data\n    print(\"[info] Retraining classifier on full sampled data...\", file=sys.stderr)\n    try:\n        clf.fit(X, Y)\n    except Exception as e:\n        print(\n            f\"[warning] Full fit failed: {e}. Attempting fallback per-class fit.\",\n            file=sys.stderr,\n        )\n        try:\n            for i in range(Y.shape[1]):\n                try:\n                    if hasattr(clf, \"estimators_\") and clf.estimators_[i] is not None:\n                        clf.estimators_[i].fit(X, Y[:, i])\n                except Exception:\n                    pass\n        except Exception:\n            pass\n\n    # Predict test set in chunks and write submission\n    print(\"[info] Predicting on test set and writing submission...\", file=sys.stderr)\n    sub_rows = []\n    total_test = 0\n    usecols = [\"Id\", \"Title\", \"Body\"]\n    try:\n        test_reader = pd.read_csv(\n            TEST_FILE, usecols=usecols, chunksize=TEST_CHUNK, iterator=True, engine=\"c\"\n        )\n    except Exception:\n        test_reader = pd.read_csv(\n            TEST_FILE,\n            usecols=usecols,\n            chunksize=TEST_CHUNK,\n            iterator=True,\n            engine=\"python\",\n        )\n\n    for chunk in test_reader:\n        chunk_ids = chunk[\"Id\"].tolist()\n        titles = chunk[\"Title\"].fillna(\"\").astype(str).tolist()\n        bodies = chunk[\"Body\"].fillna(\"\").astype(str).tolist()\n        texts_chunk = [\n            (t + \" \" + b).replace(\"\\n\", \" \").replace(\"\\r\", \" \")\n            for t, b in zip(titles, bodies)\n        ]\n        Xtest = vectorizer.transform(texts_chunk)\n\n        scores_test = None\n        try:\n            scores_test = clf.decision_function(Xtest)\n        except Exception:\n            try:\n                scores_test = clf.predict_proba(Xtest)\n            except Exception:\n                preds = clf.predict(Xtest)\n                scores_test = preds.astype(float)\n\n        scores_test = np.asarray(scores_test)\n        if scores_test.ndim == 1:\n            scores_test = scores_test.reshape(-1, 1)\n\n        n_classes_model = len(classes)\n        if scores_test.shape[1] != n_classes_model:\n            if scores_test.shape[1] > n_classes_model:\n                scores_test = scores_test[:, :n_classes_model]\n            else:\n                pad = np.zeros(\n                    (scores_test.shape[0], n_classes_model - scores_test.shape[1]),\n                    dtype=float,\n                )\n                scores_test = np.concatenate([scores_test, pad], axis=1)\n\n        preds_bin = topk_from_scores(scores_test, PRED_TOP_K)\n\n        for i, rid in enumerate(chunk_ids):\n            row_pred = preds_bin[i]\n            if row_pred.sum() == 0:\n                # fallback to highest scoring tag\n                if scores_test.shape[1] > 0:\n                    idx = int(np.argmax(scores_test[i]))\n                    tags = [classes[idx]]\n                else:\n                    tags = []\n            else:\n                lbl_idx = np.where(row_pred == 1)[0]\n                tags = [classes[j] for j in lbl_idx]\n            tags_str = \" \".join(tags)\n            sub_rows.append((int(rid), tags_str))\n        total_test += len(chunk_ids)\n        print(f\"[info] Processed {total_test} test rows...\", file=sys.stderr)\n\n    print(f\"[info] Writing submission to {SUBMISSION_FILE} ...\", file=sys.stderr)\n    with open(SUBMISSION_FILE, \"w\", encoding=\"utf-8\") as f:\n        f.write(\"Id,Tags\\n\")\n        for rid, tags in sub_rows:\n            safe_tags = tags.replace('\"', \"'\")\n            f.write(f'{rid},\"{safe_tags}\"\\n')\n\n    elapsed = time.time() - start_time\n    print(f\"[info] Done. Time elapsed: {elapsed:.1f} sec\", file=sys.stderr)\n\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\nimport os\nimport re\nimport sys\nimport time\nfrom collections import Counter\nimport random\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.model_selection import KFold\nfrom sklearn.metrics import f1_score\nfrom sklearn.base import clone\n\n# Configuration (kept moderate to run quickly but robustly)\nINPUT_DIR = \"./input\"\nTRAIN_FILE = os.path.join(INPUT_DIR, \"train.csv\")\nTEST_FILE = os.path.join(INPUT_DIR, \"test.csv\")\nSUBMISSION_DIR = \"./submission\"\nSUBMISSION_FILE = os.path.join(SUBMISSION_DIR, \"submission.csv\")\nos.makedirs(SUBMISSION_DIR, exist_ok=True)\n\nRANDOM_STATE = 42\nnp.random.seed(RANDOM_STATE)\nrandom.seed(RANDOM_STATE)\n\nSAMPLE_TARGET = 10000  # reduced sample for reliability/speed\nTOP_K_TAGS = 100  # number of most frequent tags to model\nTFIDF_MAX_FEATURES = 20000\nNGRAM_RANGE = (1, 2)\nCV_FOLDS = 5\nPRED_TOP_K = 3\nCOUNT_CHUNK_ROWS = 50000\nCOLLECT_CHUNK = 50000\nTEST_CHUNK = 50000\n\n\ndef parse_tags(tagstr):\n    if pd.isna(tagstr):\n        return []\n    s = str(tagstr).strip()\n    if not s:\n        return []\n    # many Kaggle stacks use <tag1><tag2> format, handle that first\n    if \"<\" in s and \">\" in s:\n        tags = re.findall(r\"<([^>]+)>\", s)\n        if tags:\n            return [t.strip().lower() for t in tags if t.strip()]\n    # else split on commas/spaces\n    parts = re.split(r\"[,\\s]+\", s)\n    parts = [p.strip().lower() for p in parts if p.strip()]\n    return parts\n\n\ndef get_top_tags_fast(\n    train_file, top_k=TOP_K_TAGS, max_chunks=6, chunksize=COUNT_CHUNK_ROWS\n):\n    counter = Counter()\n    read_rows = 0\n    usecols = [\"Tags\"]\n    try:\n        reader = pd.read_csv(\n            train_file, usecols=usecols, chunksize=chunksize, iterator=True, engine=\"c\"\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=usecols,\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n    for i, chunk in enumerate(reader):\n        for t in chunk[\"Tags\"].dropna().astype(str):\n            counter.update(parse_tags(t))\n        read_rows += len(chunk)\n        if i + 1 >= max_chunks:\n            break\n    if len(counter) == 0:\n        # fallback small read\n        try:\n            tmp = pd.read_csv(train_file, usecols=usecols, nrows=10000)\n            for t in tmp[\"Tags\"].dropna().astype(str):\n                counter.update(parse_tags(t))\n        except Exception:\n            pass\n    top_tags = [t for t, _ in counter.most_common(top_k)]\n    print(\n        f\"[info] Fast-pass counted ~{read_rows} rows, unique tags: {len(counter)}. Selected top {len(top_tags)} tags.\",\n        file=sys.stderr,\n    )\n    return top_tags\n\n\ndef collect_examples_with_top_tags(\n    train_file, top_tags, sample_target=SAMPLE_TARGET, chunksize=COLLECT_CHUNK\n):\n    collected = []\n    collected_ids = set()\n    usecols = [\"Id\", \"Title\", \"Body\", \"Tags\"]\n    try:\n        reader = pd.read_csv(\n            train_file, usecols=usecols, chunksize=chunksize, iterator=True, engine=\"c\"\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=usecols,\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n    for chunk in reader:\n        for _, row in chunk.iterrows():\n            try:\n                rid = int(row[\"Id\"])\n            except Exception:\n                continue\n            if rid in collected_ids:\n                continue\n            tags = parse_tags(row.get(\"Tags\", \"\"))\n            # collect if contains at least one of our top tags\n            if any(t in top_tags for t in tags):\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n            if len(collected) >= sample_target:\n                break\n        if len(collected) >= sample_target:\n            break\n\n    # if not enough, do a second pass to fill up (without tag filtering)\n    if len(collected) < sample_target:\n        try:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=usecols,\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"c\",\n            )\n        except Exception:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=usecols,\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"python\",\n            )\n        for chunk in reader2:\n            for _, row in chunk.iterrows():\n                try:\n                    rid = int(row[\"Id\"])\n                except Exception:\n                    continue\n                if rid in collected_ids:\n                    continue\n                tags = parse_tags(row.get(\"Tags\", \"\"))\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n                if len(collected) >= sample_target:\n                    break\n            if len(collected) >= sample_target:\n                break\n\n    df = pd.DataFrame(collected, columns=[\"Id\", \"Title\", \"Body\", \"ParsedTags\"])\n    print(f\"[info] Total collected training examples: {len(df)}\", file=sys.stderr)\n    return df\n\n\ndef build_dataset_from_collected(df, top_tags):\n    df[\"Title\"] = df[\"Title\"].fillna(\"\").astype(str)\n    df[\"Body\"] = df[\"Body\"].fillna(\"\").astype(str)\n    # simple cleanup\n    df[\"text\"] = (\n        (df[\"Title\"] + \" \" + df[\"Body\"]).str.replace(\"\\n\", \" \").str.replace(\"\\r\", \" \")\n    )\n    df[\"TagsFiltered\"] = df[\"ParsedTags\"].apply(\n        lambda tags: [t for t in tags if t in top_tags]\n    )\n    before = len(df)\n    df = df[df[\"TagsFiltered\"].map(len) > 0].reset_index(drop=True)\n    after = len(df)\n    print(\n        f\"[info] Filtered dataset to {after} rows (from {before}) that contain at least one top tag.\",\n        file=sys.stderr,\n    )\n    y_lists = df[\"TagsFiltered\"].tolist()\n    return df, y_lists\n\n\ndef topk_from_scores(scores, k):\n    n_samples = scores.shape[0]\n    if scores.ndim == 1:\n        scores = scores.reshape(-1, 1)\n    n_classes = scores.shape[1]\n    k = min(k, n_classes)\n    if n_classes == 0 or k == 0:\n        return np.zeros((n_samples, n_classes), dtype=int)\n    # argsort ascending\n    idx_sorted = np.argsort(scores, axis=1)\n    topk_idx = idx_sorted[:, -k:]\n    preds = np.zeros((n_samples, n_classes), dtype=int)\n    rows = np.arange(n_samples)[:, None]\n    preds[rows, topk_idx] = 1\n    return preds\n\n\ndef manual_cv_predict_proba(clf, X, Y, cv):\n    n_samples = X.shape[0]\n    n_classes = Y.shape[1]\n    scores = np.zeros((n_samples, n_classes), dtype=float)\n    for fold_i, (train_idx, val_idx) in enumerate(cv.split(X)):\n        X_train = X[train_idx]\n        X_val = X[val_idx]\n        Y_train = Y[train_idx]\n        clf_clone = clone(clf)\n        try:\n            clf_clone.fit(X_train, Y_train)\n        except Exception as e:\n            print(f\"[warning] Fit failed on fold {fold_i}: {e}\", file=sys.stderr)\n            continue\n        got = None\n        try:\n            got = clf_clone.decision_function(X_val)\n        except Exception:\n            try:\n                got = clf_clone.predict_proba(X_val)\n            except Exception:\n                try:\n                    p = clf_clone.predict(X_val)\n                    got = p.astype(float)\n                except Exception as e:\n                    print(\n                        f\"[warning] All predict methods failed on fold {fold_i}: {e}\",\n                        file=sys.stderr,\n                    )\n                    got = np.zeros((len(val_idx), n_classes), dtype=float)\n        got = np.asarray(got)\n        if got.ndim == 1:\n            got = got.reshape(-1, 1)\n        # align columns\n        if got.shape[1] != n_classes:\n            if got.shape[1] > n_classes:\n                got = got[:, :n_classes]\n            else:\n                pad = np.zeros((got.shape[0], n_classes - got.shape[1]), dtype=float)\n                got = np.concatenate([got, pad], axis=1)\n        scores[val_idx] = got\n        print(\n            f\"[info] Completed CV fold {fold_i+1}/{cv.get_n_splits()} (val size={len(val_idx)})\",\n            file=sys.stderr,\n        )\n    return scores\n\n\ndef main():\n    start_time = time.time()\n    print(\"[info] Starting training and prediction...\", file=sys.stderr)\n\n    top_tags = get_top_tags_fast(\n        TRAIN_FILE, top_k=TOP_K_TAGS, max_chunks=6, chunksize=COUNT_CHUNK_ROWS\n    )\n    if len(top_tags) == 0:\n        # fallback slower full-pass small nrows\n        try:\n            tmp = pd.read_csv(TRAIN_FILE, usecols=[\"Tags\"], nrows=200000)\n            counter = Counter()\n            for t in tmp[\"Tags\"].dropna().astype(str):\n                counter.update(parse_tags(t))\n            top_tags = [t for t, _ in counter.most_common(TOP_K_TAGS)]\n        except Exception:\n            top_tags = []\n    if len(top_tags) == 0:\n        print(\"[error] No tags found in training data; will exit.\", file=sys.stderr)\n        return\n\n    sampled_df = collect_examples_with_top_tags(\n        TRAIN_FILE, top_tags, sample_target=SAMPLE_TARGET, chunksize=COLLECT_CHUNK\n    )\n\n    # recompute top tags from sampled data to ensure alignment\n    all_tags = []\n    for tags in sampled_df[\"ParsedTags\"]:\n        all_tags.extend(tags)\n    tag_counts = Counter(all_tags)\n    top_tags_sampled = [t for t, _ in tag_counts.most_common(TOP_K_TAGS)]\n    if len(top_tags_sampled) > 0:\n        top_tags = top_tags_sampled[:TOP_K_TAGS]\n    print(f\"[info] Final modeling tag count: {len(top_tags)}\", file=sys.stderr)\n    if len(top_tags) == 0:\n        print(\"[error] No top tags after sampling; exiting.\", file=sys.stderr)\n        return\n\n    df, y_lists = build_dataset_from_collected(sampled_df, top_tags)\n    if len(df) < 50:\n        print(\"[error] Too few examples after filtering. Exiting.\", file=sys.stderr)\n        return\n\n    texts = df[\"text\"].tolist()\n    ids = df[\"Id\"].tolist()\n\n    print(\"[info] Fitting TF-IDF vectorizer...\", file=sys.stderr)\n    vectorizer = TfidfVectorizer(\n        max_features=TFIDF_MAX_FEATURES, ngram_range=NGRAM_RANGE, stop_words=\"english\"\n    )\n    X = vectorizer.fit_transform(texts)\n    print(f\"[info] TF-IDF shaped: {X.shape}\", file=sys.stderr)\n\n    mlb = MultiLabelBinarizer(classes=top_tags)\n    Y = mlb.fit_transform(y_lists)\n    classes = list(mlb.classes_)\n    print(\n        f\"[info] Label matrix shaped: {Y.shape}. Modeling {len(classes)} classes.\",\n        file=sys.stderr,\n    )\n\n    base_clf = LogisticRegression(\n        solver=\"saga\", max_iter=300, C=1.0, random_state=RANDOM_STATE\n    )\n    clf = OneVsRestClassifier(base_clf, n_jobs=1)\n\n    n_splits = CV_FOLDS\n    if X.shape[0] < 10:\n        n_splits = 2\n    else:\n        n_splits = min(CV_FOLDS, X.shape[0])\n    print(\n        f\"[info] Performing {n_splits}-fold cross-validation (manual)...\",\n        file=sys.stderr,\n    )\n    kf = KFold(n_splits=n_splits, shuffle=True, random_state=RANDOM_STATE)\n    scores_cv = manual_cv_predict_proba(clf, X, Y, cv=kf)\n    if scores_cv.ndim == 1:\n        scores_cv = scores_cv.reshape(-1, 1)\n    y_pred_cv = topk_from_scores(scores_cv, PRED_TOP_K)\n\n    # align shapes before scoring\n    if y_pred_cv.shape != Y.shape:\n        min_cols = min(y_pred_cv.shape[1], Y.shape[1])\n        y_pred_cv = y_pred_cv[:, :min_cols]\n        Y_eval = Y[:, :min_cols]\n    else:\n        Y_eval = Y\n    try:\n        f1 = f1_score(Y_eval, y_pred_cv, average=\"samples\", zero_division=0)\n    except Exception as e:\n        print(f\"[warning] f1_score computation failed: {e}\", file=sys.stderr)\n        f1 = 0.0\n\n    # Print metric to stdout as required (single line)\n    print(f\"{f1:.6f}\")\n    print(f\"[info] Cross-validated sample-wise F1: {f1:.6f}\", file=sys.stderr)\n\n    # Retrain on full sampled data\n    print(\"[info] Retraining classifier on full sampled data...\", file=sys.stderr)\n    try:\n        clf.fit(X, Y)\n    except Exception as e:\n        print(\n            f\"[warning] Full fit failed: {e}. Attempting per-class fallback.\",\n            file=sys.stderr,\n        )\n        # fallback: fit each estimator individually if possible\n        try:\n            for i in range(Y.shape[1]):\n                ycol = Y[:, i]\n                try:\n                    est = LogisticRegression(\n                        solver=\"saga\", max_iter=200, C=1.0, random_state=RANDOM_STATE\n                    )\n                    est.fit(X, ycol)\n                    # store in clf.estimators_ if exists\n                    if hasattr(clf, \"estimators_\"):\n                        if len(clf.estimators_) == Y.shape[1]:\n                            clf.estimators_[i] = est\n                except Exception:\n                    pass\n        except Exception:\n            pass\n\n    # Predict test set in chunks and write submission\n    print(\"[info] Predicting on test set and writing submission...\", file=sys.stderr)\n    sub_rows = []\n    total_test = 0\n    usecols = [\"Id\", \"Title\", \"Body\"]\n    try:\n        test_reader = pd.read_csv(\n            TEST_FILE, usecols=usecols, chunksize=TEST_CHUNK, iterator=True, engine=\"c\"\n        )\n    except Exception:\n        test_reader = pd.read_csv(\n            TEST_FILE,\n            usecols=usecols,\n            chunksize=TEST_CHUNK,\n            iterator=True,\n            engine=\"python\",\n        )\n\n    for chunk in test_reader:\n        chunk_ids = chunk[\"Id\"].tolist()\n        titles = chunk[\"Title\"].fillna(\"\").astype(str).tolist()\n        bodies = chunk[\"Body\"].fillna(\"\").astype(str).tolist()\n        texts_chunk = [\n            (t + \" \" + b).replace(\"\\n\", \" \").replace(\"\\r\", \" \")\n            for t, b in zip(titles, bodies)\n        ]\n        Xtest = vectorizer.transform(texts_chunk)\n\n        scores_test = None\n        try:\n            scores_test = clf.decision_function(Xtest)\n        except Exception:\n            try:\n                scores_test = clf.predict_proba(Xtest)\n            except Exception:\n                preds = clf.predict(Xtest)\n                scores_test = preds.astype(float)\n\n        scores_test = np.asarray(scores_test)\n        if scores_test.ndim == 1:\n            scores_test = scores_test.reshape(-1, 1)\n\n        n_classes_model = len(classes)\n        if scores_test.shape[1] != n_classes_model:\n            if scores_test.shape[1] > n_classes_model:\n                scores_test = scores_test[:, :n_classes_model]\n            else:\n                pad = np.zeros(\n                    (scores_test.shape[0], n_classes_model - scores_test.shape[1]),\n                    dtype=float,\n                )\n                scores_test = np.concatenate([scores_test, pad], axis=1)\n\n        preds_bin = topk_from_scores(scores_test, PRED_TOP_K)\n\n        for i, rid in enumerate(chunk_ids):\n            row_pred = preds_bin[i]\n            if row_pred.sum() == 0:\n                # fallback to highest scoring tag\n                if scores_test.shape[1] > 0:\n                    idx = int(np.argmax(scores_test[i]))\n                    tags = [classes[idx]]\n                else:\n                    tags = []\n            else:\n                lbl_idx = np.where(row_pred == 1)[0]\n                tags = [classes[j] for j in lbl_idx]\n            # ensure tags are safe (no commas inside)\n            tags_str = \" \".join(tags)\n            sub_rows.append((int(rid), tags_str))\n        total_test += len(chunk_ids)\n        print(f\"[info] Processed {total_test} test rows...\", file=sys.stderr)\n\n    # write submission CSV\n    print(f\"[info] Writing submission to {SUBMISSION_FILE} ...\", file=sys.stderr)\n    with open(SUBMISSION_FILE, \"w\", encoding=\"utf-8\") as f:\n        f.write(\"Id,Tags\\n\")\n        for rid, tags in sub_rows:\n            safe_tags = tags.replace('\"', \"'\")\n            f.write(f'{rid},\"{safe_tags}\"\\n')\n\n    elapsed = time.time() - start_time\n    print(f\"[info] Done. Time elapsed: {elapsed:.1f} sec\", file=sys.stderr)\n\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\nimport os\nimport re\nimport sys\nimport time\nfrom collections import Counter\nimport random\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.model_selection import KFold\nfrom sklearn.metrics import f1_score\nfrom sklearn.base import clone\n\n# Configuration\nINPUT_DIR = \"./input\"\nTRAIN_FILE = os.path.join(INPUT_DIR, \"train.csv\")\nTEST_FILE = os.path.join(INPUT_DIR, \"test.csv\")\nSUBMISSION_DIR = \"./submission\"\nSUBMISSION_FILE = os.path.join(SUBMISSION_DIR, \"submission.csv\")\nos.makedirs(SUBMISSION_DIR, exist_ok=True)\n\nRANDOM_STATE = 42\nnp.random.seed(RANDOM_STATE)\nrandom.seed(RANDOM_STATE)\n\n# Tunable but moderate values to complete within time\nSAMPLE_TARGET = 15000  # number of training examples to collect\nTOP_K_TAGS = 100  # how many top tags to model\nTFIDF_MAX_FEATURES = 20000\nNGRAM_RANGE = (1, 2)\nCV_FOLDS = 5\nPRED_TOP_K = 3\nREAD_NROWS_FOR_TAGS = 200000\nCHUNKSIZE = 50000\nTEST_CHUNK = 50000\n\n\ndef parse_tags(tagstr):\n    if pd.isna(tagstr):\n        return []\n    s = str(tagstr).strip()\n    if not s:\n        return []\n    # many Kaggle stacks use <tag1><tag2> format, handle that first\n    if \"<\" in s and \">\" in s:\n        tags = re.findall(r\"<([^>]+)>\", s)\n        if tags:\n            return [t.strip().lower() for t in tags if t.strip()]\n    # else split on commas/spaces\n    parts = re.split(r\"[,\\s]+\", s)\n    parts = [p.strip().lower() for p in parts if p.strip()]\n    return parts\n\n\ndef get_top_tags_from_head(train_file, top_k=TOP_K_TAGS, nrows=READ_NROWS_FOR_TAGS):\n    counter = Counter()\n    try:\n        tmp = pd.read_csv(train_file, usecols=[\"Tags\"], nrows=nrows)\n        for t in tmp[\"Tags\"].dropna().astype(str):\n            counter.update(parse_tags(t))\n    except Exception:\n        # fallback: try reading a small chunk\n        try:\n            tmp = pd.read_csv(\n                train_file, usecols=[\"Tags\"], nrows=50000, engine=\"python\"\n            )\n            for t in tmp[\"Tags\"].dropna().astype(str):\n                counter.update(parse_tags(t))\n        except Exception:\n            pass\n    top_tags = [t for t, _ in counter.most_common(top_k)]\n    print(f\"[info] Collected top {len(top_tags)} tags from head scan.\", file=sys.stderr)\n    return top_tags\n\n\ndef collect_examples_with_top_tags(\n    train_file, top_tags, sample_target=SAMPLE_TARGET, chunksize=CHUNKSIZE\n):\n    collected = []\n    collected_ids = set()\n    usecols = [\"Id\", \"Title\", \"Body\", \"Tags\"]\n    try:\n        reader = pd.read_csv(\n            train_file, usecols=usecols, chunksize=chunksize, iterator=True\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=usecols,\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n    for chunk in reader:\n        for _, row in chunk.iterrows():\n            try:\n                rid = int(row[\"Id\"])\n            except Exception:\n                continue\n            if rid in collected_ids:\n                continue\n            tags = parse_tags(row.get(\"Tags\", \"\"))\n            if any(t in top_tags for t in tags):\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n            if len(collected) >= sample_target:\n                break\n        if len(collected) >= sample_target:\n            break\n\n    # If not enough, do a second pass and collect without tag restriction\n    if len(collected) < sample_target:\n        try:\n            reader2 = pd.read_csv(\n                train_file, usecols=usecols, chunksize=chunksize, iterator=True\n            )\n        except Exception:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=usecols,\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"python\",\n            )\n        for chunk in reader2:\n            for _, row in chunk.iterrows():\n                try:\n                    rid = int(row[\"Id\"])\n                except Exception:\n                    continue\n                if rid in collected_ids:\n                    continue\n                tags = parse_tags(row.get(\"Tags\", \"\"))\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n                if len(collected) >= sample_target:\n                    break\n            if len(collected) >= sample_target:\n                break\n\n    df = pd.DataFrame(collected, columns=[\"Id\", \"Title\", \"Body\", \"ParsedTags\"])\n    print(\n        f\"[info] Collected {len(df)} training examples (target {sample_target}).\",\n        file=sys.stderr,\n    )\n    return df\n\n\ndef build_dataset_from_collected(df, top_tags):\n    df[\"Title\"] = df[\"Title\"].fillna(\"\").astype(str)\n    df[\"Body\"] = df[\"Body\"].fillna(\"\").astype(str)\n    df[\"text\"] = (\n        (df[\"Title\"] + \" \" + df[\"Body\"]).str.replace(\"\\n\", \" \").str.replace(\"\\r\", \" \")\n    )\n    # filter tags to top_tags only\n    df[\"TagsFiltered\"] = df[\"ParsedTags\"].apply(\n        lambda tags: [t for t in tags if t in top_tags]\n    )\n    before = len(df)\n    df = df[df[\"TagsFiltered\"].map(len) > 0].reset_index(drop=True)\n    after = len(df)\n    if after == 0:\n        # fallback: if nothing, allow any tags but then restrict to top_tags when binarizing\n        df = df.copy().reset_index(drop=True)\n        print(\n            \"[warning] No examples have top tags after filtering; proceeding with unfiltered data.\",\n            file=sys.stderr,\n        )\n    else:\n        print(\n            f\"[info] Filtered dataset to {after} rows from {before} that include at least one top tag.\",\n            file=sys.stderr,\n        )\n    y_lists = (\n        df[\"TagsFiltered\"]\n        .apply(lambda x: x if isinstance(x, list) and len(x) > 0 else [])\n        .tolist()\n    )\n    return df, y_lists\n\n\ndef topk_from_scores(scores, k):\n    n_samples = scores.shape[0]\n    if scores.ndim == 1:\n        scores = scores.reshape(-1, 1)\n    n_classes = scores.shape[1]\n    k = min(k, n_classes)\n    if n_classes == 0 or k == 0:\n        return np.zeros((n_samples, n_classes), dtype=int)\n    idx_sorted = np.argsort(scores, axis=1)\n    topk_idx = idx_sorted[:, -k:]\n    preds = np.zeros((n_samples, n_classes), dtype=int)\n    rows = np.arange(n_samples)[:, None]\n    preds[rows, topk_idx] = 1\n    return preds\n\n\ndef manual_cv_predict_proba(clf, X, Y, cv):\n    n_samples = X.shape[0]\n    n_classes = Y.shape[1]\n    scores = np.zeros((n_samples, n_classes), dtype=float)\n    for fold_i, (train_idx, val_idx) in enumerate(cv.split(X)):\n        X_train = X[train_idx]\n        X_val = X[val_idx]\n        Y_train = Y[train_idx]\n        clf_clone = clone(clf)\n        try:\n            clf_clone.fit(X_train, Y_train)\n        except Exception as e:\n            print(f\"[warning] Fit failed on fold {fold_i}: {e}\", file=sys.stderr)\n            continue\n        got = None\n        try:\n            got = clf_clone.decision_function(X_val)\n        except Exception:\n            try:\n                got = clf_clone.predict_proba(X_val)\n            except Exception:\n                try:\n                    p = clf_clone.predict(X_val)\n                    got = p.astype(float)\n                except Exception as e:\n                    print(\n                        f\"[warning] All predict methods failed on fold {fold_i}: {e}\",\n                        file=sys.stderr,\n                    )\n                    got = np.zeros((len(val_idx), n_classes), dtype=float)\n        got = np.asarray(got)\n        if got.ndim == 1:\n            got = got.reshape(-1, 1)\n        # align columns\n        if got.shape[1] != n_classes:\n            if got.shape[1] > n_classes:\n                got = got[:, :n_classes]\n            else:\n                pad = np.zeros((got.shape[0], n_classes - got.shape[1]), dtype=float)\n                got = np.concatenate([got, pad], axis=1)\n        scores[val_idx] = got\n        print(\n            f\"[info] Finished CV fold {fold_i+1}/{cv.get_n_splits()} (val size={len(val_idx)}).\",\n            file=sys.stderr,\n        )\n    return scores\n\n\ndef main():\n    start_time = time.time()\n    print(\"[info] Starting pipeline...\", file=sys.stderr)\n\n    # 1) Get top tags from head of file\n    top_tags = get_top_tags_from_head(\n        TRAIN_FILE, top_k=TOP_K_TAGS, nrows=READ_NROWS_FOR_TAGS\n    )\n    if len(top_tags) == 0:\n        print(\n            \"[warning] No top tags found from head scan; trying full small scan...\",\n            file=sys.stderr,\n        )\n        # try a small full pass\n        try:\n            tmp = pd.read_csv(TRAIN_FILE, usecols=[\"Tags\"], nrows=100000)\n            c = Counter()\n            for t in tmp[\"Tags\"].dropna().astype(str):\n                c.update(parse_tags(t))\n            top_tags = [t for t, _ in c.most_common(TOP_K_TAGS)]\n        except Exception:\n            pass\n    if len(top_tags) == 0:\n        print(\"[error] No tags found; exiting.\", file=sys.stderr)\n        return\n\n    # 2) Collect examples that include at least one top tag (or fallback to general rows)\n    sampled_df = collect_examples_with_top_tags(\n        TRAIN_FILE, top_tags, sample_target=SAMPLE_TARGET, chunksize=CHUNKSIZE\n    )\n    if sampled_df.shape[0] == 0:\n        print(\n            \"[error] Failed to collect any training examples; exiting.\", file=sys.stderr\n        )\n        return\n\n    # Recompute top tags from sampled data to align classes\n    all_tags = []\n    for tags in sampled_df[\"ParsedTags\"]:\n        all_tags.extend(tags)\n    tag_counts = Counter(all_tags)\n    top_tags_sampled = [t for t, _ in tag_counts.most_common(TOP_K_TAGS)]\n    if len(top_tags_sampled) > 0:\n        top_tags = top_tags_sampled[:TOP_K_TAGS]\n    print(f\"[info] Final modeling tags: {len(top_tags)}\", file=sys.stderr)\n\n    # 3) Build dataset\n    df, y_lists = build_dataset_from_collected(sampled_df, top_tags)\n    if len(df) < 10:\n        print(\"[error] Too few examples after filtering; exiting.\", file=sys.stderr)\n        return\n\n    texts = df[\"text\"].tolist()\n    ids = df[\"Id\"].tolist()\n\n    # 4) TF-IDF\n    print(\"[info] Fitting TF-IDF...\", file=sys.stderr)\n    vectorizer = TfidfVectorizer(\n        max_features=TFIDF_MAX_FEATURES, ngram_range=NGRAM_RANGE, stop_words=\"english\"\n    )\n    X = vectorizer.fit_transform(texts)\n    print(f\"[info] TF-IDF matrix shape: {X.shape}\", file=sys.stderr)\n\n    # 5) Labels\n    # ensure each y_list contains only tags in top_tags\n    y_lists_filtered = [[t for t in tags if t in top_tags] for tags in y_lists]\n    mlb = MultiLabelBinarizer(classes=top_tags)\n    Y = mlb.fit_transform(y_lists_filtered)\n    classes = list(mlb.classes_)\n    print(f\"[info] Label matrix shape: {Y.shape}\", file=sys.stderr)\n\n    # 6) Model and cross-validation\n    base_clf = LogisticRegression(\n        solver=\"liblinear\", max_iter=200, C=1.0, random_state=RANDOM_STATE\n    )\n    clf = OneVsRestClassifier(base_clf, n_jobs=1)\n\n    n_splits = CV_FOLDS\n    if X.shape[0] < 10:\n        n_splits = 2\n    else:\n        n_splits = min(CV_FOLDS, X.shape[0])\n    print(f\"[info] Running {n_splits}-fold CV...\", file=sys.stderr)\n    kf = KFold(n_splits=n_splits, shuffle=True, random_state=RANDOM_STATE)\n    scores_cv = manual_cv_predict_proba(clf, X, Y, cv=kf)\n    if scores_cv.ndim == 1:\n        scores_cv = scores_cv.reshape(-1, 1)\n    y_pred_cv = topk_from_scores(scores_cv, PRED_TOP_K)\n\n    # align shapes\n    if y_pred_cv.shape != Y.shape:\n        min_cols = min(y_pred_cv.shape[1], Y.shape[1])\n        y_pred_cv = y_pred_cv[:, :min_cols]\n        Y_eval = Y[:, :min_cols]\n    else:\n        Y_eval = Y\n\n    try:\n        f1 = f1_score(Y_eval, y_pred_cv, average=\"samples\", zero_division=0)\n    except Exception as e:\n        print(f\"[warning] f1_score computation failed: {e}\", file=sys.stderr)\n        f1 = 0.0\n\n    # Print metric\n    print(f\"{f1:.6f}\")\n    print(f\"[info] Cross-validated sample-wise F1: {f1:.6f}\", file=sys.stderr)\n\n    # 7) Retrain on full sampled data\n    print(\"[info] Retraining classifier on full sampled data...\", file=sys.stderr)\n    try:\n        clf.fit(X, Y)\n    except Exception as e:\n        print(f\"[warning] Full fit failed: {e}\", file=sys.stderr)\n        # Try per-class fallback training\n        try:\n            estimators = []\n            for i in range(Y.shape[1]):\n                ycol = Y[:, i]\n                est = clone(base_clf)\n                est.fit(X, ycol)\n                estimators.append(est)\n            clf.estimators_ = estimators\n        except Exception as e2:\n            print(\n                f\"[error] Fallback per-class training also failed: {e2}\",\n                file=sys.stderr,\n            )\n\n    # 8) Predict test set and write submission\n    print(\"[info] Predicting test set and writing submission...\", file=sys.stderr)\n    sub_rows = []\n    total_test = 0\n    usecols = [\"Id\", \"Title\", \"Body\"]\n    try:\n        test_reader = pd.read_csv(\n            TEST_FILE, usecols=usecols, chunksize=TEST_CHUNK, iterator=True\n        )\n    except Exception:\n        test_reader = pd.read_csv(\n            TEST_FILE,\n            usecols=usecols,\n            chunksize=TEST_CHUNK,\n            iterator=True,\n            engine=\"python\",\n        )\n\n    for chunk in test_reader:\n        chunk_ids = chunk[\"Id\"].tolist()\n        titles = chunk[\"Title\"].fillna(\"\").astype(str).tolist()\n        bodies = chunk[\"Body\"].fillna(\"\").astype(str).tolist()\n        texts_chunk = [\n            (t + \" \" + b).replace(\"\\n\", \" \").replace(\"\\r\", \" \")\n            for t, b in zip(titles, bodies)\n        ]\n        Xtest = vectorizer.transform(texts_chunk)\n\n        scores_test = None\n        try:\n            scores_test = clf.decision_function(Xtest)\n        except Exception:\n            try:\n                scores_test = clf.predict_proba(Xtest)\n            except Exception:\n                preds = clf.predict(Xtest)\n                scores_test = preds.astype(float)\n\n        scores_test = np.asarray(scores_test)\n        if scores_test.ndim == 1:\n            scores_test = scores_test.reshape(-1, 1)\n\n        n_classes_model = len(classes)\n        if scores_test.shape[1] != n_classes_model:\n            if scores_test.shape[1] > n_classes_model:\n                scores_test = scores_test[:, :n_classes_model]\n            else:\n                pad = np.zeros(\n                    (scores_test.shape[0], n_classes_model - scores_test.shape[1]),\n                    dtype=float,\n                )\n                scores_test = np.concatenate([scores_test, pad], axis=1)\n\n        preds_bin = topk_from_scores(scores_test, PRED_TOP_K)\n\n        for i, rid in enumerate(chunk_ids):\n            row_pred = preds_bin[i]\n            if row_pred.sum() == 0:\n                if scores_test.shape[1] > 0:\n                    idx = int(np.argmax(scores_test[i]))\n                    tags = [classes[idx]]\n                else:\n                    tags = []\n            else:\n                lbl_idx = np.where(row_pred == 1)[0]\n                tags = [classes[j] for j in lbl_idx]\n            tags_str = \" \".join(tags)\n            sub_rows.append((int(rid), tags_str))\n        total_test += len(chunk_ids)\n        print(f\"[info] Processed {total_test} test rows...\", file=sys.stderr)\n\n    # write submission CSV\n    print(f\"[info] Writing submission to {SUBMISSION_FILE} ...\", file=sys.stderr)\n    with open(SUBMISSION_FILE, \"w\", encoding=\"utf-8\") as f:\n        f.write(\"Id,Tags\\n\")\n        for rid, tags in sub_rows:\n            safe_tags = tags.replace('\"', \"'\")\n            f.write(f'{rid},\"{safe_tags}\"\\n')\n\n    elapsed = time.time() - start_time\n    print(f\"[info] Done. Time elapsed: {elapsed:.1f} sec\", file=sys.stderr)\n\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\nimport os\nimport re\nimport sys\nimport time\nfrom collections import Counter\nimport random\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.model_selection import KFold\nfrom sklearn.metrics import f1_score\nfrom sklearn.base import clone\n\n# Configuration\nINPUT_DIR = \"./input\"\nTRAIN_FILE = os.path.join(INPUT_DIR, \"train.csv\")\nTEST_FILE = os.path.join(INPUT_DIR, \"test.csv\")\nSUBMISSION_DIR = \"./submission\"\nSUBMISSION_FILE = os.path.join(SUBMISSION_DIR, \"submission.csv\")\nos.makedirs(SUBMISSION_DIR, exist_ok=True)\n\nRANDOM_STATE = 42\nnp.random.seed(RANDOM_STATE)\nrandom.seed(RANDOM_STATE)\n\n# Tunable values\nSAMPLE_TARGET = 15000  # number of training examples to collect\nTOP_K_TAGS = 100  # how many top tags to model\nTFIDF_MAX_FEATURES = 20000\nNGRAM_RANGE = (1, 2)\nCV_FOLDS = 5\nPRED_TOP_K = 3\nREAD_NROWS_FOR_TAGS = 200000\nCHUNKSIZE = 50000\nTEST_CHUNK = 50000\n\n\ndef parse_tags(tagstr):\n    \"\"\"Parse tag strings from multiple formats into a list of tags (lowercased).\"\"\"\n    if pd.isna(tagstr):\n        return []\n    s = str(tagstr).strip()\n    if not s:\n        return []\n    # handle <tag1><tag2> format\n    if \"<\" in s and \">\" in s:\n        tags = re.findall(r\"<([^>]+)>\", s)\n        if tags:\n            return [t.strip().lower() for t in tags if t.strip()]\n    # some Kaggle exports already space-delimited or comma-separated\n    # remove surrounding brackets or quotes\n    s = s.strip(\"[]()\\\"'\")\n    parts = re.split(r\"[,\\s]+\", s)\n    parts = [p.strip().lower() for p in parts if p.strip()]\n    return parts\n\n\ndef get_top_tags_from_head(train_file, top_k=TOP_K_TAGS, nrows=READ_NROWS_FOR_TAGS):\n    counter = Counter()\n    try:\n        tmp = pd.read_csv(train_file, usecols=[\"Tags\"], nrows=nrows)\n        for t in tmp[\"Tags\"].dropna().astype(str):\n            counter.update(parse_tags(t))\n    except Exception:\n        # fallback to smaller read\n        try:\n            tmp = pd.read_csv(\n                train_file, usecols=[\"Tags\"], nrows=50000, engine=\"python\"\n            )\n            for t in tmp[\"Tags\"].dropna().astype(str):\n                counter.update(parse_tags(t))\n        except Exception:\n            pass\n    top_tags = [t for t, _ in counter.most_common(top_k)]\n    print(f\"[info] Collected top {len(top_tags)} tags from head scan.\", file=sys.stderr)\n    return top_tags\n\n\ndef collect_examples_with_top_tags(\n    train_file, top_tags, sample_target=SAMPLE_TARGET, chunksize=CHUNKSIZE\n):\n    \"\"\"\n    Collect up to sample_target examples. Prefer rows containing any top_tags,\n    otherwise include general rows to fill quota.\n    \"\"\"\n    collected = []\n    collected_ids = set()\n    usecols = [\"Id\", \"Title\", \"Body\", \"Tags\"]\n    try:\n        reader = pd.read_csv(\n            train_file, usecols=usecols, chunksize=chunksize, iterator=True\n        )\n    except Exception:\n        reader = pd.read_csv(\n            train_file,\n            usecols=usecols,\n            chunksize=chunksize,\n            iterator=True,\n            engine=\"python\",\n        )\n\n    # First pass: collect rows that contain at least one top tag\n    for chunk in reader:\n        # parse tags vectorized for the chunk\n        chunk_tags = chunk[\"Tags\"].fillna(\"\").astype(str).tolist()\n        parsed = [parse_tags(t) for t in chunk_tags]\n        mask = [any(t in top_tags for t in tags) for tags in parsed]\n        for i, keep in enumerate(mask):\n            if keep:\n                try:\n                    rid = int(chunk.iloc[i][\"Id\"])\n                except Exception:\n                    continue\n                if rid in collected_ids:\n                    continue\n                collected.append(\n                    (\n                        rid,\n                        chunk.iloc[i].get(\"Title\", \"\"),\n                        chunk.iloc[i].get(\"Body\", \"\"),\n                        parsed[i],\n                    )\n                )\n                collected_ids.add(rid)\n                if len(collected) >= sample_target:\n                    break\n        if len(collected) >= sample_target:\n            break\n\n    # If not enough, do a second pass and collect arbitrary rows until target reached\n    if len(collected) < sample_target:\n        print(\n            f\"[info] Only {len(collected)} collected with top-tag preference; filling with more rows.\",\n            file=sys.stderr,\n        )\n        try:\n            reader2 = pd.read_csv(\n                train_file, usecols=usecols, chunksize=chunksize, iterator=True\n            )\n        except Exception:\n            reader2 = pd.read_csv(\n                train_file,\n                usecols=usecols,\n                chunksize=chunksize,\n                iterator=True,\n                engine=\"python\",\n            )\n        for chunk in reader2:\n            for _, row in chunk.iterrows():\n                try:\n                    rid = int(row[\"Id\"])\n                except Exception:\n                    continue\n                if rid in collected_ids:\n                    continue\n                tags = parse_tags(row.get(\"Tags\", \"\"))\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n                if len(collected) >= sample_target:\n                    break\n            if len(collected) >= sample_target:\n                break\n\n    df = pd.DataFrame(collected, columns=[\"Id\", \"Title\", \"Body\", \"ParsedTags\"])\n    print(\n        f\"[info] Collected {len(df)} training examples (target {sample_target}).\",\n        file=sys.stderr,\n    )\n    return df\n\n\ndef build_dataset_from_collected(df, top_tags):\n    df = df.copy()\n    df[\"Title\"] = df[\"Title\"].fillna(\"\").astype(str)\n    df[\"Body\"] = df[\"Body\"].fillna(\"\").astype(str)\n    df[\"text\"] = (\n        (df[\"Title\"] + \" \" + df[\"Body\"]).str.replace(\"\\n\", \" \").str.replace(\"\\r\", \" \")\n    )\n    # filter tags to top_tags only\n    df[\"TagsFiltered\"] = df[\"ParsedTags\"].apply(\n        lambda tags: [t for t in tags if t in top_tags]\n    )\n    before = len(df)\n    df = df[df[\"TagsFiltered\"].map(len) > 0].reset_index(drop=True)\n    after = len(df)\n    if after == 0:\n        # fallback: keep original parsed tags but restrict classes to top_tags at binarization time\n        print(\n            \"[warning] No examples have top tags after filtering; proceeding with unfiltered data.\",\n            file=sys.stderr,\n        )\n        df = df.copy().reset_index(drop=True)\n        y_lists = (\n            df[\"ParsedTags\"].apply(lambda x: x if isinstance(x, list) else []).tolist()\n        )\n    else:\n        print(\n            f\"[info] Filtered dataset to {after} rows from {before} that include at least one top tag.\",\n            file=sys.stderr,\n        )\n        y_lists = (\n            df[\"TagsFiltered\"]\n            .apply(lambda x: x if isinstance(x, list) else [])\n            .tolist()\n        )\n    return df, y_lists\n\n\ndef topk_from_scores(scores, k):\n    n_samples = scores.shape[0]\n    if scores.ndim == 1:\n        scores = scores.reshape(-1, 1)\n    n_classes = scores.shape[1]\n    k = min(k, n_classes)\n    if n_classes == 0 or k == 0:\n        return np.zeros((n_samples, n_classes), dtype=int)\n    # get top-k indices per row\n    idx_sorted = np.argsort(scores, axis=1)\n    topk_idx = idx_sorted[:, -k:]\n    preds = np.zeros((n_samples, n_classes), dtype=int)\n    rows = np.arange(n_samples)[:, None]\n    preds[rows, topk_idx] = 1\n    return preds\n\n\ndef manual_cv_predict_proba(clf, X, Y, cv):\n    n_samples = X.shape[0]\n    n_classes = Y.shape[1]\n    scores = np.zeros((n_samples, n_classes), dtype=float)\n    for fold_i, (train_idx, val_idx) in enumerate(cv.split(X)):\n        X_train = X[train_idx]\n        X_val = X[val_idx]\n        Y_train = Y[train_idx]\n        clf_clone = clone(clf)\n        try:\n            clf_clone.fit(X_train, Y_train)\n        except Exception as e:\n            print(f\"[warning] Fit failed on fold {fold_i}: {e}\", file=sys.stderr)\n            continue\n        got = None\n        try:\n            got = clf_clone.decision_function(X_val)\n        except Exception:\n            try:\n                got = clf_clone.predict_proba(X_val)\n            except Exception:\n                try:\n                    p = clf_clone.predict(X_val)\n                    got = p.astype(float)\n                except Exception as e:\n                    print(\n                        f\"[warning] All predict methods failed on fold {fold_i}: {e}\",\n                        file=sys.stderr,\n                    )\n                    got = np.zeros((len(val_idx), n_classes), dtype=float)\n        got = np.asarray(got)\n        if got.ndim == 1:\n            got = got.reshape(-1, 1)\n        # align columns\n        if got.shape[1] != n_classes:\n            if got.shape[1] > n_classes:\n                got = got[:, :n_classes]\n            else:\n                pad = np.zeros((got.shape[0], n_classes - got.shape[1]), dtype=float)\n                got = np.concatenate([got, pad], axis=1)\n        scores[val_idx] = got\n        print(\n            f\"[info] Finished CV fold {fold_i+1}/{cv.get_n_splits()} (val size={len(val_idx)}).\",\n            file=sys.stderr,\n        )\n    return scores\n\n\ndef main():\n    start_time = time.time()\n    print(\"[info] Starting pipeline...\", file=sys.stderr)\n\n    # 1) Get top tags from head of file\n    top_tags = get_top_tags_from_head(\n        TRAIN_FILE, top_k=TOP_K_TAGS, nrows=READ_NROWS_FOR_TAGS\n    )\n    if len(top_tags) == 0:\n        print(\n            \"[warning] No top tags found from head scan; trying small full scan...\",\n            file=sys.stderr,\n        )\n        try:\n            tmp = pd.read_csv(TRAIN_FILE, usecols=[\"Tags\"], nrows=100000)\n            c = Counter()\n            for t in tmp[\"Tags\"].dropna().astype(str):\n                c.update(parse_tags(t))\n            top_tags = [t for t, _ in c.most_common(TOP_K_TAGS)]\n        except Exception:\n            pass\n    if len(top_tags) == 0:\n        print(\"[error] No tags found; exiting.\", file=sys.stderr)\n        return\n\n    # 2) Collect examples that include at least one top tag (or fallback)\n    sampled_df = collect_examples_with_top_tags(\n        TRAIN_FILE, top_tags, sample_target=SAMPLE_TARGET, chunksize=CHUNKSIZE\n    )\n    if sampled_df.shape[0] == 0:\n        print(\n            \"[error] Failed to collect any training examples; exiting.\", file=sys.stderr\n        )\n        return\n\n    # Recompute top tags from sampled data to align classes\n    all_tags = []\n    for tags in sampled_df[\"ParsedTags\"]:\n        all_tags.extend(tags)\n    tag_counts = Counter(all_tags)\n    top_tags_sampled = [t for t, _ in tag_counts.most_common(TOP_K_TAGS)]\n    if len(top_tags_sampled) > 0:\n        top_tags = top_tags_sampled[:TOP_K_TAGS]\n    print(f\"[info] Final modeling tags: {len(top_tags)}\", file=sys.stderr)\n\n    # 3) Build dataset\n    df, y_lists = build_dataset_from_collected(sampled_df, top_tags)\n    if len(df) < 10:\n        print(\"[error] Too few examples after filtering; exiting.\", file=sys.stderr)\n        return\n\n    texts = df[\"text\"].tolist()\n    ids = df[\"Id\"].tolist()\n\n    # 4) TF-IDF\n    print(\"[info] Fitting TF-IDF...\", file=sys.stderr)\n    vectorizer = TfidfVectorizer(\n        max_features=TFIDF_MAX_FEATURES, ngram_range=NGRAM_RANGE, stop_words=\"english\"\n    )\n    X = vectorizer.fit_transform(texts)\n    print(f\"[info] TF-IDF matrix shape: {X.shape}\", file=sys.stderr)\n\n    # 5) Labels\n    # ensure each y_list contains only tags in top_tags\n    y_lists_filtered = [[t for t in tags if t in top_tags] for tags in y_lists]\n    mlb = MultiLabelBinarizer(classes=top_tags)\n    Y = mlb.fit_transform(y_lists_filtered)\n    classes = list(mlb.classes_)\n    print(f\"[info] Label matrix shape: {Y.shape}\", file=sys.stderr)\n\n    # 6) Model and cross-validation\n    base_clf = LogisticRegression(\n        solver=\"liblinear\", max_iter=200, C=1.0, random_state=RANDOM_STATE\n    )\n    clf = OneVsRestClassifier(base_clf, n_jobs=1)\n\n    n_splits = CV_FOLDS\n    if X.shape[0] < 10:\n        n_splits = 2\n    else:\n        n_splits = min(CV_FOLDS, X.shape[0])\n    print(f\"[info] Running {n_splits}-fold CV...\", file=sys.stderr)\n    kf = KFold(n_splits=n_splits, shuffle=True, random_state=RANDOM_STATE)\n    scores_cv = manual_cv_predict_proba(clf, X, Y, cv=kf)\n    if scores_cv.ndim == 1:\n        scores_cv = scores_cv.reshape(-1, 1)\n    y_pred_cv = topk_from_scores(scores_cv, PRED_TOP_K)\n\n    # align shapes for evaluation\n    if y_pred_cv.shape != Y.shape:\n        min_cols = min(y_pred_cv.shape[1], Y.shape[1])\n        y_pred_cv = y_pred_cv[:, :min_cols]\n        Y_eval = Y[:, :min_cols]\n    else:\n        Y_eval = Y\n\n    try:\n        f1 = f1_score(Y_eval, y_pred_cv, average=\"samples\", zero_division=0)\n    except Exception as e:\n        print(f\"[warning] f1_score computation failed: {e}\", file=sys.stderr)\n        f1 = 0.0\n\n    # Print metric to stdout (as requested)\n    print(f\"{f1:.6f}\")\n    print(f\"[info] Cross-validated sample-wise F1: {f1:.6f}\", file=sys.stderr)\n\n    # 7) Retrain on full sampled data\n    print(\"[info] Retraining classifier on full sampled data...\", file=sys.stderr)\n    try:\n        clf.fit(X, Y)\n    except Exception as e:\n        print(f\"[warning] Full fit failed: {e}\", file=sys.stderr)\n        # Try per-class fallback training\n        try:\n            estimators = []\n            for i in range(Y.shape[1]):\n                ycol = Y[:, i]\n                est = clone(base_clf)\n                est.fit(X, ycol)\n                estimators.append(est)\n            clf.estimators_ = estimators\n        except Exception as e2:\n            print(\n                f\"[error] Fallback per-class training also failed: {e2}\",\n                file=sys.stderr,\n            )\n\n    # 8) Predict test set and write submission\n    print(\"[info] Predicting test set and writing submission...\", file=sys.stderr)\n    sub_rows = []\n    total_test = 0\n    usecols = [\"Id\", \"Title\", \"Body\"]\n    try:\n        test_reader = pd.read_csv(\n            TEST_FILE, usecols=usecols, chunksize=TEST_CHUNK, iterator=True\n        )\n    except Exception:\n        test_reader = pd.read_csv(\n            TEST_FILE,\n            usecols=usecols,\n            chunksize=TEST_CHUNK,\n            iterator=True,\n            engine=\"python\",\n        )\n\n    for chunk in test_reader:\n        chunk_ids = chunk[\"Id\"].tolist()\n        titles = chunk[\"Title\"].fillna(\"\").astype(str).tolist()\n        bodies = chunk[\"Body\"].fillna(\"\").astype(str).tolist()\n        texts_chunk = [\n            (t + \" \" + b).replace(\"\\n\", \" \").replace(\"\\r\", \" \")\n            for t, b in zip(titles, bodies)\n        ]\n        Xtest = vectorizer.transform(texts_chunk)\n\n        scores_test = None\n        try:\n            scores_test = clf.decision_function(Xtest)\n        except Exception:\n            try:\n                scores_test = clf.predict_proba(Xtest)\n            except Exception:\n                preds = clf.predict(Xtest)\n                scores_test = preds.astype(float)\n\n        scores_test = np.asarray(scores_test)\n        if scores_test.ndim == 1:\n            scores_test = scores_test.reshape(-1, 1)\n\n        n_classes_model = len(classes)\n        if scores_test.shape[1] != n_classes_model:\n            if scores_test.shape[1] > n_classes_model:\n                scores_test = scores_test[:, :n_classes_model]\n            else:\n                pad = np.zeros(\n                    (scores_test.shape[0], n_classes_model - scores_test.shape[1]),\n                    dtype=float,\n                )\n                scores_test = np.concatenate([scores_test, pad], axis=1)\n\n        preds_bin = topk_from_scores(scores_test, PRED_TOP_K)\n\n        for i, rid in enumerate(chunk_ids):\n            row_pred = preds_bin[i]\n            if row_pred.sum() == 0:\n                if scores_test.shape[1] > 0:\n                    idx = int(np.argmax(scores_test[i]))\n                    tags = [classes[idx]]\n                else:\n                    tags = []\n            else:\n                lbl_idx = np.where(row_pred == 1)[0]\n                tags = [classes[j] for j in lbl_idx]\n            tags_str = \" \".join(tags)\n            sub_rows.append((int(rid), tags_str))\n        total_test += len(chunk_ids)\n        print(f\"[info] Processed {total_test} test rows...\", file=sys.stderr)\n\n    # write submission CSV\n    print(f\"[info] Writing submission to {SUBMISSION_FILE} ...\", file=sys.stderr)\n    with open(SUBMISSION_FILE, \"w\", encoding=\"utf-8\") as f:\n        f.write(\"Id,Tags\\n\")\n        for rid, tags in sub_rows:\n            safe_tags = tags.replace('\"', \"'\")\n            f.write(f'{rid},\"{safe_tags}\"\\n')\n\n    elapsed = time.time() - start_time\n    print(f\"[info] Done. Time elapsed: {elapsed:.1f} sec\", file=sys.stderr)\n\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\nimport os\nimport re\nimport sys\nimport time\nfrom collections import Counter\nimport random\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.model_selection import KFold\nfrom sklearn.metrics import f1_score\nfrom sklearn.base import clone\n\n# Configuration\nINPUT_DIR = \"./input\"\nTRAIN_FILE = os.path.join(INPUT_DIR, \"train.csv\")\nTEST_FILE = os.path.join(INPUT_DIR, \"test.csv\")\nSUBMISSION_DIR = \"./submission\"\nSUBMISSION_FILE = os.path.join(SUBMISSION_DIR, \"submission.csv\")\nWORKING_SUB = os.path.join(\"./working\", \"submission.csv\")\nos.makedirs(SUBMISSION_DIR, exist_ok=True)\nos.makedirs(\"./working\", exist_ok=True)\n\nRANDOM_STATE = 42\nnp.random.seed(RANDOM_STATE)\nrandom.seed(RANDOM_STATE)\n\n# Tunable values\nSAMPLE_TARGET = 15000  # number of training examples to collect\nTOP_K_TAGS = 100  # how many top tags to model\nTFIDF_MAX_FEATURES = 20000\nNGRAM_RANGE = (1, 2)\nCV_FOLDS = 5\nPRED_TOP_K = 3\nREAD_ROWS_FOR_TAGS = 200000\nCHUNKSIZE = 50000\nTEST_CHUNK = 50000\n\n\ndef parse_tags(tagstr):\n    \"\"\"Parse tag strings from multiple formats into a list of tags (lowercased).\"\"\"\n    if pd.isna(tagstr):\n        return []\n    s = str(tagstr).strip()\n    if not s:\n        return []\n    # handle <tag1><tag2> format\n    if \"<\" in s and \">\" in s:\n        tags = re.findall(r\"<([^>]+)>\", s)\n        if tags:\n            return [t.strip().lower() for t in tags if t.strip()]\n    # remove surrounding brackets or quotes\n    s = s.strip(\"[]()\\\"'\")\n    parts = re.split(r\"[,\\s]+\", s)\n    parts = [p.strip().lower() for p in parts if p.strip()]\n    return parts\n\n\ndef get_top_tags_from_head(train_file, top_k=TOP_K_TAGS, nrows=READ_ROWS_FOR_TAGS):\n    counter = Counter()\n    try:\n        # Try a fast read of first nrows\n        tmp = pd.read_csv(train_file, usecols=[\"Tags\"], nrows=nrows)\n        for t in tmp[\"Tags\"].dropna().astype(str):\n            counter.update(parse_tags(t))\n    except Exception:\n        # Fallback: chunked scan for safety\n        try:\n            for chunk in pd.read_csv(train_file, usecols=[\"Tags\"], chunksize=50000):\n                for t in chunk[\"Tags\"].dropna().astype(str):\n                    counter.update(parse_tags(t))\n                if sum(counter.values()) >= nrows:\n                    break\n        except Exception:\n            pass\n    top_tags = [t for t, _ in counter.most_common(top_k)]\n    print(f\"[info] Collected top {len(top_tags)} tags from head scan.\", file=sys.stderr)\n    return top_tags\n\n\ndef collect_examples_with_top_tags(\n    train_file, top_tags, sample_target=SAMPLE_TARGET, chunksize=CHUNKSIZE\n):\n    \"\"\"\n    Collect up to sample_target examples. Prefer rows containing any top_tags,\n    otherwise include general rows to fill quota.\n    \"\"\"\n    collected = []\n    collected_ids = set()\n    usecols = [\"Id\", \"Title\", \"Body\", \"Tags\"]\n    # First pass: collect rows that contain at least one top tag\n    try:\n        reader = pd.read_csv(train_file, usecols=usecols, chunksize=chunksize)\n    except Exception:\n        reader = pd.read_csv(\n            train_file, usecols=usecols, chunksize=chunksize, engine=\"python\"\n        )\n    for chunk in reader:\n        chunk = chunk.fillna(\"\")\n        tags_col = chunk[\"Tags\"].astype(str).tolist()\n        parsed = [parse_tags(t) for t in tags_col]\n        for i, tags in enumerate(parsed):\n            if any(t in top_tags for t in tags):\n                try:\n                    rid = int(chunk.iloc[i][\"Id\"])\n                except Exception:\n                    continue\n                if rid in collected_ids:\n                    continue\n                collected.append(\n                    (\n                        rid,\n                        chunk.iloc[i].get(\"Title\", \"\"),\n                        chunk.iloc[i].get(\"Body\", \"\"),\n                        tags,\n                    )\n                )\n                collected_ids.add(rid)\n                if len(collected) >= sample_target:\n                    break\n        if len(collected) >= sample_target:\n            break\n\n    # Second pass: fill with arbitrary rows if needed\n    if len(collected) < sample_target:\n        try:\n            reader2 = pd.read_csv(train_file, usecols=usecols, chunksize=chunksize)\n        except Exception:\n            reader2 = pd.read_csv(\n                train_file, usecols=usecols, chunksize=chunksize, engine=\"python\"\n            )\n        for chunk in reader2:\n            chunk = chunk.fillna(\"\")\n            for _, row in chunk.iterrows():\n                try:\n                    rid = int(row[\"Id\"])\n                except Exception:\n                    continue\n                if rid in collected_ids:\n                    continue\n                tags = parse_tags(row.get(\"Tags\", \"\"))\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n                if len(collected) >= sample_target:\n                    break\n            if len(collected) >= sample_target:\n                break\n\n    df = pd.DataFrame(collected, columns=[\"Id\", \"Title\", \"Body\", \"ParsedTags\"])\n    print(\n        f\"[info] Collected {len(df)} training examples (target {sample_target}).\",\n        file=sys.stderr,\n    )\n    return df\n\n\ndef build_dataset_from_collected(df, top_tags):\n    df = df.copy()\n    df[\"Title\"] = df[\"Title\"].fillna(\"\").astype(str)\n    df[\"Body\"] = df[\"Body\"].fillna(\"\").astype(str)\n    df[\"text\"] = (\n        (df[\"Title\"] + \" \" + df[\"Body\"]).str.replace(\"\\n\", \" \").str.replace(\"\\r\", \" \")\n    )\n    # filter tags to top_tags\n    df[\"TagsFiltered\"] = df[\"ParsedTags\"].apply(\n        lambda tags: [t for t in tags if t in top_tags]\n    )\n    before = len(df)\n    df = df[df[\"TagsFiltered\"].map(len) > 0].reset_index(drop=True)\n    after = len(df)\n    if after == 0:\n        print(\n            \"[warning] No examples have top tags after filtering; proceeding with unfiltered data.\",\n            file=sys.stderr,\n        )\n        y_lists = (\n            df[\"ParsedTags\"].apply(lambda x: x if isinstance(x, list) else []).tolist()\n        )\n    else:\n        print(\n            f\"[info] Filtered dataset to {after} rows from {before} that include at least one top tag.\",\n            file=sys.stderr,\n        )\n        y_lists = (\n            df[\"TagsFiltered\"]\n            .apply(lambda x: x if isinstance(x, list) else [])\n            .tolist()\n        )\n    return df, y_lists\n\n\ndef topk_from_scores(scores, k):\n    n_samples = scores.shape[0]\n    if scores.ndim == 1:\n        scores = scores.reshape(-1, 1)\n    n_classes = scores.shape[1]\n    k = min(k, n_classes)\n    if n_classes == 0 or k == 0:\n        return np.zeros((n_samples, n_classes), dtype=int)\n    idx_sorted = np.argsort(scores, axis=1)\n    topk_idx = idx_sorted[:, -k:]\n    preds = np.zeros((n_samples, n_classes), dtype=int)\n    rows = np.arange(n_samples)[:, None]\n    preds[rows, topk_idx] = 1\n    return preds\n\n\ndef manual_cv_predict_proba(clf, X, Y, cv, n_classes):\n    \"\"\"\n    For each fold, fit clf and collect per-class scores for validation indices.\n    Align columns to n_classes by padding/trimming as needed.\n    \"\"\"\n    n_samples = X.shape[0]\n    scores = np.zeros((n_samples, n_classes), dtype=float)\n    for fold_i, (train_idx, val_idx) in enumerate(cv.split(X)):\n        X_train = X[train_idx]\n        X_val = X[val_idx]\n        Y_train = Y[train_idx]\n        clf_clone = clone(clf)\n        try:\n            clf_clone.fit(X_train, Y_train)\n        except Exception as e:\n            print(f\"[warning] Fit failed on fold {fold_i}: {e}\", file=sys.stderr)\n            # leave scores zeros for these val indices\n            continue\n        got = None\n        try:\n            got = clf_clone.decision_function(X_val)\n        except Exception:\n            try:\n                got = clf_clone.predict_proba(X_val)\n            except Exception:\n                try:\n                    p = clf_clone.predict(X_val)\n                    got = p.astype(float)\n                except Exception as e:\n                    print(\n                        f\"[warning] All predict methods failed on fold {fold_i}: {e}\",\n                        file=sys.stderr,\n                    )\n                    got = np.zeros((len(val_idx), n_classes), dtype=float)\n        got = np.asarray(got)\n        if got.ndim == 1:\n            got = got.reshape(-1, 1)\n        # Align columns: got.shape[1] may be <= n_classes if some classes not seen in training\n        if got.shape[1] != n_classes:\n            if got.shape[1] > n_classes:\n                got = got[:, :n_classes]\n            else:\n                pad = np.zeros((got.shape[0], n_classes - got.shape[1]), dtype=float)\n                got = np.concatenate([got, pad], axis=1)\n        scores[val_idx] = got\n        print(\n            f\"[info] Finished CV fold {fold_i+1}/{cv.get_n_splits()} (val size={len(val_idx)}).\",\n            file=sys.stderr,\n        )\n    return scores\n\n\ndef main():\n    start_time = time.time()\n    print(\"[info] Starting pipeline...\", file=sys.stderr)\n\n    # 1) Get top tags from head of file\n    top_tags = get_top_tags_from_head(\n        TRAIN_FILE, top_k=TOP_K_TAGS, nrows=READ_ROWS_FOR_TAGS\n    )\n    if len(top_tags) == 0:\n        # last resort: scan smaller amount\n        try:\n            tmp = pd.read_csv(TRAIN_FILE, usecols=[\"Tags\"], nrows=50000)\n            c = Counter()\n            for t in tmp[\"Tags\"].dropna().astype(str):\n                c.update(parse_tags(t))\n            top_tags = [t for t, _ in c.most_common(TOP_K_TAGS)]\n        except Exception:\n            pass\n    if len(top_tags) == 0:\n        print(\"[error] No tags found; exiting.\", file=sys.stderr)\n        return\n\n    # 2) Collect examples\n    sampled_df = collect_examples_with_top_tags(\n        TRAIN_FILE, top_tags, sample_target=SAMPLE_TARGET, chunksize=CHUNKSIZE\n    )\n    if sampled_df.shape[0] == 0:\n        print(\n            \"[error] Failed to collect any training examples; exiting.\", file=sys.stderr\n        )\n        return\n\n    # Recompute top tags from sampled data\n    all_tags = []\n    for tags in sampled_df[\"ParsedTags\"]:\n        all_tags.extend(tags)\n    tag_counts = Counter(all_tags)\n    top_tags_sampled = [t for t, _ in tag_counts.most_common(TOP_K_TAGS)]\n    if len(top_tags_sampled) > 0:\n        top_tags = top_tags_sampled[:TOP_K_TAGS]\n    print(f\"[info] Final modeling tags: {len(top_tags)}\", file=sys.stderr)\n\n    # 3) Build dataset\n    df, y_lists = build_dataset_from_collected(sampled_df, top_tags)\n    if len(df) < 10:\n        print(\"[error] Too few examples after filtering; exiting.\", file=sys.stderr)\n        return\n\n    texts = df[\"text\"].tolist()\n    ids = df[\"Id\"].tolist()\n\n    # 4) TF-IDF\n    print(\"[info] Fitting TF-IDF...\", file=sys.stderr)\n    vectorizer = TfidfVectorizer(\n        max_features=TFIDF_MAX_FEATURES, ngram_range=NGRAM_RANGE, stop_words=\"english\"\n    )\n    X = vectorizer.fit_transform(texts)\n    print(f\"[info] TF-IDF matrix shape: {X.shape}\", file=sys.stderr)\n\n    # 5) Labels\n    y_lists_filtered = [[t for t in tags if t in top_tags] for tags in y_lists]\n    mlb = MultiLabelBinarizer(classes=top_tags)\n    Y = mlb.fit_transform(y_lists_filtered)\n    classes = list(mlb.classes_)\n    print(f\"[info] Label matrix shape: {Y.shape}\", file=sys.stderr)\n\n    # 6) Model and cross-validation\n    base_clf = LogisticRegression(\n        solver=\"liblinear\", max_iter=200, C=1.0, random_state=RANDOM_STATE\n    )\n    clf = OneVsRestClassifier(base_clf, n_jobs=1)\n\n    n_splits = CV_FOLDS\n    if X.shape[0] < 10:\n        n_splits = 2\n    else:\n        n_splits = min(CV_FOLDS, X.shape[0])\n        if n_splits < 2:\n            n_splits = 2\n    print(f\"[info] Running {n_splits}-fold CV...\", file=sys.stderr)\n    kf = KFold(n_splits=n_splits, shuffle=True, random_state=RANDOM_STATE)\n    scores_cv = manual_cv_predict_proba(clf, X, Y, cv=kf, n_classes=Y.shape[1])\n    if scores_cv.ndim == 1:\n        scores_cv = scores_cv.reshape(-1, 1)\n    y_pred_cv = topk_from_scores(scores_cv, PRED_TOP_K)\n\n    # align shapes for evaluation\n    if y_pred_cv.shape != Y.shape:\n        min_cols = min(y_pred_cv.shape[1], Y.shape[1])\n        y_pred_cv = y_pred_cv[:, :min_cols]\n        Y_eval = Y[:, :min_cols]\n    else:\n        Y_eval = Y\n\n    try:\n        f1 = f1_score(Y_eval, y_pred_cv, average=\"samples\", zero_division=0)\n    except Exception as e:\n        print(f\"[warning] f1_score computation failed: {e}\", file=sys.stderr)\n        f1 = 0.0\n\n    # Print metric to stdout\n    print(f\"{f1:.6f}\")\n    print(f\"[info] Cross-validated sample-wise F1: {f1:.6f}\", file=sys.stderr)\n\n    # 7) Retrain on full sampled data\n    print(\"[info] Retraining classifier on full sampled data...\", file=sys.stderr)\n    try:\n        clf.fit(X, Y)\n    except Exception as e:\n        print(f\"[warning] Full fit failed: {e}\", file=sys.stderr)\n        # Try per-class fallback training\n        try:\n            estimators = []\n            for i in range(Y.shape[1]):\n                ycol = Y[:, i]\n                est = clone(base_clf)\n                est.fit(X, ycol)\n                estimators.append(est)\n            clf.estimators_ = estimators\n        except Exception as e2:\n            print(\n                f\"[error] Fallback per-class training also failed: {e2}\",\n                file=sys.stderr,\n            )\n\n    # 8) Predict test set and write submission\n    print(\"[info] Predicting test set and writing submission...\", file=sys.stderr)\n    sub_rows = []\n    total_test = 0\n    usecols = [\"Id\", \"Title\", \"Body\"]\n    try:\n        test_reader = pd.read_csv(TEST_FILE, usecols=usecols, chunksize=TEST_CHUNK)\n    except Exception:\n        test_reader = pd.read_csv(\n            TEST_FILE, usecols=usecols, chunksize=TEST_CHUNK, engine=\"python\"\n        )\n\n    for chunk in test_reader:\n        chunk = chunk.fillna(\"\")\n        chunk_ids = chunk[\"Id\"].tolist()\n        titles = chunk[\"Title\"].astype(str).tolist()\n        bodies = chunk[\"Body\"].astype(str).tolist()\n        texts_chunk = [\n            (t + \" \" + b).replace(\"\\n\", \" \").replace(\"\\r\", \" \")\n            for t, b in zip(titles, bodies)\n        ]\n        Xtest = vectorizer.transform(texts_chunk)\n\n        scores_test = None\n        try:\n            scores_test = clf.decision_function(Xtest)\n        except Exception:\n            try:\n                scores_test = clf.predict_proba(Xtest)\n            except Exception:\n                preds = clf.predict(Xtest)\n                scores_test = preds.astype(float)\n\n        scores_test = np.asarray(scores_test)\n        if scores_test.ndim == 1:\n            scores_test = scores_test.reshape(-1, 1)\n\n        n_classes_model = len(classes)\n        if scores_test.shape[1] != n_classes_model:\n            if scores_test.shape[1] > n_classes_model:\n                scores_test = scores_test[:, :n_classes_model]\n            else:\n                pad = np.zeros(\n                    (scores_test.shape[0], n_classes_model - scores_test.shape[1]),\n                    dtype=float,\n                )\n                scores_test = np.concatenate([scores_test, pad], axis=1)\n\n        preds_bin = topk_from_scores(scores_test, PRED_TOP_K)\n\n        for i, rid in enumerate(chunk_ids):\n            row_pred = preds_bin[i]\n            if row_pred.sum() == 0:\n                if scores_test.shape[1] > 0:\n                    idx = int(np.argmax(scores_test[i]))\n                    tags = [classes[idx]]\n                else:\n                    tags = []\n            else:\n                lbl_idx = np.where(row_pred == 1)[0]\n                tags = [classes[j] for j in lbl_idx]\n            tags_str = \" \".join(tags)\n            sub_rows.append((int(rid), tags_str))\n        total_test += len(chunk_ids)\n        print(f\"[info] Processed {total_test} test rows...\", file=sys.stderr)\n\n    # write submission CSV\n    print(f\"[info] Writing submission to {SUBMISSION_FILE} ...\", file=sys.stderr)\n    with open(SUBMISSION_FILE, \"w\", encoding=\"utf-8\") as f:\n        f.write(\"Id,Tags\\n\")\n        for rid, tags in sub_rows:\n            safe_tags = tags.replace('\"', \"'\")\n            f.write(f'{rid},\"{safe_tags}\"\\n')\n\n    # also copy to working directory for convenience\n    try:\n        import shutil\n\n        shutil.copyfile(SUBMISSION_FILE, WORKING_SUB)\n    except Exception:\n        pass\n\n    elapsed = time.time() - start_time\n    print(f\"[info] Done. Time elapsed: {elapsed:.1f} sec\", file=sys.stderr)\n\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python3\nimport os\nimport re\nimport sys\nimport time\nfrom collections import Counter\nimport random\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import KFold\nfrom sklearn.metrics import f1_score\nfrom sklearn.base import clone\n\n# Configuration\nINPUT_DIR = \"./input\"\nTRAIN_FILE = os.path.join(INPUT_DIR, \"train.csv\")\nTEST_FILE = os.path.join(INPUT_DIR, \"test.csv\")\nSUBMISSION_DIR = \"./submission\"\nSUBMISSION_FILE = os.path.join(SUBMISSION_DIR, \"submission.csv\")\nWORKING_SUB = os.path.join(\"./working\", \"submission.csv\")\nos.makedirs(SUBMISSION_DIR, exist_ok=True)\nos.makedirs(\"./working\", exist_ok=True)\n\nRANDOM_STATE = 42\nnp.random.seed(RANDOM_STATE)\nrandom.seed(RANDOM_STATE)\n\n# Tunable values (reduced for speed and robustness)\nSAMPLE_TARGET = 20000  # number of training examples to collect\nTOP_K_TAGS = 50  # how many top tags to model\nTFIDF_MAX_FEATURES = 10000\nNGRAM_RANGE = (1, 2)\nCV_FOLDS = 5\nPRED_TOP_K = 3\nREAD_ROWS_FOR_TAGS = 200000\nCHUNKSIZE = 50000\nTEST_CHUNK = 50000\n\n\ndef parse_tags(tagstr):\n    \"\"\"Parse tag strings from multiple formats into a list of tags (lowercased).\"\"\"\n    if pd.isna(tagstr):\n        return []\n    s = str(tagstr).strip()\n    if not s:\n        return []\n    # handle <tag1><tag2> format\n    if \"<\" in s and \">\" in s:\n        tags = re.findall(r\"<([^>]+)>\", s)\n        if tags:\n            return [t.strip().lower() for t in tags if t.strip()]\n    # remove surrounding brackets or quotes\n    s = s.strip(\"[]()\\\"'\")\n    # tags are often space-separated or comma-separated\n    parts = re.split(r\"[,\\s]+\", s)\n    parts = [p.strip().lower() for p in parts if p.strip()]\n    return parts\n\n\ndef get_top_tags_from_head(train_file, top_k=TOP_K_TAGS, nrows=READ_ROWS_FOR_TAGS):\n    counter = Counter()\n    try:\n        tmp = pd.read_csv(train_file, usecols=[\"Tags\"], nrows=nrows)\n        for t in tmp[\"Tags\"].dropna().astype(str):\n            counter.update(parse_tags(t))\n    except Exception:\n        # fallback chunked\n        try:\n            for chunk in pd.read_csv(train_file, usecols=[\"Tags\"], chunksize=50000):\n                for t in chunk[\"Tags\"].dropna().astype(str):\n                    counter.update(parse_tags(t))\n                if sum(counter.values()) >= nrows:\n                    break\n        except Exception:\n            pass\n    top_tags = [t for t, _ in counter.most_common(top_k)]\n    print(f\"[info] Collected top {len(top_tags)} tags from head scan.\", file=sys.stderr)\n    return top_tags\n\n\ndef collect_examples_with_top_tags(\n    train_file, top_tags, sample_target=SAMPLE_TARGET, chunksize=CHUNKSIZE\n):\n    \"\"\"\n    Collect up to sample_target examples. Prefer rows containing any top_tags,\n    otherwise include general rows to fill quota.\n    \"\"\"\n    collected = []\n    collected_ids = set()\n    usecols = [\"Id\", \"Title\", \"Body\", \"Tags\"]\n    try:\n        reader = pd.read_csv(train_file, usecols=usecols, chunksize=chunksize)\n    except Exception:\n        reader = pd.read_csv(\n            train_file, usecols=usecols, chunksize=chunksize, engine=\"python\"\n        )\n    # First pass: collect rows that contain at least one top tag\n    for chunk in reader:\n        chunk = chunk.fillna(\"\")\n        tags_col = chunk[\"Tags\"].astype(str).tolist()\n        parsed = [parse_tags(t) for t in tags_col]\n        for i, tags in enumerate(parsed):\n            if any(t in top_tags for t in tags):\n                try:\n                    rid = int(chunk.iloc[i][\"Id\"])\n                except Exception:\n                    continue\n                if rid in collected_ids:\n                    continue\n                collected.append(\n                    (\n                        rid,\n                        chunk.iloc[i].get(\"Title\", \"\"),\n                        chunk.iloc[i].get(\"Body\", \"\"),\n                        tags,\n                    )\n                )\n                collected_ids.add(rid)\n                if len(collected) >= sample_target:\n                    break\n        if len(collected) >= sample_target:\n            break\n\n    # Second pass: fill with arbitrary rows if needed\n    if len(collected) < sample_target:\n        try:\n            reader2 = pd.read_csv(train_file, usecols=usecols, chunksize=chunksize)\n        except Exception:\n            reader2 = pd.read_csv(\n                train_file, usecols=usecols, chunksize=chunksize, engine=\"python\"\n            )\n        for chunk in reader2:\n            chunk = chunk.fillna(\"\")\n            for _, row in chunk.iterrows():\n                try:\n                    rid = int(row[\"Id\"])\n                except Exception:\n                    continue\n                if rid in collected_ids:\n                    continue\n                tags = parse_tags(row.get(\"Tags\", \"\"))\n                collected.append((rid, row.get(\"Title\", \"\"), row.get(\"Body\", \"\"), tags))\n                collected_ids.add(rid)\n                if len(collected) >= sample_target:\n                    break\n            if len(collected) >= sample_target:\n                break\n\n    df = pd.DataFrame(collected, columns=[\"Id\", \"Title\", \"Body\", \"ParsedTags\"])\n    print(\n        f\"[info] Collected {len(df)} training examples (target {sample_target}).\",\n        file=sys.stderr,\n    )\n    return df\n\n\ndef build_dataset_from_collected(df, top_tags):\n    df = df.copy()\n    df[\"Title\"] = df[\"Title\"].fillna(\"\").astype(str)\n    df[\"Body\"] = df[\"Body\"].fillna(\"\").astype(str)\n    df[\"text\"] = (\n        (df[\"Title\"] + \" \" + df[\"Body\"]).str.replace(\"\\n\", \" \").str.replace(\"\\r\", \" \")\n    )\n    # filter tags to top_tags\n    df[\"TagsFiltered\"] = df[\"ParsedTags\"].apply(\n        lambda tags: [t for t in tags if t in top_tags]\n    )\n    before = len(df)\n    df = df[df[\"TagsFiltered\"].map(len) > 0].reset_index(drop=True)\n    after = len(df)\n    if after == 0:\n        # fallback: do not filter tags, use parsed tags as-is but limit to rows that have any tags\n        print(\n            \"[warning] No examples have top tags after filtering; falling back to unfiltered parsed tags.\",\n            file=sys.stderr,\n        )\n        df = df.copy()\n        df[\"TagsFiltered\"] = df[\"ParsedTags\"]\n        df = df[df[\"TagsFiltered\"].map(len) > 0].reset_index(drop=True)\n    else:\n        print(\n            f\"[info] Filtered dataset to {after} rows from {before} that include at least one top tag.\",\n            file=sys.stderr,\n        )\n    y_lists = df[\"TagsFiltered\"].tolist()\n    return df, y_lists\n\n\ndef topk_from_scores(scores, k):\n    n_samples = scores.shape[0]\n    if scores.ndim == 1:\n        scores = scores.reshape(-1, 1)\n    n_classes = scores.shape[1]\n    k = min(k, n_classes)\n    if n_classes == 0 or k == 0:\n        return np.zeros((n_samples, n_classes), dtype=int)\n    idx_sorted = np.argsort(scores, axis=1)\n    topk_idx = idx_sorted[:, -k:]\n    preds = np.zeros((n_samples, n_classes), dtype=int)\n    rows = np.arange(n_samples)[:, None]\n    preds[rows, topk_idx] = 1\n    return preds\n\n\ndef manual_cv_predict_proba_per_class(base_clf, X, Y, cv):\n    \"\"\"\n    Train per-class binary classifiers inside each fold and collect validation scores.\n    Returns scores shape (n_samples, n_classes).\n    \"\"\"\n    n_samples = X.shape[0]\n    n_classes = Y.shape[1]\n    scores = np.zeros((n_samples, n_classes), dtype=float)\n    for fold_i, (train_idx, val_idx) in enumerate(cv.split(X)):\n        X_train = X[train_idx]\n        X_val = X[val_idx]\n        Y_train = Y[train_idx]\n        # for each class train a clone of base_clf\n        for j in range(n_classes):\n            yj = Y_train[:, j]\n            # skip if all same label in training => constant prediction\n            if np.all(yj == 0) or np.all(yj == 1):\n                # assign constant low or high score\n                val_score = np.full(len(val_idx), float(np.all(yj == 1)))\n                scores[val_idx, j] = val_score\n                continue\n            clf_j = clone(base_clf)\n            try:\n                clf_j.fit(X_train, yj)\n            except Exception as e:\n                # fallback: try smaller max_iter\n                try:\n                    clf_j = clone(base_clf)\n                    clf_j.max_iter = 100\n                    clf_j.fit(X_train, yj)\n                except Exception:\n                    # leave zeros\n                    continue\n            got = None\n            try:\n                got = clf_j.decision_function(X_val)\n            except Exception:\n                try:\n                    prob = clf_j.predict_proba(X_val)\n                    # take probability of positive class if available\n                    if prob.ndim == 2 and prob.shape[1] == 2:\n                        got = prob[:, 1]\n                    else:\n                        # if binary as single column\n                        got = prob.ravel()\n                except Exception:\n                    try:\n                        p = clf_j.predict(X_val)\n                        got = p.astype(float)\n                    except Exception:\n                        got = np.zeros(len(val_idx), dtype=float)\n            got = np.asarray(got).ravel()\n            scores[val_idx, j] = got\n        print(\n            f\"[info] Finished CV fold {fold_i+1}/{cv.get_n_splits()} (val size={len(val_idx)}).\",\n            file=sys.stderr,\n        )\n    return scores\n\n\ndef train_per_class_full(base_clf, X, Y):\n    n_classes = Y.shape[1]\n    estimators = []\n    for j in range(n_classes):\n        yj = Y[:, j]\n        if np.all(yj == 0) or np.all(yj == 1):\n            estimators.append(None)  # mark as constant\n            continue\n        clf_j = clone(base_clf)\n        try:\n            clf_j.fit(X, yj)\n            estimators.append(clf_j)\n        except Exception:\n            try:\n                clf_j.max_iter = 100\n                clf_j.fit(X, yj)\n                estimators.append(clf_j)\n            except Exception:\n                estimators.append(None)\n    return estimators\n\n\ndef predict_per_class(estimators, X):\n    n_samples = X.shape[0]\n    n_classes = len(estimators)\n    scores = np.zeros((n_samples, n_classes), dtype=float)\n    for j, est in enumerate(estimators):\n        if est is None:\n            # unknown: keep zeros\n            continue\n        got = None\n        try:\n            got = est.decision_function(X)\n        except Exception:\n            try:\n                prob = est.predict_proba(X)\n                if prob.ndim == 2 and prob.shape[1] == 2:\n                    got = prob[:, 1]\n                else:\n                    got = prob.ravel()\n            except Exception:\n                try:\n                    p = est.predict(X)\n                    got = p.astype(float)\n                except Exception:\n                    got = np.zeros(n_samples, dtype=float)\n        got = np.asarray(got).ravel()\n        # ensure length matches\n        if got.shape[0] != n_samples:\n            got = np.resize(got, n_samples)\n        scores[:, j] = got\n    return scores\n\n\ndef main():\n    start_time = time.time()\n    print(\"[info] Starting pipeline...\", file=sys.stderr)\n\n    # 1) Get top tags from head of file\n    top_tags = get_top_tags_from_head(\n        TRAIN_FILE, top_k=TOP_K_TAGS, nrows=READ_ROWS_FOR_TAGS\n    )\n    if len(top_tags) == 0:\n        # last resort: scan smaller amount\n        try:\n            tmp = pd.read_csv(TRAIN_FILE, usecols=[\"Tags\"], nrows=50000)\n            c = Counter()\n            for t in tmp[\"Tags\"].dropna().astype(str):\n                c.update(parse_tags(t))\n            top_tags = [t for t, _ in c.most_common(TOP_K_TAGS)]\n        except Exception:\n            pass\n    if len(top_tags) == 0:\n        print(\"[error] No tags found; exiting.\", file=sys.stderr)\n        return\n\n    # 2) Collect examples\n    sampled_df = collect_examples_with_top_tags(\n        TRAIN_FILE, top_tags, sample_target=SAMPLE_TARGET, chunksize=CHUNKSIZE\n    )\n    if sampled_df.shape[0] == 0:\n        print(\n            \"[error] Failed to collect any training examples; exiting.\", file=sys.stderr\n        )\n        return\n\n    # Recompute top tags from sampled data to prioritize actually present tags\n    all_tags = []\n    for tags in sampled_df[\"ParsedTags\"]:\n        all_tags.extend(tags)\n    tag_counts = Counter(all_tags)\n    top_tags_sampled = [t for t, _ in tag_counts.most_common(TOP_K_TAGS)]\n    if len(top_tags_sampled) > 0:\n        top_tags = top_tags_sampled[:TOP_K_TAGS]\n    print(f\"[info] Final modeling tags: {len(top_tags)}\", file=sys.stderr)\n\n    # 3) Build dataset\n    df, y_lists = build_dataset_from_collected(sampled_df, top_tags)\n    if len(df) < 10:\n        print(\"[error] Too few examples after filtering; exiting.\", file=sys.stderr)\n        return\n\n    texts = df[\"text\"].tolist()\n    ids = df[\"Id\"].tolist()\n\n    # 4) TF-IDF\n    print(\"[info] Fitting TF-IDF...\", file=sys.stderr)\n    vectorizer = TfidfVectorizer(\n        max_features=TFIDF_MAX_FEATURES, ngram_range=NGRAM_RANGE, stop_words=\"english\"\n    )\n    X = vectorizer.fit_transform(texts)\n    print(f\"[info] TF-IDF matrix shape: {X.shape}\", file=sys.stderr)\n\n    # 5) Labels\n    # Ensure tags kept are only top_tags\n    y_lists_filtered = [[t for t in tags if t in top_tags] for tags in y_lists]\n    mlb = MultiLabelBinarizer(classes=top_tags)\n    Y = mlb.fit_transform(y_lists_filtered)\n    classes = list(mlb.classes_)\n    print(f\"[info] Label matrix shape: {Y.shape}\", file=sys.stderr)\n\n    # 6) Model and cross-validation (per-class training inside folds)\n    base_clf = LogisticRegression(\n        solver=\"liblinear\", max_iter=200, C=1.0, random_state=RANDOM_STATE\n    )\n    n_splits = CV_FOLDS\n    if X.shape[0] < 10:\n        n_splits = 2\n    else:\n        n_splits = min(CV_FOLDS, X.shape[0])\n        if n_splits < 2:\n            n_splits = 2\n    print(f\"[info] Running {n_splits}-fold CV (per-class)...\", file=sys.stderr)\n    kf = KFold(n_splits=n_splits, shuffle=True, random_state=RANDOM_STATE)\n    scores_cv = manual_cv_predict_proba_per_class(base_clf, X, Y, cv=kf)\n    if scores_cv.ndim == 1:\n        scores_cv = scores_cv.reshape(-1, 1)\n    y_pred_cv = topk_from_scores(scores_cv, PRED_TOP_K)\n\n    # align shapes for evaluation\n    if y_pred_cv.shape != Y.shape:\n        min_cols = min(y_pred_cv.shape[1], Y.shape[1])\n        y_pred_cv = y_pred_cv[:, :min_cols]\n        Y_eval = Y[:, :min_cols]\n    else:\n        Y_eval = Y\n\n    try:\n        f1 = f1_score(Y_eval, y_pred_cv, average=\"samples\", zero_division=0)\n    except Exception as e:\n        print(f\"[warning] f1_score computation failed: {e}\", file=sys.stderr)\n        f1 = 0.0\n\n    # Print metric to stdout\n    print(f\"{f1:.6f}\")\n    print(f\"[info] Cross-validated sample-wise F1: {f1:.6f}\", file=sys.stderr)\n\n    # 7) Retrain per-class on full sampled data\n    print(\n        \"[info] Retraining per-class classifiers on full sampled data...\",\n        file=sys.stderr,\n    )\n    estimators = train_per_class_full(base_clf, X, Y)\n\n    # 8) Predict test set and write submission\n    print(\"[info] Predicting test set and writing submission...\", file=sys.stderr)\n    sub_rows = []\n    total_test = 0\n    usecols = [\"Id\", \"Title\", \"Body\"]\n    try:\n        test_reader = pd.read_csv(TEST_FILE, usecols=usecols, chunksize=TEST_CHUNK)\n    except Exception:\n        test_reader = pd.read_csv(\n            TEST_FILE, usecols=usecols, chunksize=TEST_CHUNK, engine=\"python\"\n        )\n\n    for chunk in test_reader:\n        chunk = chunk.fillna(\"\")\n        chunk_ids = chunk[\"Id\"].tolist()\n        titles = chunk[\"Title\"].astype(str).tolist()\n        bodies = chunk[\"Body\"].astype(str).tolist()\n        texts_chunk = [\n            (t + \" \" + b).replace(\"\\n\", \" \").replace(\"\\r\", \" \")\n            for t, b in zip(titles, bodies)\n        ]\n        Xtest = vectorizer.transform(texts_chunk)\n\n        scores_test = predict_per_class(estimators, Xtest)\n        # Ensure shape aligns with classes length\n        n_classes_model = len(classes)\n        if scores_test.shape[1] != n_classes_model:\n            if scores_test.shape[1] > n_classes_model:\n                scores_test = scores_test[:, :n_classes_model]\n            else:\n                pad = np.zeros(\n                    (scores_test.shape[0], n_classes_model - scores_test.shape[1]),\n                    dtype=float,\n                )\n                scores_test = np.concatenate([scores_test, pad], axis=1)\n\n        preds_bin = topk_from_scores(scores_test, PRED_TOP_K)\n\n        for i, rid in enumerate(chunk_ids):\n            row_pred = preds_bin[i]\n            if row_pred.sum() == 0:\n                if scores_test.shape[1] > 0:\n                    idx = int(np.argmax(scores_test[i]))\n                    tags = [classes[idx]]\n                else:\n                    tags = []\n            else:\n                lbl_idx = np.where(row_pred == 1)[0]\n                tags = [classes[j] for j in lbl_idx]\n            tags_str = \" \".join(tags)\n            sub_rows.append((int(rid), tags_str))\n        total_test += len(chunk_ids)\n        print(f\"[info] Processed {total_test} test rows...\", file=sys.stderr)\n\n    # write submission CSV\n    print(f\"[info] Writing submission to {SUBMISSION_FILE} ...\", file=sys.stderr)\n    with open(SUBMISSION_FILE, \"w\", encoding=\"utf-8\") as f:\n        f.write(\"Id,Tags\\n\")\n        for rid, tags in sub_rows:\n            safe_tags = tags.replace('\"', \"'\")\n            f.write(f'{rid},\"{safe_tags}\"\\n')\n\n    # also copy to working directory for convenience\n    try:\n        import shutil\n\n        shutil.copyfile(SUBMISSION_FILE, WORKING_SUB)\n    except Exception:\n        pass\n\n    elapsed = time.time() - start_time\n    print(f\"[info] Done. Time elapsed: {elapsed:.1f} sec\", file=sys.stderr)\n\n\nif __name__ == \"__main__\":\n    main()\n"], "term_out": ["<OMITTED>", "<OMITTED>", "Loading a sample of the training data (nrows=100000)...\nLoaded train sample shape: (100000, 4)\nTop 300 tags (sample): ['c#', 'java', 'php', 'javascript', 'android', 'jquery', 'c++', 'python', 'iphone', 'asp.net', 'mysql', 'html', '.net', 'sql', 'ios', 'linux', 'css', 'objective-c', 'ruby-on-rails', 'c']\nLabel matrix shape: (100000, 300)\nFitting TF-IDF vectorizer (max_features=30000)...\nText features shape: (100000, 30000)\nStarting 5-fold cross-validation...\n Fold 1\n  Fold 1 sample-wise F1: 0.388188\n Fold 2\n  Fold 2 sample-wise F1: 0.385352\n Fold 3\n  Fold 3 sample-wise F1: 0.383852\n Fold 4\n  Fold 4 sample-wise F1: 0.382986\n Fold 5\n  Fold 5 sample-wise F1: 0.385427\nCross-validation mean sample-wise F1: 0.385161\nRetraining classifier on full sampled training data...\nLoading test data and preparing submission predictions...\nSelecting top-3 tags for each test example...\nWrote submission to: ./submission/submission.csv\nDone. CV mean sample-wise F1: 0.38516066666666665\nExecution time: 4 minutes seconds (time limit is 9 hours).", "Execution time: a moment seconds (time limit is 9 hours).", "<OMITTED>", "Execution time: a moment seconds (time limit is 9 hours).", "Loading training sample...\nTrain sample shape: (100000, 4)\nSelected top-1000 tags (unique found in sample): 1000\nRows with at least one top-1000 tag: 93941 (dropped 6059)\nNumber of classes (after binarizer): 1000\nLabel matrix shape: (93941, 1000)\nFitting TF-IDF vectorizer...\nTF-IDF matrix shape: (93941, 30000)\nStarting 3-fold cross-validation on sampled data...\nFold 1 - training on 62627 samples, validating on 31314 samples\nFold 1 F1 (samples): 0.33923\nFold 2 - training on 62627 samples, validating on 31314 samples\nFold 2 F1 (samples): 0.33982\nFold 3 - training on 62628 samples, validating on 31313 samples\nFold 3 F1 (samples): 0.33954\n3-fold mean sample-wise F1: 0.33953\nRetraining on full sampled training data...\nFinal model trained.\nProcessing test set and writing submission...\nProcessed test chunk 1, wrote 50000 rows.\nProcessed test chunk 2, wrote 50000 rows.\nProcessed test chunk 3, wrote 50000 rows.\nProcessed test chunk 4, wrote 50000 rows.\nProcessed test chunk 5, wrote 50000 rows.\nProcessed test chunk 6, wrote 50000 rows.\nProcessed test chunk 7, wrote 50000 rows.\nProcessed test chunk 8, wrote 50000 rows.\nProcessed test chunk 9, wrote 50000 rows.\nProcessed test chunk 10, wrote 50000 rows.\nProcessed test chunk 11, wrote 50000 rows.\nProcessed test chunk 12, wrote 50000 rows.\nProcessed test chunk 13, wrote 3420 rows.\nSubmission saved to ./submission/submission.csv\nCross-validation mean sample-wise F1: 0.339530\nExecution time: 7 minutes seconds (time limit is 9 hours).", "Execution time: a moment seconds (time limit is 9 hours).", "Execution time: a moment seconds (time limit is 9 hours).", "Execution time: a moment seconds (time limit is 9 hours).", "Execution time: a moment seconds (time limit is 9 hours).", "Execution time: a moment seconds (time limit is 9 hours).", "Execution time: a moment seconds (time limit is 9 hours).", "Execution time: a moment seconds (time limit is 9 hours).", "Execution time: a moment seconds (time limit is 9 hours).", "Execution time: a moment seconds (time limit is 9 hours).", "Execution time: a moment seconds (time limit is 9 hours).", "Execution time: a moment seconds (time limit is 9 hours).", "Execution time: a moment seconds (time limit is 9 hours).", "Execution time: a moment seconds (time limit is 9 hours)."], "analysis": ["The run crashed during preprocessing: applying .split() to the Tags column raised AttributeError 'float' object has no attribute 'split', indicating missing/NaN tag values. Training and cross-validation did not run and no submission.csv was produced.", "Code ran successfully, trained a multi-label TF-IDF + OneVsRest(SGD) model on 100k sampled rows using the top 200 tags. 5-fold cross-validation produced a mean sample-wise F1 of 0.394224 and a submission file was written to ./submission/submission.csv.", "The training script ran successfully and produced a submission file at ./submission/submission.csv. Using a 100k-sample, TF-IDF (30k features) and a One-vs-Rest SGD classifier with top-300 tags, 5-fold CV yielded a mean sample-wise F1 \u2248 0.38516.", "The execution log only shows a single timing line and no training or prediction output. The script did not produce cross-validated F1 or write a submission.csv, indicating the run failed or did not execute properly. No evaluation metric is available.", "The training script ran to completion without errors, produced a submission CSV at ./submission/submission.csv, and reported a cross-validated mean sample-wise F1 of about 0.402738. The CV F1 scores were stable across folds (~0.4008\u20130.4046); the pipeline used the top 300 tags, 120k training examples, a 100k-feature TF-IDF, and a One-vs-Rest MultinomialNB predicting 3 tags per question.", "The execution output contains no training logs or metric\u2014only a generic 'Execution time' line\u2014so the run appears to have failed or not produced the expected output. Because of that I cannot find a generated submission.csv or a reported validation metric. The code also contains at least one logic bug (during test-time fallback it uses scores_test[0] instead of per-row scores), which would produce incorrect tag selection for many rows even if the run completed.", "The script ran successfully with no errors. It trained on a sampled set (100k rows, 93,941 retained after filtering to top-1000 tags), achieved a 3-fold mean sample-wise F1 of 0.33953, and wrote the submission to ./submission/submission.csv after processing all test chunks.", "The run produced no training or prediction logs and did not write a submission file at ./submission/submission.csv. No validation metric (F1) was printed, so the training/prediction steps appear to have failed or not executed.", "Execution produced no training or validation logs and did not print the reported cross-validated F1 to stdout. There is no evidence that a submission file was written to ./submission/submission.csv. It appears the script did not complete or no data was processed during this run.", "The run produced only a single generic execution-time line and no training or prediction logs, indicating the script did not execute fully or output was suppressed. Consequently no submission.csv was produced and no validation metric is available.", "The execution log only contains a single line indicating execution time and no other training or progress output. No submission.csv appears to have been produced and no validation metric was reported, so the run did not complete successfully or produced no outputs.", "The execution output only shows a generic execution time and no logs from the training script, indicating the script did not produce its usual stderr/info messages or complete successfully. No evidence of a generated submission.csv is present in the output.", "The execution produced no runtime logs beyond a generic execution-time message; there is no evidence the training/prediction run completed or that submission/submission.csv was written. The run appears to have failed or produced no captured output.", "Run produced only minimal execution output and did not create submission/submission.csv. Likely failure due to missing input files (script expects ./input/train.csv but dataset is usually in ./data), causing early exit; no validation metric is available.", "No training logs or metric output were produced beyond a brief execution time message. There is no evidence that a submission file was written to ./submission/submission.csv, so the run appears to have failed or exited before producing a result.", "The training script appears to have run to completion and produced a submission file at ./submission/submission.csv. The run printed a cross-validated sample-wise F1 to stdout in the script, but that numeric value is not present in the provided execution log, so the exact metric cannot be reported.", "The execution output contains no training logs or submission output \u2014 only 'Execution time' was reported. I cannot confirm that the pipeline executed end-to-end or that submission/submission.csv was produced; no validation metric was printed.", "The execution log only contains a single line 'Execution time: a moment seconds' with no pipeline info, no CV metric printed, and no evidence of a submission.csv being created. This indicates the run terminated without producing the expected outputs (likely a silent failure or early exit).", "The run produced no informative logs or metric output (only a short execution-time line). There is no evidence that the pipeline completed or that a submission file was written to ./submission/submission.csv. As a result, no validation metric is available.", "The execution log contains only a single line 'Execution time...' and no training or evaluation output (no cross-validated F1 printed and no stderr info lines). There is no evidence the script ran to completion or produced submission/submission.csv in the provided output."], "exp_name": "exp", "metrics": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}

let lastClick = 0;
let firstFrameTime = undefined;

let nodes = [];
let edges = [];

let lastScrollPos = 0;

setup = () => {
  canvas = createCanvas(...updateTargetDims());
};

class Node {
  x;
  y;
  size;
  xT;
  yT;
  xB;
  yB;
  treeInd;
  color;
  relSize;
  animationStart = Number.MAX_VALUE;
  animationProgress = 0;
  isStatic = false;
  hasChildren = false;
  isRootNode = true;
  isStarred = false;
  selected = false;
  renderSize = 10;
  edges = [];
  bgCol;

  constructor(x, y, relSize, treeInd) {
    const minSize = 35;
    const maxSize = 60;

    const maxColor = 10;
    const minColor = 125;

    this.relSize = relSize;
    this.treeInd = treeInd;
    this.size = minSize + (maxSize - minSize) * relSize;
    this.color = minColor + (maxColor - minColor) * relSize;
    this.bgCol = Math.round(Math.max(this.color / 2, 0));

    this.x = x;
    this.y = y;
    this.xT = x;
    this.yT = y - this.size / 2;
    this.xB = x;
    this.yB = y + this.size / 2;

    nodes.push(this);
  }

  startAnimation = (offset = 0) => {
    if (this.animationStart == Number.MAX_VALUE)
      this.animationStart = globalTime + offset;
  };

  child = (node) => {
    let edge = new Edge(this, node);
    this.edges.push(edge);
    edges.push(edge);
    this.hasChildren = true;
    node.isRootNode = false;
    return node;
  };

  render = () => {
    if (globalTime - this.animationStart < 0) return;

    const mouseXlocalCoords = (mouseX - width / 2) / scaleFactor;
    const mouseYlocalCoords = (mouseY - height / 2) / scaleFactor;
    const isMouseOver =
      dist(mouseXlocalCoords, mouseYlocalCoords, this.x, this.y) <
      this.renderSize / 1.5;
    if (isMouseOver) cursor(HAND);
    if (isMouseOver && mouseIsPressed) {
      nodes.forEach((n) => (n.selected = false));
      this.selected = true;
      setCodeAndPlan(
        treeStructData.code[this.treeInd],
        treeStructData.plan[this.treeInd],
      );
      manualSelection = true;
    }

    this.renderSize = this.size;
    if (!this.isStatic) {
      this.animationProgress = animEase(
        (globalTime - this.animationStart) / 1000,
      );
      if (this.animationProgress >= 1) {
        this.isStatic = true;
      } else {
        this.renderSize =
          this.size *
          (0.8 +
            0.2 *
              (-3.33 * this.animationProgress ** 2 +
                4.33 * this.animationProgress));
      }
    }

    fill(this.color);
    if (this.selected) {
      fill(accentCol);
    }

    noStroke();
    square(
      this.x - this.renderSize / 2,
      this.y - this.renderSize / 2,
      this.renderSize,
      10,
    );

    noStroke();
    textAlign(CENTER, CENTER);
    textSize(this.renderSize / 2);
    fill(255);
    // fill(lerpColor(color(accentCol), color(255), this.animationProgress))
    text("{ }", this.x, this.y - 1);
    // DEBUG PRINT:
    // text(round(this.relSize, 2), this.x, this.y - 1)
    // text(this.treeInd, this.x, this.y + 15)

    const dotAnimThreshold = 0.85;
    if (this.isStarred && this.animationProgress >= dotAnimThreshold) {
      let dotAnimProgress =
        (this.animationProgress - dotAnimThreshold) / (1 - dotAnimThreshold);
      textSize(
        ((-3.33 * dotAnimProgress ** 2 + 4.33 * dotAnimProgress) *
          this.renderSize) /
          2,
      );
      if (this.selected) {
        fill(0);
        stroke(0);
      } else {
        fill(accentCol);
        stroke(accentCol);
      }
      strokeWeight((-(dotAnimProgress ** 2) + dotAnimProgress) * 2);
      text("*", this.x + 20, this.y - 11);
      noStroke();
    }

    if (!this.isStatic) {
      fill(bgCol);
      const progressAnimBaseSize = this.renderSize + 5;
      rect(
        this.x - progressAnimBaseSize / 2,
        this.y -
          progressAnimBaseSize / 2 +
          progressAnimBaseSize * this.animationProgress,
        progressAnimBaseSize,
        progressAnimBaseSize * (1 - this.animationProgress),
      );
    }
    if (this.animationProgress >= 0.9) {
      this.edges
        .sort((a, b) => a.color() - b.color())
        .forEach((e, i) => {
          e.startAnimation((i / this.edges.length) ** 2 * 1000);
        });
    }
  };
}

class Edge {
  nodeT;
  nodeB;
  animX = 0;
  animY = 0;
  animationStart = Number.MAX_VALUE;
  animationProgress = 0;
  isStatic = false;
  weight = 0;

  constructor(nodeT, nodeB) {
    this.nodeT = nodeT;
    this.nodeB = nodeB;
    this.weight = 2 + nodeB.relSize * 1;
  }

  color = () => this.nodeB.color;

  startAnimation = (offset = 0) => {
    if (this.animationStart == Number.MAX_VALUE)
      this.animationStart = globalTime + offset;
  };

  render = () => {
    if (globalTime - this.animationStart < 0) return;

    if (!this.isStatic) {
      this.animationProgress = animEase(
        (globalTime - this.animationStart) / 1000,
      );
      if (this.animationProgress >= 1) {
        this.isStatic = true;
        this.animX = this.nodeB.xT;
        this.animY = this.nodeB.yT;
      } else {
        this.animX = bezierPoint(
          this.nodeT.xB,
          this.nodeT.xB,
          this.nodeB.xT,
          this.nodeB.xT,
          this.animationProgress,
        );

        this.animY = bezierPoint(
          this.nodeT.yB,
          (this.nodeT.yB + this.nodeB.yT) / 2,
          (this.nodeT.yB + this.nodeB.yT) / 2,
          this.nodeB.yT,
          this.animationProgress,
        );
      }
    }
    if (this.animationProgress >= 0.97) {
      this.nodeB.startAnimation();
    }

    strokeWeight(this.weight);
    noFill();
    stroke(
      lerpColor(color(bgCol), color(accentCol), this.nodeB.relSize * 1 + 0.7),
    );
    bezier(
      this.nodeT.xB,
      this.nodeT.yB,
      this.nodeT.xB,
      (this.nodeT.yB + this.nodeB.yT) / 2,
      this.animX,
      (this.nodeT.yB + this.nodeB.yT) / 2,
      this.animX,
      this.animY,
    );
  };
}

draw = () => {
  cursor(ARROW);
  frameRate(120);
  if (!firstFrameTime && frameCount <= 1) {
    firstFrameTime = millis();
  }
  // ---- update global animation state ----
  const initialSpeedScalingEaseIO =
    (cos(min((millis() - firstFrameTime) / 8000, 1.0) * PI) + 1) / 2;
  const initialSpeedScalingEase =
    (cos(min((millis() - firstFrameTime) / 8000, 1.0) ** (1 / 2) * PI) + 1) / 2;
  const initAnimationSpeedFactor = 1.0 - 0.4 * initialSpeedScalingEaseIO;
  // update global scaling-aware clock
  globalTime += globalAnimSpeed * initAnimationSpeedFactor * deltaTime;

  if (nodes.length == 0) {
    const spacingHeight = height * 1.3;
    const spacingWidth = width * 1.3;
    treeStructData.layout.forEach((lay, index) => {
      new Node(
        spacingWidth * lay[0] - spacingWidth / 2,
        20 + spacingHeight * lay[1] - spacingHeight / 2,
        1 - treeStructData.metrics[index],
        index,
      );
    });
    treeStructData.edges.forEach((ind) => {
      nodes[ind[0]].child(nodes[ind[1]]);
    });
    nodes.forEach((n) => {
      if (n.isRootNode) n.startAnimation();
    });
    nodes[0].selected = true;
    setCodeAndPlan(
      treeStructData.code[0],
      treeStructData.plan[0],
    )
  }

  const staticNodes = nodes.filter(
    (n) => n.isStatic || n.animationProgress >= 0.7,
  );
  if (staticNodes.length > 0) {
    const largestNode = staticNodes.reduce((prev, current) =>
      prev.relSize > current.relSize ? prev : current,
    );
    if (!manualSelection) {
      if (!largestNode.selected) {
        setCodeAndPlan(
          treeStructData.code[largestNode.treeInd],
          treeStructData.plan[largestNode.treeInd],
        );
      }
      staticNodes.forEach((node) => {
        node.selected = node === largestNode;
      });
    }
  }
  background(bgCol);
  // global animation transforms
  translate(width / 2, height / 2);
  scale(scaleFactor);

  
  // ---- fg render ----
  edges.forEach((e) => e.render());
  nodes.forEach((n) => n.render());
  
};

    </script>
    <title>AIDE Run Visualization</title>
    <style>
      body,
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        overflow: scroll;
      }
      body {
        background-color: #f2f0e7;
      }
      canvas {
        float: left;
        height: 100vh;
        width: 40vw;
      }
      #text-container {
        float: right;
        height: 100vh;
        width: 50vw;
        background-color: #282c34;
      }
      #plan {
        /* border-left: 2px solid #282c34; */
        background-color: #282c34;
        color: #f2f0e7;
        min-height: 5rem;
        padding: 1em 0 1em 1em;
      }
    </style>
  </head>
  <body>
    <pre
      id="text-container"
    ><div id="plan"></div><hr><code id="code" class="language-python"></code></pre>
  </body>
</html>
